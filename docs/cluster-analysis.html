<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="Problems and Solutions in Applied Statistics" />
<meta property="og:type" content="book" />
<meta property="og:url" content="<a href="http://ritsokiguess.site/pasias" class="uri">http://ritsokiguess.site/pasias</a>" />

<meta property="og:description" content="A set of problems and solutions, in R, on various parts of applied statistics" />
<meta name="github-repo" content="nxskok/pasias" />

<meta name="author" content="Ken Butler" />

<meta name="date" content="2019-01-07" />

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>

<meta name="description" content="A set of problems and solutions, in R, on various parts of applied statistics">

<title>Problems and Solutions in Applied Statistics</title>

<link href="libs/tufte-css-2015.12.29/tufte-fonts.css" rel="stylesheet" />
<link href="libs/tufte-css-2015.12.29/tufte-background.css" rel="stylesheet" />
<link href="libs/tufte-css-2015.12.29/tufte-italics.css" rel="stylesheet" />
<link href="libs/tufte-css-2015.12.29/tufte.css" rel="stylesheet" />


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<link rel="stylesheet" href="toc.css" type="text/css" />

</head>

<body>



<div class="row">
<div class="col-sm-12">
<div id="TOC">
<ul>
<li><a href="index.html#introduction"><span class="toc-section-number">1</span> Introduction</a></li>
<li><a href="packages-used-somewhere-in-this-book.html#packages-used-somewhere-in-this-book"><span class="toc-section-number">2</span> Packages used somewhere in this book</a></li>
<li class="has-sub"><a href="getting-used-to-r-and-r-studio.html#getting-used-to-r-and-r-studio"><span class="toc-section-number">3</span> Getting used to R and R Studio</a><ul>
<li><a href="getting-used-to-r-and-r-studio.html#getting-an-r-studio-cloud-account"><span class="toc-section-number">3.1</span> Getting an R Studio Cloud account</a></li>
<li><a href="getting-used-to-r-and-r-studio.html#getting-started"><span class="toc-section-number">3.2</span> Getting started</a></li>
<li><a href="getting-used-to-r-and-r-studio.html#reading-data-from-a-file"><span class="toc-section-number">3.3</span> Reading data from a file</a></li>
<li><a href="getting-used-to-r-and-r-studio.html#reading-files-different-ways"><span class="toc-section-number">3.4</span> Reading files different ways</a></li>
</ul></li>
<li class="has-sub"><a href="reading-in-data-and-drawing-some-graphs.html#reading-in-data-and-drawing-some-graphs"><span class="toc-section-number">4</span> Reading in data and drawing some graphs</a><ul>
<li><a href="reading-in-data-and-drawing-some-graphs.html#orange-juice"><span class="toc-section-number">4.1</span> Orange juice</a></li>
<li><a href="reading-in-data-and-drawing-some-graphs.html#making-soap"><span class="toc-section-number">4.2</span> Making soap</a></li>
<li><a href="reading-in-data-and-drawing-some-graphs.html#handling-shipments"><span class="toc-section-number">4.3</span> Handling shipments</a></li>
</ul></li>
<li class="has-sub"><a href="data-exploration.html#data-exploration"><span class="toc-section-number">5</span> Data exploration</a><ul>
<li><a href="data-exploration.html#north-carolina-births"><span class="toc-section-number">5.1</span> North Carolina births</a></li>
<li><a href="data-exploration.html#more-about-the-nc-births"><span class="toc-section-number">5.2</span> More about the NC births</a></li>
<li><a href="data-exploration.html#nenana-alaska"><span class="toc-section-number">5.3</span> Nenana, Alaska</a></li>
<li><a href="data-exploration.html#computerized-accounting"><span class="toc-section-number">5.4</span> Computerized accounting</a></li>
<li><a href="data-exploration.html#test-scores-in-two-classes"><span class="toc-section-number">5.5</span> Test scores in two classes</a></li>
</ul></li>
<li class="has-sub"><a href="one-sample-inference.html#one-sample-inference"><span class="toc-section-number">6</span> One-sample inference</a><ul>
<li><a href="one-sample-inference.html#hunter-gatherers-in-australia"><span class="toc-section-number">6.1</span> Hunter-gatherers in Australia</a></li>
<li><a href="one-sample-inference.html#buses-to-boulder"><span class="toc-section-number">6.2</span> Buses to Boulder</a></li>
<li><a href="one-sample-inference.html#length-of-gestation-in-north-carolina"><span class="toc-section-number">6.3</span> Length of gestation in North Carolina</a></li>
<li><a href="one-sample-inference.html#inferring-ice-break-up-in-nenana"><span class="toc-section-number">6.4</span> Inferring ice break-up in Nenana</a></li>
</ul></li>
<li class="has-sub"><a href="two-sample-inference.html#two-sample-inference"><span class="toc-section-number">7</span> Two-sample inference</a><ul>
<li><a href="two-sample-inference.html#children-and-electronic-devices"><span class="toc-section-number">7.1</span> Children and electronic devices</a></li>
<li><a href="two-sample-inference.html#parking-close-to-the-curb"><span class="toc-section-number">7.2</span> Parking close to the curb</a></li>
<li><a href="two-sample-inference.html#bell-peppers-and-too-much-water"><span class="toc-section-number">7.3</span> Bell peppers and too much water</a></li>
<li><a href="two-sample-inference.html#exercise-and-anxiety-and-bullying-mice"><span class="toc-section-number">7.4</span> Exercise and anxiety and bullying mice</a></li>
<li><a href="two-sample-inference.html#diet-and-growth-in-boys"><span class="toc-section-number">7.5</span> Diet and growth in boys</a></li>
</ul></li>
<li class="has-sub"><a href="power-and-sample-size.html#power-and-sample-size"><span class="toc-section-number">8</span> Power and sample size</a><ul>
<li><a href="power-and-sample-size.html#simulating-power"><span class="toc-section-number">8.1</span> Simulating power</a></li>
<li><a href="power-and-sample-size.html#calculating-power-and-sample-size-for-estimating-mean"><span class="toc-section-number">8.2</span> Calculating power and sample size for estimating mean</a></li>
<li><a href="power-and-sample-size.html#simulating-power-for-proportions"><span class="toc-section-number">8.3</span> Simulating power for proportions</a></li>
</ul></li>
<li class="has-sub"><a href="the-sign-test-and-moods-median-test.html#the-sign-test-and-moods-median-test"><span class="toc-section-number">9</span> The sign test and Mood’s median test</a><ul>
<li><a href="the-sign-test-and-moods-median-test.html#running-a-maze"><span class="toc-section-number">9.1</span> Running a maze</a></li>
<li><a href="the-sign-test-and-moods-median-test.html#chocolate-chips"><span class="toc-section-number">9.2</span> Chocolate chips</a></li>
<li><a href="the-sign-test-and-moods-median-test.html#the-power-of-the-sign-test"><span class="toc-section-number">9.3</span> The power of the sign test</a></li>
<li><a href="the-sign-test-and-moods-median-test.html#sugar-in-breakfast-cereals"><span class="toc-section-number">9.4</span> Sugar in breakfast cereals</a></li>
<li><a href="the-sign-test-and-moods-median-test.html#fear-of-math"><span class="toc-section-number">9.5</span> Fear of math</a></li>
<li><a href="the-sign-test-and-moods-median-test.html#medical-instructions"><span class="toc-section-number">9.6</span> Medical instructions</a></li>
</ul></li>
<li class="has-sub"><a href="matched-pairs-t-and-sign-test.html#matched-pairs-t-and-sign-test"><span class="toc-section-number">10</span> Matched pairs t and sign test</a><ul>
<li><a href="matched-pairs-t-and-sign-test.html#measuring-body-fat"><span class="toc-section-number">10.1</span> Measuring body fat</a></li>
<li><a href="matched-pairs-t-and-sign-test.html#throwing-baseballs-and-softballs"><span class="toc-section-number">10.2</span> Throwing baseballs and softballs</a></li>
<li><a href="matched-pairs-t-and-sign-test.html#throwing-baseballs-and-softballs-again"><span class="toc-section-number">10.3</span> Throwing baseballs and softballs, again</a></li>
<li><a href="matched-pairs-t-and-sign-test.html#changes-in-salary"><span class="toc-section-number">10.4</span> Changes in salary</a></li>
<li><a href="matched-pairs-t-and-sign-test.html#body-fat-revisited"><span class="toc-section-number">10.5</span> Body fat revisited</a></li>
</ul></li>
<li class="has-sub"><a href="normal-quantile-plots.html#normal-quantile-plots"><span class="toc-section-number">11</span> Normal quantile plots</a><ul>
<li><a href="normal-quantile-plots.html#lengths-of-heliconia-flowers"><span class="toc-section-number">11.1</span> Lengths of heliconia flowers</a></li>
<li><a href="normal-quantile-plots.html#ferritin-and-normality"><span class="toc-section-number">11.2</span> Ferritin and normality</a></li>
</ul></li>
<li class="has-sub"><a href="analysis-of-variance.html#analysis-of-variance"><span class="toc-section-number">12</span> Analysis of variance</a><ul>
<li><a href="analysis-of-variance.html#movie-ratings-and-lengths"><span class="toc-section-number">12.1</span> Movie ratings and lengths</a></li>
<li><a href="analysis-of-variance.html#deer-and-how-much-they-eat"><span class="toc-section-number">12.2</span> Deer and how much they eat</a></li>
<li><a href="analysis-of-variance.html#movie-ratings-again"><span class="toc-section-number">12.3</span> Movie ratings again</a></li>
<li><a href="analysis-of-variance.html#atomic-weight-of-carbon"><span class="toc-section-number">12.4</span> Atomic weight of carbon</a></li>
<li><a href="analysis-of-variance.html#can-caffeine-improve-your-performance-on-a-test"><span class="toc-section-number">12.5</span> Can caffeine improve your performance on a test?</a></li>
</ul></li>
<li class="has-sub"><a href="tidying-and-selecting-data.html#tidying-and-selecting-data"><span class="toc-section-number">13</span> Tidying and selecting data</a><ul>
<li><a href="tidying-and-selecting-data.html#tidying-the-jays-data"><span class="toc-section-number">13.1</span> Tidying the Jays data</a></li>
<li><a href="tidying-and-selecting-data.html#baseball-and-softball-spaghetti"><span class="toc-section-number">13.2</span> Baseball and softball spaghetti</a></li>
<li><a href="tidying-and-selecting-data.html#ethanol-and-sleep-time-in-rats"><span class="toc-section-number">13.3</span> Ethanol and sleep time in rats</a></li>
<li><a href="tidying-and-selecting-data.html#growth-of-tomatoes"><span class="toc-section-number">13.4</span> Growth of tomatoes</a></li>
<li><a href="tidying-and-selecting-data.html#pain-relief-in-migraine-headaches-again"><span class="toc-section-number">13.5</span> Pain relief in migraine headaches (again)</a></li>
<li><a href="tidying-and-selecting-data.html#location-species-and-disease-in-plants"><span class="toc-section-number">13.6</span> Location, species and disease in plants</a></li>
<li><a href="tidying-and-selecting-data.html#mating-songs-in-crickets"><span class="toc-section-number">13.7</span> Mating songs in crickets</a></li>
<li><a href="tidying-and-selecting-data.html#cars"><span class="toc-section-number">13.8</span> Cars</a></li>
<li><a href="tidying-and-selecting-data.html#number-1-songs"><span class="toc-section-number">13.9</span> Number 1 songs</a></li>
<li><a href="tidying-and-selecting-data.html#bikes-on-college"><span class="toc-section-number">13.10</span> Bikes on College</a></li>
<li><a href="tidying-and-selecting-data.html#feeling-the-heat"><span class="toc-section-number">13.11</span> Feeling the heat</a></li>
</ul></li>
<li class="has-sub"><a href="regression.html#regression"><span class="toc-section-number">14</span> Regression</a><ul>
<li><a href="regression.html#rainfall-in-california"><span class="toc-section-number">14.1</span> Rainfall in California</a></li>
<li><a href="regression.html#carbon-monoxide-in-cigarettes"><span class="toc-section-number">14.2</span> Carbon monoxide in cigarettes</a></li>
<li><a href="regression.html#maximal-oxygen-uptake-in-young-boys"><span class="toc-section-number">14.3</span> Maximal oxygen uptake in young boys</a></li>
<li><a href="regression.html#facebook-friends-and-grey-matter"><span class="toc-section-number">14.4</span> Facebook friends and grey matter</a></li>
<li><a href="regression.html#endogenous-nitrogen-excretion-in-carp"><span class="toc-section-number">14.5</span> Endogenous nitrogen excretion in carp</a></li>
<li><a href="regression.html#sparrowhawks"><span class="toc-section-number">14.6</span> Sparrowhawks</a></li>
<li><a href="regression.html#salaries-of-social-workers"><span class="toc-section-number">14.7</span> Salaries of social workers</a></li>
<li><a href="regression.html#predicting-volume-of-wood-in-pine-trees"><span class="toc-section-number">14.8</span> Predicting volume of wood in pine trees</a></li>
<li><a href="regression.html#tortoise-shells-and-eggs"><span class="toc-section-number">14.9</span> Tortoise shells and eggs</a></li>
<li><a href="regression.html#crickets-revisited"><span class="toc-section-number">14.10</span> Crickets revisited</a></li>
<li><a href="regression.html#roller-coasters"><span class="toc-section-number">14.11</span> Roller coasters</a></li>
<li><a href="regression.html#running-and-blood-sugar"><span class="toc-section-number">14.12</span> Running and blood sugar</a></li>
<li><a href="regression.html#calories-and-fat-in-pizza"><span class="toc-section-number">14.13</span> Calories and fat in pizza</a></li>
<li><a href="regression.html#where-should-the-fire-stations-be"><span class="toc-section-number">14.14</span> Where should the fire stations be?</a></li>
<li><a href="regression.html#being-satisfied-with-hospital"><span class="toc-section-number">14.15</span> Being satisfied with hospital</a></li>
<li><a href="regression.html#handling-shipments-of-chemicals"><span class="toc-section-number">14.16</span> Handling shipments of chemicals</a></li>
<li><a href="regression.html#salaries-of-mathematicians"><span class="toc-section-number">14.17</span> Salaries of mathematicians</a></li>
<li><a href="regression.html#predicting-gpa-of-computer-science-students"><span class="toc-section-number">14.18</span> Predicting GPA of computer science students</a></li>
</ul></li>
<li class="has-sub"><a href="dates-and-times.html#dates-and-times"><span class="toc-section-number">15</span> Dates and times</a><ul>
<li><a href="dates-and-times.html#dealing-with-dates-in-the-worcester-heart-attack-study"><span class="toc-section-number">15.1</span> Dealing with dates in the Worcester Heart Attack study</a></li>
<li><a href="dates-and-times.html#growth-of-mizuna-lettuce-seeds"><span class="toc-section-number">15.2</span> Growth of Mizuna lettuce seeds</a></li>
<li><a href="dates-and-times.html#types-of-childbirth"><span class="toc-section-number">15.3</span> Types of childbirth</a></li>
<li><a href="dates-and-times.html#wolves-and-caribou"><span class="toc-section-number">15.4</span> Wolves and caribou</a></li>
</ul></li>
<li class="has-sub"><a href="functions.html#functions"><span class="toc-section-number">16</span> Functions</a><ul>
<li><a href="functions.html#making-some-r-functions"><span class="toc-section-number">16.1</span> Making some R functions</a></li>
<li><a href="functions.html#the-collatz-sequence"><span class="toc-section-number">16.2</span> The Collatz sequence</a></li>
</ul></li>
<li class="has-sub"><a href="the-bootstrap.html#the-bootstrap"><span class="toc-section-number">17</span> The Bootstrap</a><ul>
<li><a href="the-bootstrap.html#air-conditioning-failures"><span class="toc-section-number">17.1</span> Air conditioning failures</a></li>
<li><a href="the-bootstrap.html#air-conditioning-failures-bootstrapping-the-median"><span class="toc-section-number">17.2</span> Air conditioning failures: bootstrapping the median</a></li>
</ul></li>
<li class="has-sub"><a href="bayesian-statistics-with-rstan.html#bayesian-statistics-with-rstan"><span class="toc-section-number">18</span> Bayesian Statistics with <code>rstan</code></a><ul>
<li><a href="bayesian-statistics-with-rstan.html#estimating-proportion-in-favour-from-a-survey"><span class="toc-section-number">18.1</span> Estimating proportion in favour from a survey</a></li>
<li><a href="bayesian-statistics-with-rstan.html#bayesian-regression"><span class="toc-section-number">18.2</span> Bayesian regression</a></li>
</ul></li>
<li class="has-sub"><a href="logistic-regression.html#logistic-regression"><span class="toc-section-number">19</span> Logistic regression</a><ul>
<li><a href="logistic-regression.html#finding-wolf-spiders-on-the-beach"><span class="toc-section-number">19.1</span> Finding wolf spiders on the beach</a></li>
<li><a href="logistic-regression.html#killing-aphids"><span class="toc-section-number">19.2</span> Killing aphids</a></li>
<li><a href="logistic-regression.html#the-effects-of-substance-a"><span class="toc-section-number">19.3</span> The effects of Substance A</a></li>
<li><a href="logistic-regression.html#what-makes-an-animal-get-infected"><span class="toc-section-number">19.4</span> What makes an animal get infected?</a></li>
<li><a href="logistic-regression.html#the-brain-of-a-cat"><span class="toc-section-number">19.5</span> The brain of a cat</a></li>
<li><a href="logistic-regression.html#how-not-to-get-heart-disease"><span class="toc-section-number">19.6</span> How not to get heart disease</a></li>
<li><a href="logistic-regression.html#successful-breastfeeding"><span class="toc-section-number">19.7</span> Successful breastfeeding</a></li>
<li><a href="logistic-regression.html#making-it-over-the-mountains"><span class="toc-section-number">19.8</span> Making it over the mountains</a></li>
<li><a href="logistic-regression.html#who-needs-the-most-intensive-care"><span class="toc-section-number">19.9</span> Who needs the most intensive care?</a></li>
<li><a href="logistic-regression.html#go-away-and-dont-come-back"><span class="toc-section-number">19.10</span> Go away and don’t come back!</a></li>
</ul></li>
<li class="has-sub"><a href="logistic-regression-with-ordinal-or-nominal-response.html#logistic-regression-with-ordinal-or-nominal-response"><span class="toc-section-number">20</span> Logistic regression with ordinal or nominal response</a><ul>
<li><a href="logistic-regression-with-ordinal-or-nominal-response.html#do-you-like-your-mobile-phone"><span class="toc-section-number">20.1</span> Do you like your mobile phone?</a></li>
<li><a href="logistic-regression-with-ordinal-or-nominal-response.html#attitudes-towards-abortion"><span class="toc-section-number">20.2</span> Attitudes towards abortion</a></li>
<li><a href="logistic-regression-with-ordinal-or-nominal-response.html#finding-non-missing-values"><span class="toc-section-number">20.3</span> Finding non-missing values</a></li>
<li><a href="logistic-regression-with-ordinal-or-nominal-response.html#european-social-survey-and-voting"><span class="toc-section-number">20.4</span> European Social Survey and voting</a></li>
<li><a href="logistic-regression-with-ordinal-or-nominal-response.html#alligator-food"><span class="toc-section-number">20.5</span> Alligator food</a></li>
<li><a href="logistic-regression-with-ordinal-or-nominal-response.html#how-do-you-like-your-steak-the-data"><span class="toc-section-number">20.6</span> How do you like your steak – the data</a></li>
<li><a href="logistic-regression-with-ordinal-or-nominal-response.html#crimes-in-san-francisco-the-data"><span class="toc-section-number">20.7</span> Crimes in San Francisco – the data</a></li>
<li><a href="logistic-regression-with-ordinal-or-nominal-response.html#how-do-you-like-your-steak"><span class="toc-section-number">20.8</span> How do you like your steak?</a></li>
<li><a href="logistic-regression-with-ordinal-or-nominal-response.html#crimes-in-san-francisco"><span class="toc-section-number">20.9</span> Crimes in San Francisco</a></li>
<li><a href="logistic-regression-with-ordinal-or-nominal-response.html#high-school-and-beyond"><span class="toc-section-number">20.10</span> High School and Beyond</a></li>
<li><a href="logistic-regression-with-ordinal-or-nominal-response.html#what-sports-do-these-athletes-play"><span class="toc-section-number">20.11</span> What sports do these athletes play?</a></li>
</ul></li>
<li class="has-sub"><a href="survival-analysis.html#survival-analysis"><span class="toc-section-number">21</span> Survival analysis</a><ul>
<li><a href="survival-analysis.html#the-worcester-survey"><span class="toc-section-number">21.1</span> The Worcester survey</a></li>
<li><a href="survival-analysis.html#drug-treatment-programs"><span class="toc-section-number">21.2</span> Drug treatment programs</a></li>
<li><a href="survival-analysis.html#multiple-myeloma"><span class="toc-section-number">21.3</span> Multiple myeloma</a></li>
<li><a href="survival-analysis.html#ovarian-cancer"><span class="toc-section-number">21.4</span> Ovarian cancer</a></li>
</ul></li>
<li class="has-sub"><a href="analysis-of-variance-revisited.html#analysis-of-variance-revisited"><span class="toc-section-number">22</span> Analysis of variance revisited</a><ul>
<li><a href="analysis-of-variance-revisited.html#acid-rain"><span class="toc-section-number">22.1</span> Acid rain</a></li>
<li><a href="analysis-of-variance-revisited.html#treating-hay-fever"><span class="toc-section-number">22.2</span> Treating hay fever</a></li>
<li><a href="analysis-of-variance-revisited.html#focused-comparisons-of-the-effect-of-caffeine"><span class="toc-section-number">22.3</span> Focused comparisons of the effect of caffeine</a></li>
<li><a href="analysis-of-variance-revisited.html#who-studies-the-most-outside-class"><span class="toc-section-number">22.4</span> Who studies the most outside class?</a></li>
<li><a href="analysis-of-variance-revisited.html#mental-context"><span class="toc-section-number">22.5</span> Mental context</a></li>
<li><a href="analysis-of-variance-revisited.html#trying-on-shirts"><span class="toc-section-number">22.6</span> Trying on shirts</a></li>
<li><a href="analysis-of-variance-revisited.html#productivity-and-research-and-development"><span class="toc-section-number">22.7</span> Productivity and research-and-development</a></li>
<li><a href="analysis-of-variance-revisited.html#treating-leprosy"><span class="toc-section-number">22.8</span> Treating leprosy</a></li>
</ul></li>
<li class="has-sub"><a href="multivariate-analysis-of-variance.html#multivariate-analysis-of-variance"><span class="toc-section-number">23</span> Multivariate analysis of variance</a><ul>
<li><a href="multivariate-analysis-of-variance.html#fabricated-data"><span class="toc-section-number">23.1</span> Fabricated data</a></li>
<li><a href="multivariate-analysis-of-variance.html#do-characteristics-of-urine-depend-on-obesity"><span class="toc-section-number">23.2</span> Do characteristics of urine depend on obesity?</a></li>
<li><a href="multivariate-analysis-of-variance.html#how-do-height-and-weight-depend-on-sport-played-by-elite-athletes"><span class="toc-section-number">23.3</span> How do height and weight depend on sport played by elite athletes?</a></li>
</ul></li>
<li class="has-sub"><a href="repeated-measures.html#repeated-measures"><span class="toc-section-number">24</span> Repeated measures</a><ul>
<li><a href="repeated-measures.html#effect-of-drug-on-rat-weight"><span class="toc-section-number">24.1</span> Effect of drug on rat weight</a></li>
<li><a href="repeated-measures.html#social-interaction-among-old-people"><span class="toc-section-number">24.2</span> Social interaction among old people</a></li>
<li><a href="repeated-measures.html#childrens-stress-levels-and-airports"><span class="toc-section-number">24.3</span> Children’s stress levels and airports</a></li>
<li><a href="repeated-measures.html#body-fat-as-repeated-measures"><span class="toc-section-number">24.4</span> Body fat as repeated measures</a></li>
<li><a href="repeated-measures.html#investigating-motor-activity-in-rats"><span class="toc-section-number">24.5</span> Investigating motor activity in rats</a></li>
<li><a href="repeated-measures.html#repeated-measures-with-no-background"><span class="toc-section-number">24.6</span> Repeated measures with no background</a></li>
</ul></li>
<li class="has-sub"><a href="discriminant-analysis.html#discriminant-analysis"><span class="toc-section-number">25</span> Discriminant analysis</a><ul>
<li><a href="discriminant-analysis.html#telling-whether-a-banknote-is-real-or-counterfeit"><span class="toc-section-number">25.1</span> Telling whether a banknote is real or counterfeit</a></li>
<li><a href="discriminant-analysis.html#urine-and-obesity-what-makes-a-difference"><span class="toc-section-number">25.2</span> Urine and obesity: what makes a difference?</a></li>
<li><a href="discriminant-analysis.html#understanding-a-manova"><span class="toc-section-number">25.3</span> Understanding a MANOVA</a></li>
<li><a href="discriminant-analysis.html#what-distinguishes-people-who-do-different-jobs"><span class="toc-section-number">25.4</span> What distinguishes people who do different jobs?</a></li>
<li><a href="discriminant-analysis.html#observing-children-with-adhd"><span class="toc-section-number">25.5</span> Observing children with ADHD</a></li>
<li><a href="discriminant-analysis.html#growing-corn"><span class="toc-section-number">25.6</span> Growing corn</a></li>
<li><a href="discriminant-analysis.html#understanding-athletes-height-weight-sport-and-gender"><span class="toc-section-number">25.7</span> Understanding athletes’ height, weight, sport and gender</a></li>
</ul></li>
<li class="has-sub"><a href="cluster-analysis.html#cluster-analysis"><span class="toc-section-number">26</span> Cluster analysis</a><ul>
<li><a href="cluster-analysis.html#sites-on-the-sea-bed"><span class="toc-section-number">26.1</span> Sites on the sea bed</a></li>
<li><a href="cluster-analysis.html#dissimilarities-between-fruits"><span class="toc-section-number">26.2</span> Dissimilarities between fruits</a></li>
<li><a href="cluster-analysis.html#similarity-of-species"><span class="toc-section-number">26.3</span> Similarity of species</a></li>
<li><a href="cluster-analysis.html#rating-beer"><span class="toc-section-number">26.4</span> Rating beer</a></li>
<li><a href="cluster-analysis.html#clustering-the-swiss-bills"><span class="toc-section-number">26.5</span> Clustering the Swiss bills</a></li>
<li><a href="cluster-analysis.html#grouping-similar-cars"><span class="toc-section-number">26.6</span> Grouping similar cars</a></li>
<li><a href="cluster-analysis.html#running-jumping-and-throwing"><span class="toc-section-number">26.7</span> Running, jumping, and throwing</a></li>
<li><a href="cluster-analysis.html#bridges-in-pittsburgh"><span class="toc-section-number">26.8</span> Bridges in Pittsburgh</a></li>
<li><a href="cluster-analysis.html#clustering-the-australian-athletes"><span class="toc-section-number">26.9</span> Clustering the Australian athletes</a></li>
</ul></li>
<li class="has-sub"><a href="multidimensional-scaling.html#multidimensional-scaling"><span class="toc-section-number">27</span> Multidimensional Scaling</a><ul>
<li><a href="multidimensional-scaling.html#making-a-map-of-wisconsin"><span class="toc-section-number">27.1</span> Making a map of Wisconsin</a></li>
<li><a href="multidimensional-scaling.html#things-that-feel-similar-to-each-other"><span class="toc-section-number">27.2</span> Things that feel similar to each other</a></li>
<li><a href="multidimensional-scaling.html#confusing-letters"><span class="toc-section-number">27.3</span> Confusing letters</a></li>
<li><a href="multidimensional-scaling.html#more-beer-please"><span class="toc-section-number">27.4</span> More beer please</a></li>
<li><a href="multidimensional-scaling.html#feeling-similar-again"><span class="toc-section-number">27.5</span> Feeling similar, again</a></li>
</ul></li>
<li class="has-sub"><a href="principal-components-and-factor-analysis.html#principal-components-and-factor-analysis"><span class="toc-section-number">28</span> Principal Components and Factor Analysis</a><ul>
<li><a href="principal-components-and-factor-analysis.html#the-weather-somewhere"><span class="toc-section-number">28.1</span> The weather, somewhere</a></li>
<li><a href="principal-components-and-factor-analysis.html#air-pollution"><span class="toc-section-number">28.2</span> Air pollution</a></li>
<li><a href="principal-components-and-factor-analysis.html#a-correlation-matrix"><span class="toc-section-number">28.3</span> A correlation matrix</a></li>
<li><a href="principal-components-and-factor-analysis.html#the-interpersonal-circumplex"><span class="toc-section-number">28.4</span> The Interpersonal Circumplex</a></li>
</ul></li>
<li class="has-sub"><a href="frequency-table-analysis.html#frequency-table-analysis"><span class="toc-section-number">29</span> Frequency table analysis</a><ul>
<li><a href="frequency-table-analysis.html#college-plans"><span class="toc-section-number">29.1</span> College plans</a></li>
<li><a href="frequency-table-analysis.html#predicting-voting"><span class="toc-section-number">29.2</span> Predicting voting</a></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div class="row">
<div class="col-sm-12">
<div id="cluster-analysis" class="section level1">
<h1><span class="header-section-number">Chapter 26</span> Cluster analysis</h1>
<p>Packages for this chapter:</p>
<div class="sourceCode" id="cb3627"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3627-1" data-line-number="1"><span class="kw">library</span>(MASS)</a>
<a class="sourceLine" id="cb3627-2" data-line-number="2"><span class="kw">library</span>(ggbiplot)</a>
<a class="sourceLine" id="cb3627-3" data-line-number="3"><span class="kw">library</span>(tidyverse)</a></code></pre></div>
<pre><code>## Warning: `env_bind_fns()` is deprecated as of rlang 0.3.0.
## Please use `env_bind_active()` instead.
## This warning is displayed once per session.</code></pre>
<div id="sites-on-the-sea-bed" class="section level2">
<h2><span class="header-section-number">26.1</span> Sites on the sea bed</h2>
<p>Biologists investigate the prevalence of
species of organism by sampling sites where the organisms might be,
taking a “grab” from the site, and sending the grabs to a laboratory
for analysis. The data in this question come from the sea bed. There
were 30 sites, labelled <code>s1</code> through <code>s30</code>. At each
site, five species of organism, labelled <code>a</code> through
<code>e</code>, were of interest; the data shown in those columns of the
data set were the number of organisms of that species identified in
the grab from that site. There are some other columns in the
(original) data set that will not concern us. Our interest is in
seeing which sites are similar to which other sites, so that a cluster
analysis will be suitable.</p>
<p>When the data are counts of different species, as they are here,
biologists often measure the dissimilarity in species prevalence
profiles between two sites using something called the Bray-Curtis
dissimilarity. It is not important to understand this for this
question (though I explain it in my solutions). I calculated the
Bray-Curtis dissimilarity between each pair of sites and stored the
results in <a href="http://www.utsc.utoronto.ca/~butler/d29/seabed1.csv">link</a>.</p>
<ol style="list-style-type: lower-alpha">
<li>Read in the dissimilarity data and check that you have 30
rows and 30 columns of dissimilarities.</li>
</ol>
<p>Solution</p>
<div class="sourceCode" id="cb3629"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3629-1" data-line-number="1">my_url &lt;-<span class="st"> &quot;http://www.utsc.utoronto.ca/~butler/d29/seabed1.csv&quot;</span></a>
<a class="sourceLine" id="cb3629-2" data-line-number="2">seabed &lt;-<span class="st"> </span><span class="kw">read_csv</span>(my_url)</a></code></pre></div>
<pre><code>## Parsed with column specification:
## cols(
##   .default = col_double()
## )</code></pre>
<pre><code>## See spec(...) for full column specifications.</code></pre>
<div class="sourceCode" id="cb3632"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3632-1" data-line-number="1">seabed</a></code></pre></div>
<pre><code>## # A tibble: 30 x 30
##       s1    s2    s3    s4    s5    s6    s7    s8    s9   s10   s11   s12
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 0     0.457 0.296 0.467 0.477 0.522 0.455 0.933 0.333 0.403 0.357 0.375
##  2 0.457 0     0.481 0.556 0.348 0.229 0.415 0.930 0.222 0.447 0.566 0.215
##  3 0.296 0.481 0     0.467 0.508 0.522 0.491 1     0.407 0.343 0.214 0.325
##  4 0.467 0.556 0.467 0     0.786 0.692 0.870 1     0.639 0.379 0.532 0.549
##  5 0.477 0.348 0.508 0.786 0     0.419 0.212 0.854 0.196 0.564 0.373 0.319
##  6 0.522 0.229 0.522 0.692 0.419 0     0.509 0.933 0.243 0.571 0.530 0.237
##  7 0.455 0.415 0.491 0.870 0.212 0.509 0     0.806 0.317 0.588 0.509 0.358
##  8 0.933 0.930 1     1     0.854 0.933 0.806 0     0.895 1     0.938 0.929
##  9 0.333 0.222 0.407 0.639 0.196 0.243 0.317 0.895 0     0.489 0.349 0.159
## 10 0.403 0.447 0.343 0.379 0.564 0.571 0.588 1     0.489 0     0.449 0.419
## # … with 20 more rows, and 18 more variables: s13 &lt;dbl&gt;, s14 &lt;dbl&gt;,
## #   s15 &lt;dbl&gt;, s16 &lt;dbl&gt;, s17 &lt;dbl&gt;, s18 &lt;dbl&gt;, s19 &lt;dbl&gt;, s20 &lt;dbl&gt;,
## #   s21 &lt;dbl&gt;, s22 &lt;dbl&gt;, s23 &lt;dbl&gt;, s24 &lt;dbl&gt;, s25 &lt;dbl&gt;, s26 &lt;dbl&gt;,
## #   s27 &lt;dbl&gt;, s28 &lt;dbl&gt;, s29 &lt;dbl&gt;, s30 &lt;dbl&gt;</code></pre>
<p>Check. The columns are labelled with
the site names. (As I originally set this question, the data file was
read in with <code>read.csv</code> instead, and the site names were read
in as row names as well: see discussion elsewhere about row names. But
in the <code>tidyverse</code> we don’t have row names.)</p>
<ol start="2" style="list-style-type: lower-alpha">
<li>Create a distance object out of your dissimilarities,
bearing in mind that the values are distances (well,
dissimilarities) already.</li>
</ol>
<p>Solution</p>
<p>This one needs <code>as.dist</code> to convert already-distances into
a <code>dist</code> object. (<code>dist</code> would have
<em>calculated</em> distances from things that were not
distances/dissimilarities yet.)</p>
<div class="sourceCode" id="cb3634"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3634-1" data-line-number="1">d &lt;-<span class="st"> </span><span class="kw">as.dist</span>(seabed)</a></code></pre></div>
<p>If you check, you’ll see that the site names are being used to label
rows <em>and</em> columns of the dissimilarity matrix as displayed. The
lack of row names is not hurting us.</p>
<ol start="3" style="list-style-type: lower-alpha">
<li>Fit a cluster analysis using single-linkage, and display a
dendrogram of the results.</li>
</ol>
<p>Solution</p>
<p>This:</p>
<div class="sourceCode" id="cb3635"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3635-1" data-line-number="1">d<span class="fl">.1</span> &lt;-<span class="st"> </span><span class="kw">hclust</span>(d, <span class="dt">method =</span> <span class="st">&quot;single&quot;</span>)</a>
<a class="sourceLine" id="cb3635-2" data-line-number="2"><span class="kw">plot</span>(d<span class="fl">.1</span>)</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/unnamed-chunk-6-1.png" width="672"  /></p>
<p>This is a base-graphics plot, it not having any of the nice
<code>ggplot</code> things. But it does the job.</p>
<p>Single-linkage tends to produce “stringy” clusters, since the
individual being added to a cluster only needs to be close to one
thing in the cluster. Here, that manifests itself in sites getting
added to clusters one at a time: for example, sites 25 and 26 get
joined together into a cluster, and then in sequence sites 6, 16, 27,
30 and 22 get joined on to it (rather than any of those sites being
formed into clusters first).</p>
<p>You might
<label for="tufte-mn-231" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-231" class="margin-toggle"><span class="marginnote">Conceivably.</span> be wondering what else is in that
<code>hclust</code> object, and what it’s good for. Let’s take a look:</p>
<div class="sourceCode" id="cb3636"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3636-1" data-line-number="1"><span class="kw">glimpse</span>(d<span class="fl">.1</span>)</a></code></pre></div>
<pre><code>## List of 7
##  $ merge      : int [1:29, 1:2] -3 -25 -6 -9 -28 -16 -27 -1 -30 -24 ...
##  $ height     : num [1:29] 0.1 0.137 0.152 0.159 0.159 ...
##  $ order      : int [1:30] 21 14 29 23 15 1 19 18 2 7 ...
##  $ labels     : chr [1:30] &quot;s1&quot; &quot;s2&quot; &quot;s3&quot; &quot;s4&quot; ...
##  $ method     : chr &quot;single&quot;
##  $ call       : language hclust(d = d, method = &quot;single&quot;)
##  $ dist.method: NULL
##  - attr(*, &quot;class&quot;)= chr &quot;hclust&quot;</code></pre>
<p>You might guess that <code>labels</code> contains the names of the sites,
and you’d be correct. Of the other things, the most interesting are
<code>merge</code> and <code>height</code>. Let’s display them side by side:</p>
<div class="sourceCode" id="cb3638"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3638-1" data-line-number="1"><span class="kw">with</span>(d<span class="fl">.1</span>, <span class="kw">cbind</span>(height, merge))</a></code></pre></div>
<pre><code>##          height        
##  [1,] 0.1000000  -3 -20
##  [2,] 0.1369863 -25 -26
##  [3,] 0.1523179  -6   2
##  [4,] 0.1588785  -9 -12
##  [5,] 0.1588785 -28   4
##  [6,] 0.1617647 -16   3
##  [7,] 0.1633987 -27   6
##  [8,] 0.1692308  -1 -19
##  [9,] 0.1807229 -30   7
## [10,] 0.1818182 -24   5
## [11,] 0.1956522  -5  10
## [12,] 0.2075472 -15   8
## [13,] 0.2083333 -14 -29
## [14,] 0.2121212  -7  11
## [15,] 0.2142857 -11   1
## [16,] 0.2149533  -2  14
## [17,] 0.2191781 -18  16
## [18,] 0.2205882 -22   9
## [19,] 0.2285714  17  18
## [20,] 0.2307692  12  19
## [21,] 0.2328767 -10  15
## [22,] 0.2558140  20  21
## [23,] 0.2658228 -23  22
## [24,] 0.2666667  13  23
## [25,] 0.3023256  -4 -13
## [26,] 0.3333333  24  25
## [27,] 0.3571429 -21  26
## [28,] 0.4285714  -8 -17
## [29,] 0.6363636  27  28</code></pre>
<p><code>height</code> is the vertical scale of the dendrogram. The first
height is 0.1, and if you look at the bottom of the dendrogram, the
first sites to be joined together are sites 3 and 20 at height 0.1
(the horizontal bar joining sites 3 and 20 is what you are looking
for). In the last two columns, which came from <code>merge</code>, you see
what got joined together, with negative numbers meaning individuals
(individual sites), and positive numbers meaning clusters formed
earlier. So, if you look at the third line, at height 0.152, site 6
gets joined to the cluster formed on line 2, which (looking back) we
see consists of sites 25 and 26. Go back now to the dendrogram; about
<span class="math inline">\({3\over 4}\)</span> of the way across, you’ll see sites 25 and 26 joined
together into a cluster, and a little higher up the page, site 6 joins
that cluster.</p>
<p>I said that single linkage produces stringy clusters, and the way that
shows up in <code>merge</code> is that you often get an individual site
(negative number) joined onto a previously-formed cluster (positive
number). This is in contrast to Ward’s method, below.</p>
<ol start="4" style="list-style-type: lower-alpha">
<li>Now fit a cluster analysis using Ward’s method, and display
a dendrogram of the results.</li>
</ol>
<p>Solution</p>
<p>Same thing, with small changes. The hard part is getting the name
of the <code>method</code> right:</p>
<div class="sourceCode" id="cb3640"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3640-1" data-line-number="1">d<span class="fl">.2</span> &lt;-<span class="st"> </span><span class="kw">hclust</span>(d, <span class="dt">method =</span> <span class="st">&quot;ward.D&quot;</span>)</a>
<a class="sourceLine" id="cb3640-2" data-line-number="2"><span class="kw">plot</span>(d<span class="fl">.2</span>, <span class="dt">cex =</span> <span class="fl">0.7</span>)</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/unnamed-chunk-9-1.png" width="672"  /></p>
<p>The site numbers were a bit close together, so I printed them out
smaller than usual size (which is what the <code>cex</code> and a number
less than 1 is doing: 70% of normal size).
<label for="tufte-mn-232" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-232" class="margin-toggle"><span class="marginnote">This is base-graphics code, which I learned a long time ago. There are a lot of options with weird names that are hard to remember, and that are sometimes inconsistent with each other. There is a package <em>ggdendro</em> that makes nice <em>ggplot</em> dendrograms, and another called <em>dendextend</em> that does all kinds of stuff with dendrograms. I decided that it wasn’t worth the trouble of teaching you (and therefore me) <em>ggdendro</em>, since the dendrograms look much the same.</span>
This time, there is a greater tendency for sites to be joined into
small clusters first, then these small clusters are joined
together. It’s not perfect, but there is a greater tendency for it to
happen here.</p>
<p>This shows up in <code>merge</code> too:</p>
<div class="sourceCode" id="cb3641"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3641-1" data-line-number="1">d<span class="fl">.2</span><span class="op">$</span>merge</a></code></pre></div>
<pre><code>##       [,1] [,2]
##  [1,]   -3  -20
##  [2,]  -25  -26
##  [3,]   -9  -12
##  [4,]  -28    3
##  [5,]   -1  -19
##  [6,]   -6    2
##  [7,]  -14  -29
##  [8,]   -5   -7
##  [9,]  -18  -24
## [10,]  -27    6
## [11,]  -16  -22
## [12,]   -2    4
## [13,]  -30   10
## [14,]  -15    5
## [15,]  -23    8
## [16,]   -4  -13
## [17,]  -11    1
## [18,]    9   12
## [19,]  -10   17
## [20,]   -8  -17
## [21,]   11   13
## [22,]  -21   15
## [23,]    7   22
## [24,]   14   19
## [25,]   16   24
## [26,]   18   21
## [27,]   20   23
## [28,]   26   27
## [29,]   25   28</code></pre>
<p>There are relatively few instances of a site being joined to a cluster
of sites. Usually, individual sites get joined together (negative with
a negative, mainly at the top of the list), or clusters get joined to
clusters (positive with positive, mainly lower down the list).</p>
<ol start="5" style="list-style-type: lower-alpha">
<li><a name="part:prefclust">*</a> On the Ward’s method clustering, how many clusters would you
choose to divide the sites into? Draw rectangles around those clusters.</li>
</ol>
<p>Solution</p>
<p>You may need to draw the plot again. In any case, a second line of
code draws the rectangles. I think three clusters is good, but you
can have a few more than that if you like:</p>
<div class="sourceCode" id="cb3643"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3643-1" data-line-number="1"><span class="kw">plot</span>(d<span class="fl">.2</span>, <span class="dt">cex =</span> <span class="fl">0.7</span>)</a>
<a class="sourceLine" id="cb3643-2" data-line-number="2"><span class="kw">rect.hclust</span>(d<span class="fl">.2</span>, <span class="dv">3</span>)</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/unnamed-chunk-11-1.png" width="672"  /></p>
<p>What I want to see is a not-unreasonable choice of number of clusters
(I think you could go up to about six), and then a depiction of that
number of clusters on the plot. This is six clusters:</p>
<div class="sourceCode" id="cb3644"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3644-1" data-line-number="1"><span class="kw">plot</span>(d<span class="fl">.2</span>, <span class="dt">cex =</span> <span class="fl">0.7</span>)</a>
<a class="sourceLine" id="cb3644-2" data-line-number="2"><span class="kw">rect.hclust</span>(d<span class="fl">.2</span>, <span class="dv">6</span>)</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/unnamed-chunk-12-1.png" width="672"  /></p>
<p>In all your plots, the <code>cex</code> is optional, but you can compare
the plots with it and without it and see which you prefer.</p>
<p>Looking at this, even seven clusters might work, but I doubt you’d
want to go beyond that. The choice of the number of clusters is mainly
an aesthetic
<label for="tufte-mn-233" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-233" class="margin-toggle"><span class="marginnote">This, I think, is the British spelling, with the North American one being <em>esthetic</em>. My spelling is where the <em>aes</em> in a <em>ggplot</em> comes from.</span> decision.</p>
<ol start="6" style="list-style-type: lower-alpha">
<li><a name="part:original">*</a> The original data is in
<a href="http://www.utsc.utoronto.ca/~butler/d29/seabed.csv">link</a>. Read in the
original data and verify that you again have 30 sites, variables
called <code>a</code> through <code>e</code> and some others.</li>
</ol>
<p>Solution</p>
<p>This is really a very cheap two points:</p>
<div class="sourceCode" id="cb3645"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3645-1" data-line-number="1">my_url &lt;-<span class="st"> &quot;http://www.utsc.utoronto.ca/~butler/d29/seabed.csv&quot;</span></a>
<a class="sourceLine" id="cb3645-2" data-line-number="2">seabed.z &lt;-<span class="st"> </span><span class="kw">read_csv</span>(my_url)</a></code></pre></div>
<pre><code>## Parsed with column specification:
## cols(
##   site = col_character(),
##   a = col_double(),
##   b = col_double(),
##   c = col_double(),
##   d = col_double(),
##   e = col_double(),
##   depth = col_double(),
##   pollution = col_double(),
##   temp = col_double(),
##   sediment = col_character()
## )</code></pre>
<div class="sourceCode" id="cb3647"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3647-1" data-line-number="1">seabed.z</a></code></pre></div>
<pre><code>## # A tibble: 30 x 10
##    site      a     b     c     d     e depth pollution  temp sediment
##    &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;   
##  1 s1        0     2     9    14     2    72       4.8   3.5 s       
##  2 s2       26     4    13    11     0    75       2.8   2.5 c       
##  3 s3        0    10     9     8     0    59       5.4   2.7 c       
##  4 s4        0     0    15     3     0    64       8.2   2.9 s       
##  5 s5       13     5     3    10     7    61       3.9   3.1 c       
##  6 s6       31    21    13    16     5    94       2.6   3.5 g       
##  7 s7        9     6     0    11     2    53       4.6   2.9 s       
##  8 s8        2     0     0     0     1    61       5.1   3.3 c       
##  9 s9       17     7    10    14     6    68       3.9   3.4 c       
## 10 s10       0     5    26     9     0    69      10     3   s       
## # … with 20 more rows</code></pre>
<p>30 observations of 10 variables, including <code>a</code> through
<code>e</code>. Check.</p>
<p>I gave this a weird name so that it didn’t overwrite my original
<code>seabed</code>, the one I turned into a distance object, though I
don’t think I really needed to worry.</p>
<p>These data came from
<a href="http://www.fbbva.es/TLFU/dat/DE_2013_multivariate.pdf">link</a>,
<label for="tufte-mn-234" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-234" class="margin-toggle"><span class="marginnote">If you are a soccer fan, you might recognize BBVA as a former sponsor of the top Spanish soccer league, <em>La Liga BBVA</em> (as it was). BBVA is a Spanish bank that also has a Foundation that published this book.</span> from which I also got the definition of the Bray-Curtis
dissimilarity that I calculated for you. The data are in Exhibit 1.1
of that book.</p>
<ol start="7" style="list-style-type: lower-alpha">
<li>Go back to your Ward method dendrogram with the red
rectangles and find two sites in the same cluster. Display the
original data for your two sites and see if you can explain why they
are in the same cluster. It doesn’t matter which two sites you choose;
the grader will merely check that your results look reasonable.</li>
</ol>
<p>Solution</p>
<p>I want my two sites to be very similar, so I’m looking at two sites
that were joined into a cluster very early on, sites <code>s3</code> and
<code>s20</code>. As I said, I don’t mind which ones you pick, but being
in the same cluster will be easiest to justify if you pick sites
that were joined together early.
Then you need to display just those rows of the original data (that
you just read in), which is a <code>filter</code> with an “or” in it:</p>
<div class="sourceCode" id="cb3649"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3649-1" data-line-number="1">seabed.z <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(site <span class="op">==</span><span class="st"> &quot;s3&quot;</span> <span class="op">|</span><span class="st"> </span>site <span class="op">==</span><span class="st"> &quot;s20&quot;</span>)</a></code></pre></div>
<pre><code>## # A tibble: 2 x 10
##   site      a     b     c     d     e depth pollution  temp sediment
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;   
## 1 s3        0    10     9     8     0    59       5.4   2.7 c       
## 2 s20       0    10    14     9     0    73       5.6   3   s</code></pre>
<p>I think this odd-looking thing also works:</p>
<div class="sourceCode" id="cb3651"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3651-1" data-line-number="1">seabed.z <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(site <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;s3&quot;</span>, <span class="st">&quot;s20&quot;</span>))</a></code></pre></div>
<pre><code>## # A tibble: 2 x 10
##   site      a     b     c     d     e depth pollution  temp sediment
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;   
## 1 s3        0    10     9     8     0    59       5.4   2.7 c       
## 2 s20       0    10    14     9     0    73       5.6   3   s</code></pre>
<p>I’ll also take displaying the lines one at a time, though it is easier
to compare them if they are next to each other.</p>
<p>Why are they in the same cluster? To be similar (that is, have a low
dissimilarity), the values of <code>a</code> through <code>e</code> should be
close together. Here, they certainly are: <code>a</code> and <code>e</code>
are both zero for both sites, and <code>b</code>, <code>c</code> and
<code>d</code> are around 10 for both sites. So I’d call that similar.</p>
<p>You will probably pick a different pair of sites, and thus your
detailed discussion will differ from mine, but the general point of it
should be the same: pick a pair of sites in the same cluster (1 mark),
display those two rows of the original data (1 mark), some sensible
discussion of how the sites are similar (1 mark). As long as you pick
two sites in the same one of your clusters, I don’t mind which ones
you pick. The grader will check that your two sites were indeed in the
same one of your clusters, then will check that you do indeed display
those two sites from the original data.</p>
<p>What happens if you pick sites from different clusters? Let’s pick two
very dissimilar ones, sites 4 and 7 from opposite ends of my dendrogram:</p>
<div class="sourceCode" id="cb3653"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3653-1" data-line-number="1">seabed.z <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(site <span class="op">==</span><span class="st"> &quot;s4&quot;</span> <span class="op">|</span><span class="st"> </span>site <span class="op">==</span><span class="st"> &quot;s7&quot;</span>)</a></code></pre></div>
<pre><code>## # A tibble: 2 x 10
##   site      a     b     c     d     e depth pollution  temp sediment
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;   
## 1 s4        0     0    15     3     0    64       8.2   2.9 s       
## 2 s7        9     6     0    11     2    53       4.6   2.9 s</code></pre>
<p>Site <code>s4</code> has no <code>a</code> or <code>b</code> at all, and site
<code>s7</code> has quite a few; site <code>s7</code> has no <code>c</code> at
all, while site <code>s4</code> has a lot. These are very different sites.</p>
<p>Extra: now that you’ve seen what the original data look like, I should
explain how I got the Bray-Curtis dissimilarities. As I said, only the
counts of species <code>a</code> through <code>e</code> enter into the
calculation; the other variables have nothing to do with it.</p>
<p>Let’s simplify matters by pretending that we have only two species (we
can call them A and B), and a vector like this:</p>
<div class="sourceCode" id="cb3655"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3655-1" data-line-number="1">v1 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">10</span>, <span class="dv">3</span>)</a></code></pre></div>
<p>which says that we have 10 organisms of species A and 3 of species B
at a site. This is rather similar to this site:</p>
<div class="sourceCode" id="cb3656"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3656-1" data-line-number="1">v2 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">8</span>, <span class="dv">4</span>)</a></code></pre></div>
<p>but very different from this site:</p>
<div class="sourceCode" id="cb3657"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3657-1" data-line-number="1">v3 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">7</span>)</a></code></pre></div>
<p>The way you calculate the Bray-Curtis dissimilarity is to take the
absolute difference of counts of organisms of each species:</p>
<div class="sourceCode" id="cb3658"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3658-1" data-line-number="1"><span class="kw">abs</span>(v1 <span class="op">-</span><span class="st"> </span>v2)</a></code></pre></div>
<pre><code>## [1] 2 1</code></pre>
<p>and add those up:</p>
<div class="sourceCode" id="cb3660"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3660-1" data-line-number="1"><span class="kw">sum</span>(<span class="kw">abs</span>(v1 <span class="op">-</span><span class="st"> </span>v2))</a></code></pre></div>
<pre><code>## [1] 3</code></pre>
<p>and then divide by the total of all the frequencies:</p>
<div class="sourceCode" id="cb3662"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3662-1" data-line-number="1"><span class="kw">sum</span>(<span class="kw">abs</span>(v1 <span class="op">-</span><span class="st"> </span>v2)) <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(v1 <span class="op">+</span><span class="st"> </span>v2)</a></code></pre></div>
<pre><code>## [1] 0.12</code></pre>
<p>The smaller this number is, the more similar the sites are. So you
might imagine that <code>v1</code> and <code>v3</code> would be more dissimilar:</p>
<div class="sourceCode" id="cb3664"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3664-1" data-line-number="1"><span class="kw">sum</span>(<span class="kw">abs</span>(v1 <span class="op">-</span><span class="st"> </span>v3)) <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(v1 <span class="op">+</span><span class="st"> </span>v3)</a></code></pre></div>
<pre><code>## [1] 0.7</code></pre>
<p>and so it is. The scaling of the Bray-Curtis dissimilarity is that the
smallest it can be is 0, if the frequencies of each of the species are
exactly the same at the two sites, and the largest it can be is 1, if
one site has only species A and the other has only species B. (I’ll
demonstrate that in a moment.)
You might imagine that we’ll be doing this calculation a lot, and so
we should define a function to automate it. Hadley Wickham
(in “R for Data Science”) says that you should copy and paste some code (as
I did above) no more than twice; if you need to do it again, you
should write a function instead. The thinking behind this is if you
copy and paste and change something (like a variable name), you’ll
need to make the change <em>everywhere</em>, and it’s so easy to miss
one.
So, my function is (copying and pasting my code from above into the
body of the function, which is Wickham-approved since it’s only my
second time):</p>
<div class="sourceCode" id="cb3666"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3666-1" data-line-number="1">braycurtis &lt;-<span class="st"> </span><span class="cf">function</span>(v1, v2) {</a>
<a class="sourceLine" id="cb3666-2" data-line-number="2">  <span class="kw">sum</span>(<span class="kw">abs</span>(v1 <span class="op">-</span><span class="st"> </span>v2)) <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(v1 <span class="op">+</span><span class="st"> </span>v2)</a>
<a class="sourceLine" id="cb3666-3" data-line-number="3">}</a></code></pre></div>
<p>Let’s test it on my made-up sites, making up one more:</p>
<div class="sourceCode" id="cb3667"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3667-1" data-line-number="1"><span class="kw">braycurtis</span>(v1, v2)</a></code></pre></div>
<pre><code>## [1] 0.12</code></pre>
<div class="sourceCode" id="cb3669"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3669-1" data-line-number="1"><span class="kw">braycurtis</span>(v1, v3)</a></code></pre></div>
<pre><code>## [1] 0.7</code></pre>
<div class="sourceCode" id="cb3671"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3671-1" data-line-number="1"><span class="kw">braycurtis</span>(v2, v2)</a></code></pre></div>
<pre><code>## [1] 0</code></pre>
<div class="sourceCode" id="cb3673"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3673-1" data-line-number="1">v4 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb3673-2" data-line-number="2"><span class="kw">braycurtis</span>(v3, v4)</a></code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>These all check out. The first two are repeats of the ones we did
before. The third one says that if you calculate Bray-Curtis for two
sites with the exact same frequencies all the way along, you get the
minimum value of 0; the fourth one says that when site <code>v3</code>
only has species B and site <code>v4</code> only has species A, you get
the maximum value of 1.</p>
<p>But note this:</p>
<div class="sourceCode" id="cb3675"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3675-1" data-line-number="1">v2</a></code></pre></div>
<pre><code>## [1] 8 4</code></pre>
<div class="sourceCode" id="cb3677"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3677-1" data-line-number="1"><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>v2</a></code></pre></div>
<pre><code>## [1] 16  8</code></pre>
<div class="sourceCode" id="cb3679"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3679-1" data-line-number="1"><span class="kw">braycurtis</span>(v2, <span class="dv">2</span> <span class="op">*</span><span class="st"> </span>v2)</a></code></pre></div>
<pre><code>## [1] 0.3333333</code></pre>
<p>You might say that <code>v2</code> and <code>2*v2</code> are the same
distribution, and so they are, proportionately. But Bray-Curtis is
assessing whether the frequencies are <em>the same</em> (as opposed to
something like a chi-squared test that is assessing
proportionality).
<label for="tufte-mn-235" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-235" class="margin-toggle"><span class="marginnote">You could make a table out of the sites and species, and use the test statistic from a chi-squared test as a measure of dissimilarity: the smallest it can be is zero, if the species counts are exactly proportional at the two sites. It doesn’t have an upper limit.</span></p>
<p>So far so good. Now we have to do this for the actual data. The first
issue
<label for="tufte-mn-236" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-236" class="margin-toggle"><span class="marginnote">There are more issues.</span> is that the data is some of the
row of the original data frame; specifically, it’s columns 2 through
6. For example, sites <code>s3</code> and <code>s20</code> of the original
data frame look like this:</p>
<div class="sourceCode" id="cb3681"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3681-1" data-line-number="1">seabed.z <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(site <span class="op">==</span><span class="st"> &quot;s3&quot;</span> <span class="op">|</span><span class="st"> </span>site <span class="op">==</span><span class="st"> &quot;s20&quot;</span>)</a></code></pre></div>
<pre><code>## # A tibble: 2 x 10
##   site      a     b     c     d     e depth pollution  temp sediment
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;   
## 1 s3        0    10     9     8     0    59       5.4   2.7 c       
## 2 s20       0    10    14     9     0    73       5.6   3   s</code></pre>
<p>and we don’t want to feed the whole of those into <code>braycurtis</code>,
just the second through sixth elements of them. So let’s write another
function that extracts the columns <code>a</code> through <code>e</code> of its
inputs for given rows, and passes those on to the <code>braycurtis</code>
that we wrote before. This is a little fiddly, but bear with me. The
input to the function is the data frame, then the two sites that we want:
First, though, what happens if <code>filter</code> site <code>s3</code>?</p>
<div class="sourceCode" id="cb3683"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3683-1" data-line-number="1">seabed.z <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(site <span class="op">==</span><span class="st"> &quot;s3&quot;</span>)</a></code></pre></div>
<pre><code>## # A tibble: 1 x 10
##   site      a     b     c     d     e depth pollution  temp sediment
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;   
## 1 s3        0    10     9     8     0    59       5.4   2.7 c</code></pre>
<p>This is a one-row data frame, not a vector as our function expects.
Do we need to worry about it? First, grab the right columns, so that we will know what our function has to do:</p>
<div class="sourceCode" id="cb3685"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3685-1" data-line-number="1">seabed.z <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3685-2" data-line-number="2"><span class="st">  </span><span class="kw">filter</span>(site <span class="op">==</span><span class="st"> &quot;s3&quot;</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3685-3" data-line-number="3"><span class="st">  </span><span class="kw">select</span>(a<span class="op">:</span>e)</a></code></pre></div>
<pre><code>## # A tibble: 1 x 5
##       a     b     c     d     e
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     0    10     9     8     0</code></pre>
<p>That leads us to this function, which is a bit repetitious, but for
two repeats I can handle it. I haven’t done anything about the fact
that <code>x</code> and <code>y</code> below are actually data frames:</p>
<div class="sourceCode" id="cb3687"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3687-1" data-line-number="1">braycurtis.spec &lt;-<span class="st"> </span><span class="cf">function</span>(d, i, j) {</a>
<a class="sourceLine" id="cb3687-2" data-line-number="2">  d <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(site <span class="op">==</span><span class="st"> </span>i) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(a<span class="op">:</span>e) -&gt;<span class="st"> </span>x</a>
<a class="sourceLine" id="cb3687-3" data-line-number="3">  d <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(site <span class="op">==</span><span class="st"> </span>j) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(a<span class="op">:</span>e) -&gt;<span class="st"> </span>y</a>
<a class="sourceLine" id="cb3687-4" data-line-number="4">  <span class="kw">braycurtis</span>(x, y)</a>
<a class="sourceLine" id="cb3687-5" data-line-number="5">}</a></code></pre></div>
<p>The first time I did this, I had the <code>filter</code> and the
<code>select</code> in the opposite order, so I was neatly <em>removing</em>
the column I wanted to <code>filter</code> by <em>before</em> I did the
<code>filter</code>!</p>
<p>The first two lines pull out columns <code>a</code> through <code>e</code> of
(respectively) sites <code>i</code> and <code>j</code>.</p>
<p>If I were going to create more than two things like <code>x</code> and
<code>y</code>, I would have hived that off
into a separate function as well, but I didn’t.</p>
<p>Sites 3 and 20 were the two sites I chose before as being similar ones (in the
same cluster). So the dissimilarity should be small:</p>
<div class="sourceCode" id="cb3688"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3688-1" data-line-number="1"><span class="kw">braycurtis.spec</span>(seabed.z, <span class="st">&quot;s3&quot;</span>, <span class="st">&quot;s20&quot;</span>)</a></code></pre></div>
<pre><code>## [1] 0.1</code></pre>
<p>and so it is. Is it about right? The <code>c</code> differ by 5, the
<code>d</code> differ by one, and the total frequency in both rows is
about 60, so the dissimilarity should be about <span class="math inline">\(6/60=0.1\)</span>, as it is
(exactly, in fact).</p>
<p>This, you will note, works. I think R has taken the attitude that it
can treat these one-row data frames as if they were vectors.
This is the cleaned-up version of my function. When I first wrote it,
I <code>print</code>ed out <code>x</code> and <code>y</code>, so that I could
check that they were what I was expecting (they were).
<label for="tufte-mn-237" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-237" class="margin-toggle"><span class="marginnote">I am a paid-up member of the <em>print all the things</em> school of debugging. You probably know how to do this better.</span>
We have almost all the machinery we need. Now what we have to do is to
compare every site with every other site and compute the dissimilarity
between them. If you’re used to Python or another similar language,
you’ll recognize this as two loops, one inside the other. This can be done in R (and I’ll show you how), but I’d rather show you the Tidyverse way first.</p>
<p>The starting point is to make a vector containing all the sites, which
is easier than you would guess:</p>
<div class="sourceCode" id="cb3690"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3690-1" data-line-number="1">sites &lt;-<span class="st"> </span><span class="kw">str_c</span>(<span class="st">&quot;s&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">30</span>)</a>
<a class="sourceLine" id="cb3690-2" data-line-number="2">sites</a></code></pre></div>
<pre><code>##  [1] &quot;s1&quot;  &quot;s2&quot;  &quot;s3&quot;  &quot;s4&quot;  &quot;s5&quot;  &quot;s6&quot;  &quot;s7&quot;  &quot;s8&quot;  &quot;s9&quot;  &quot;s10&quot; &quot;s11&quot;
## [12] &quot;s12&quot; &quot;s13&quot; &quot;s14&quot; &quot;s15&quot; &quot;s16&quot; &quot;s17&quot; &quot;s18&quot; &quot;s19&quot; &quot;s20&quot; &quot;s21&quot; &quot;s22&quot;
## [23] &quot;s23&quot; &quot;s24&quot; &quot;s25&quot; &quot;s26&quot; &quot;s27&quot; &quot;s28&quot; &quot;s29&quot; &quot;s30&quot;</code></pre>
<p>Next, we need to make all possible <em>pairs</em> of sites, which we
also know how to do:</p>
<div class="sourceCode" id="cb3692"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3692-1" data-line-number="1">site_pairs &lt;-<span class="st"> </span><span class="kw">crossing</span>(<span class="dt">site1 =</span> sites, <span class="dt">site2 =</span> sites)</a>
<a class="sourceLine" id="cb3692-2" data-line-number="2">site_pairs</a></code></pre></div>
<pre><code>## # A tibble: 900 x 2
##    site1 site2
##    &lt;chr&gt; &lt;chr&gt;
##  1 s1    s1   
##  2 s1    s10  
##  3 s1    s11  
##  4 s1    s12  
##  5 s1    s13  
##  6 s1    s14  
##  7 s1    s15  
##  8 s1    s16  
##  9 s1    s17  
## 10 s1    s18  
## # … with 890 more rows</code></pre>
<p>Now, think about what to do in English first: “for each of the sites in <code>site1</code>, and for each of the sites in <code>site2</code>, taken in parallel, work out the Bray-Curtis distance.” This is, I hope,
making you think of <code>map</code>. Two details: the Bray-Curtis
distance is a (decimal) number, and we’re for-eaching over two things in
parallel, so <code>map2_dbl</code>:</p>
<div class="sourceCode" id="cb3694"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3694-1" data-line-number="1">site_pairs <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3694-2" data-line-number="2"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">bray_curtis =</span> <span class="kw">map2_dbl</span>(</a>
<a class="sourceLine" id="cb3694-3" data-line-number="3">    site1, site2,</a>
<a class="sourceLine" id="cb3694-4" data-line-number="4">    <span class="op">~</span><span class="st"> </span><span class="kw">braycurtis.spec</span>(seabed.z, .x, .y)</a>
<a class="sourceLine" id="cb3694-5" data-line-number="5">  )) -&gt;<span class="st"> </span>bc</a>
<a class="sourceLine" id="cb3694-6" data-line-number="6">bc</a></code></pre></div>
<pre><code>## # A tibble: 900 x 3
##    site1 site2 bray_curtis
##    &lt;chr&gt; &lt;chr&gt;       &lt;dbl&gt;
##  1 s1    s1          0    
##  2 s1    s10         0.403
##  3 s1    s11         0.357
##  4 s1    s12         0.375
##  5 s1    s13         0.577
##  6 s1    s14         0.633
##  7 s1    s15         0.208
##  8 s1    s16         0.857
##  9 s1    s17         1    
## 10 s1    s18         0.569
## # … with 890 more rows</code></pre>
<p>Remember that we have two “it”s to iterate over, so they get called
<code>.x</code> and <code>.y</code> rather than just <code>.</code>, so you can
tell them apart.</p>
<p>This is a “long” data frame, but for the cluster analysis, we need a wide one with sites in rows and columns, so let’s create that:</p>
<div class="sourceCode" id="cb3696"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3696-1" data-line-number="1">(bc <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pivot_wider</span>(<span class="dt">names_from=</span>site2, <span class="dt">values_from=</span>bray_curtis) -&gt;<span class="st"> </span>bc2)</a></code></pre></div>
<pre><code>## # A tibble: 30 x 31
##    site1    s1   s10   s11   s12   s13   s14   s15   s16   s17   s18   s19
##    &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 s1    0     0.403 0.357 0.375 0.577 0.633 0.208 0.857 1     0.569 0.169
##  2 s10   0.403 0     0.449 0.419 0.415 0.710 0.424 0.856 1     0.380 0.333
##  3 s11   0.357 0.449 0     0.463 0.481 0.765 0.491 0.66  1     0.627 0.343
##  4 s12   0.375 0.419 0.463 0     0.667 0.413 0.342 0.548 0.860 0.254 0.253
##  5 s13   0.577 0.415 0.481 0.667 0     1     0.608 0.875 1     0.667 0.524
##  6 s14   0.633 0.710 0.765 0.413 1     0     0.458 0.656 0.692 0.604 0.633
##  7 s15   0.208 0.424 0.491 0.342 0.608 0.458 0     0.856 0.733 0.548 0.25 
##  8 s16   0.857 0.856 0.66  0.548 0.875 0.656 0.856 0     0.893 0.512 0.761
##  9 s17   1     1     1     0.860 1     0.692 0.733 0.893 0     0.914 0.905
## 10 s18   0.569 0.380 0.627 0.254 0.667 0.604 0.548 0.512 0.914 0     0.449
## # … with 20 more rows, and 19 more variables: s2 &lt;dbl&gt;, s20 &lt;dbl&gt;,
## #   s21 &lt;dbl&gt;, s22 &lt;dbl&gt;, s23 &lt;dbl&gt;, s24 &lt;dbl&gt;, s25 &lt;dbl&gt;, s26 &lt;dbl&gt;,
## #   s27 &lt;dbl&gt;, s28 &lt;dbl&gt;, s29 &lt;dbl&gt;, s3 &lt;dbl&gt;, s30 &lt;dbl&gt;, s4 &lt;dbl&gt;,
## #   s5 &lt;dbl&gt;, s6 &lt;dbl&gt;, s7 &lt;dbl&gt;, s8 &lt;dbl&gt;, s9 &lt;dbl&gt;</code></pre>
<p>That’s the data frame I shared with you.</p>
<p>The more Python-like way of doing it is a loop inside a loop. This
works in R, but it has more housekeeping and a few possibly unfamiliar
ideas. We are going to work with a <code>matrix</code>, and we access
elements of a matrix with two numbers inside square brackets, a row
number and a column number. We also have to initialize our matrix that
we’re going to fill with Bray-Curtis distances; I’ll fill it with <span class="math inline">\(-1\)</span>
values, so that if any are left at the end, I’ll know I missed
something.</p>
<div class="sourceCode" id="cb3698"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3698-1" data-line-number="1">m &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">30</span>, <span class="dv">30</span>)</a>
<a class="sourceLine" id="cb3698-2" data-line-number="2"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">30</span>) {</a>
<a class="sourceLine" id="cb3698-3" data-line-number="3">  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">30</span>) {</a>
<a class="sourceLine" id="cb3698-4" data-line-number="4">    m[i, j] &lt;-<span class="st"> </span><span class="kw">braycurtis.spec</span>(seabed.z, sites[i], sites[j])</a>
<a class="sourceLine" id="cb3698-5" data-line-number="5">  }</a>
<a class="sourceLine" id="cb3698-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb3698-7" data-line-number="7"><span class="kw">rownames</span>(m) &lt;-<span class="st"> </span>sites</a>
<a class="sourceLine" id="cb3698-8" data-line-number="8"><span class="kw">colnames</span>(m) &lt;-<span class="st"> </span>sites</a>
<a class="sourceLine" id="cb3698-9" data-line-number="9"><span class="kw">head</span>(m)</a></code></pre></div>
<pre><code>##           s1        s2        s3        s4        s5        s6        s7
## s1 0.0000000 0.4567901 0.2962963 0.4666667 0.4769231 0.5221239 0.4545455
## s2 0.4567901 0.0000000 0.4814815 0.5555556 0.3478261 0.2285714 0.4146341
## s3 0.2962963 0.4814815 0.0000000 0.4666667 0.5076923 0.5221239 0.4909091
## s4 0.4666667 0.5555556 0.4666667 0.0000000 0.7857143 0.6923077 0.8695652
## s5 0.4769231 0.3478261 0.5076923 0.7857143 0.0000000 0.4193548 0.2121212
## s6 0.5221239 0.2285714 0.5221239 0.6923077 0.4193548 0.0000000 0.5087719
##           s8        s9       s10       s11       s12       s13       s14
## s1 0.9333333 0.3333333 0.4029851 0.3571429 0.3750000 0.5769231 0.6326531
## s2 0.9298246 0.2222222 0.4468085 0.5662651 0.2149533 0.6708861 0.4210526
## s3 1.0000000 0.4074074 0.3432836 0.2142857 0.3250000 0.6538462 0.6734694
## s4 1.0000000 0.6388889 0.3793103 0.5319149 0.5492958 0.3023256 0.8500000
## s5 0.8536585 0.1956522 0.5641026 0.3731343 0.3186813 0.7142857 0.2666667
## s6 0.9325843 0.2428571 0.5714286 0.5304348 0.2374101 0.6756757 0.5925926
##          s15       s16       s17       s18       s19       s20       s21
## s1 0.2075472 0.8571429 1.0000000 0.5689655 0.1692308 0.3333333 0.7333333
## s2 0.3750000 0.4720000 0.8620690 0.3146853 0.3695652 0.4022989 0.6666667
## s3 0.3584906 0.7346939 1.0000000 0.5344828 0.3230769 0.1000000 0.8222222
## s4 0.4090909 0.9325843 1.0000000 0.6635514 0.4642857 0.3333333 0.8333333
## s5 0.4687500 0.5045872 0.8095238 0.5118110 0.3947368 0.5211268 0.3571429
## s6 0.5357143 0.2484076 0.9111111 0.2571429 0.3870968 0.4621849 0.6730769
##          s22       s23       s24       s25       s26       s27       s28
## s1 0.7346939 0.4411765 0.5714286 0.7037037 0.6956522 0.6363636 0.3250000
## s2 0.3760000 0.5368421 0.2432432 0.3925926 0.3277311 0.3809524 0.2149533
## s3 0.6326531 0.5294118 0.3809524 0.6666667 0.6086957 0.6363636 0.5000000
## s4 0.9325843 0.8644068 0.5200000 0.9393939 0.9277108 0.9333333 0.5774648
## s5 0.3761468 0.2658228 0.4105263 0.5294118 0.4174757 0.3818182 0.3186813
## s6 0.2993631 0.4488189 0.3006993 0.1856287 0.1523179 0.2151899 0.2949640
##          s29       s30
## s1 0.4339623 0.6071429
## s2 0.3500000 0.3669065
## s3 0.4339623 0.5892857
## s4 0.5454545 0.8446602
## s5 0.3125000 0.4796748
## s6 0.5357143 0.2163743</code></pre>
<p>Because my loops work with site <em>numbers</em> and my function works
with site <em>names</em>, I have to remember to refer to the site names
when I call my function. I also have to supply row and column names
(the site names).</p>
<p>That looks all right. Are all my Bray-Curtis distances between 0 and 1? I can smoosh my matrix into a vector and summarize it:</p>
<div class="sourceCode" id="cb3700"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3700-1" data-line-number="1"><span class="kw">summary</span>(<span class="kw">as.vector</span>(m))</a></code></pre></div>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.0000  0.3571  0.5023  0.5235  0.6731  1.0000</code></pre>
<p>All the
dissimilarities are correctly between 0 and 1. We can also check the
one we did before:</p>
<div class="sourceCode" id="cb3702"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3702-1" data-line-number="1">bc2 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(site1 <span class="op">==</span><span class="st"> &quot;s3&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(s20)</a></code></pre></div>
<pre><code>## # A tibble: 1 x 1
##     s20
##   &lt;dbl&gt;
## 1   0.1</code></pre>
<p>or</p>
<div class="sourceCode" id="cb3704"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3704-1" data-line-number="1">m[<span class="dv">3</span>, <span class="dv">20</span>]</a></code></pre></div>
<pre><code>## [1] 0.1</code></pre>
<p>Check.</p>
<ol start="8" style="list-style-type: lower-alpha">
<li>Obtain the cluster memberships for each site, for your
preferred number of clusters from part (<a href="#part:prefclust">here</a>). Add a
column to the original data that you read in, in part
(<a href="#part:original">here</a>), containing those cluster memberships, . Obtain a plot that will enable you to assess the
relationship between those clusters and <code>pollution</code>. (Once you
have the cluster memberships, you can add them to the data frame and
make the graph using a pipe.) What do you see?</li>
</ol>
<p>Solution</p>
<p>Start by getting the clusters with <code>cutree</code>. I’m going with 3
clusters, though you can use the number of clusters you chose
before. (This is again making the grader’s life a misery, but her
instructions from me are to check that you have done something
reasonable, with the actual answer being less important.)</p>
<div class="sourceCode" id="cb3706"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3706-1" data-line-number="1">cluster &lt;-<span class="st"> </span><span class="kw">cutree</span>(d<span class="fl">.2</span>, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb3706-2" data-line-number="2">cluster</a></code></pre></div>
<pre><code>##  s1  s2  s3  s4  s5  s6  s7  s8  s9 s10 s11 s12 s13 s14 s15 s16 s17 s18 
##   1   2   1   1   3   2   3   3   2   1   1   2   1   3   1   2   3   2 
## s19 s20 s21 s22 s23 s24 s25 s26 s27 s28 s29 s30 
##   1   1   3   2   3   2   2   2   2   2   3   2</code></pre>
<p>Now, we add that to the original data, the data frame I called
<code>seabed.z</code>, and make a plot. The best one is a boxplot:</p>
<div class="sourceCode" id="cb3708"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3708-1" data-line-number="1">seabed.z <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3708-2" data-line-number="2"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">cluster =</span> <span class="kw">factor</span>(cluster)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3708-3" data-line-number="3"><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> cluster, <span class="dt">y =</span> pollution)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_boxplot</span>()</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/unnamed-chunk-41-1.png" width="672"  /></p>
<p>The clusters differ substantially in terms of the amount of pollution,
with my cluster 1 being highest and my cluster 2 being
lowest. (Cluster 3 has a low outlier.)</p>
<p>Any sensible plot will do here. I think boxplots are the best, but you
could also do something like vertically-faceted histograms:</p>
<div class="sourceCode" id="cb3709"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3709-1" data-line-number="1">seabed.z <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3709-2" data-line-number="2"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">cluster =</span> <span class="kw">factor</span>(cluster)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3709-3" data-line-number="3"><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> pollution)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_histogram</span>(<span class="dt">bins =</span> <span class="dv">8</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb3709-4" data-line-number="4"><span class="st">  </span><span class="kw">facet_grid</span>(cluster <span class="op">~</span><span class="st"> </span>.)</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/unnamed-chunk-42-1.png" width="672"  /></p>
<p>which to my mind doesn’t show the differences as dramatically. (The bins are
determined from all the data together, so that each facet actually has
fewer than 8 bins. You can see where the bins would be if they had any
data in them.)</p>
<p>Here’s how 5 clusters looks:</p>
<div class="sourceCode" id="cb3710"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3710-1" data-line-number="1">cluster &lt;-<span class="st"> </span><span class="kw">cutree</span>(d<span class="fl">.2</span>, <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb3710-2" data-line-number="2">cluster</a></code></pre></div>
<pre><code>##  s1  s2  s3  s4  s5  s6  s7  s8  s9 s10 s11 s12 s13 s14 s15 s16 s17 s18 
##   1   2   1   1   3   4   3   5   2   1   1   2   1   3   1   4   5   2 
## s19 s20 s21 s22 s23 s24 s25 s26 s27 s28 s29 s30 
##   1   1   3   4   3   2   4   4   4   2   3   4</code></pre>
<div class="sourceCode" id="cb3712"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3712-1" data-line-number="1">seabed.z <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3712-2" data-line-number="2"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">cluster =</span> <span class="kw">factor</span>(cluster)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3712-3" data-line-number="3"><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> cluster, <span class="dt">y =</span> pollution)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_boxplot</span>()</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/unnamed-chunk-43-1.png" width="672"  /></p>
<p>This time, the picture isn’t quite so clear-cut, but clusters 1 and 5
are the highest in terms of pollution and cluster 4 is the lowest. I’m
guessing that whatever number of clusters you choose, you’ll see some
differences in terms of pollution.</p>
<p>What is interesting is that <code>pollution</code> had <em>nothing</em> to
do with the original formation of the clusters: that was based only on
which species were found at each site. So, what we have shown here is that
the amount of pollution has some association with what species are found at a
site.</p>
<p>A way to go on with this is to use the clusters as “known groups”
and predict the cluster membership from <code>depth</code>,
<code>pollution</code> and <code>temp</code> using a discriminant
analysis. Then you could plot the sites, colour-coded by what cluster
they were in, and even though you had three variables, you could plot
it in two dimensions (or maybe even one dimension, depending how many
LD’s were important).</p>
</div>
<div id="dissimilarities-between-fruits" class="section level2">
<h2><span class="header-section-number">26.2</span> Dissimilarities between fruits</h2>
<p>Consider the fruits apple, orange, banana, pear,
strawberry, blueberry. We are going to work with these four
properties of fruits:</p>
<ul>
<li><p>has a round shape</p></li>
<li><p>Is sweet</p></li>
<li><p>Is crunchy</p></li>
<li><p>Is a berry</p></li>
</ul>
<ol style="list-style-type: lower-alpha">
<li>Make a table with fruits as columns, and with
rows “round shape”, “sweet”, “crunchy”, “berry”. In each cell
of the table, put a 1 if the fruit has the property named in the
row, and a 0 if it does not. (This is your opinion, and may not
agree with mine. That doesn’t matter, as long as you follow through
with whatever your choices were.)</li>
</ol>
<p>Solution</p>
<p>Something akin to this:</p>
<pre><code>
Fruit        Apple Orange Banana Pear Strawberry Blueberry
Round shape    1      1      0     0       0         1
Sweet          1      1      0     0       1         0
Crunchy        1      0      0     1       0         0
Berry          0      0      0     0       1         1
</code></pre>
<p>You’ll have to make a choice about “crunchy”. I usually eat
pears before they’re fully ripe, so to me, they’re crunchy.</p>
<ol start="2" style="list-style-type: lower-alpha">
<li>We’ll define the dissimilarity between two fruits to be the
number of qualities they <em>disagree</em> on. Thus, for example, the
dissimilarity between Apple and Orange is 1 (an apple is crunchy and
an orange is not, but they agree on everything else). Calculate the
dissimilarity between each pair of fruits, and make a square table
that summarizes the results. (To save yourself some work, note that
the dissimilarity between a fruit and itself must be zero, and the
dissimilarity between fruits A and B is the same as that between B
and A.) Save your table of dissimilarities into a file for the next part.</li>
</ol>
<p>Solution</p>
<p>I got this, by counting them:</p>
<pre><code> 
Fruit         Apple  Orange   Banana   Pear  Strawberry  Blueberry
Apple           0       1       3       2        3          3
Orange          1       0       2       3        2          2
Banana          3       2       0       1        2          2
Pear            2       3       1       0        3          3
Strawberry      3       2       2       3        0          2
Blueberry       3       2       2       3        2          0
</code></pre>
<p>I copied this into a file <code>fruits.txt</code>. Note that (i) I
have aligned my columns, so that I will be able to use
<code>read_table</code> later, and (ii) I have given the first column
a name, since <code>read_table</code> wants the same number of column
names as columns.</p>
<p>Extra: yes, you can do this in R too. We’ve seen some of the tricks
before.</p>
<p>Let’s start by reading in my table of fruits and properties, which
I saved in
<a href="http://www.utsc.utoronto.ca/~butler/d29/fruit1.txt">link</a>:</p>
<div class="sourceCode" id="cb3715"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3715-1" data-line-number="1">my_url &lt;-<span class="st"> &quot;http://www.utsc.utoronto.ca/~butler/d29/fruit1.txt&quot;</span></a>
<a class="sourceLine" id="cb3715-2" data-line-number="2">fruit1 &lt;-<span class="st"> </span><span class="kw">read_table</span>(my_url)</a></code></pre></div>
<pre><code>## Parsed with column specification:
## cols(
##   Property = col_character(),
##   Apple = col_double(),
##   Orange = col_double(),
##   Banana = col_double(),
##   Pear = col_double(),
##   Strawberry = col_double(),
##   Blueberry = col_double()
## )</code></pre>
<div class="sourceCode" id="cb3717"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3717-1" data-line-number="1">fruit1</a></code></pre></div>
<pre><code>## # A tibble: 4 x 7
##   Property    Apple Orange Banana  Pear Strawberry Blueberry
##   &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;     &lt;dbl&gt;
## 1 Round.shape     1      1      0     0          0         1
## 2 Sweet           1      1      0     0          1         0
## 3 Crunchy         1      0      0     1          0         0
## 4 Berry           0      0      0     0          1         1</code></pre>
<p>We don’t need the first column, so we’ll get rid of it:</p>
<div class="sourceCode" id="cb3719"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3719-1" data-line-number="1">fruit2 &lt;-<span class="st"> </span>fruit1 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(<span class="op">-</span>Property)</a>
<a class="sourceLine" id="cb3719-2" data-line-number="2">fruit2</a></code></pre></div>
<pre><code>## # A tibble: 4 x 6
##   Apple Orange Banana  Pear Strawberry Blueberry
##   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;     &lt;dbl&gt;
## 1     1      1      0     0          0         1
## 2     1      1      0     0          1         0
## 3     1      0      0     1          0         0
## 4     0      0      0     0          1         1</code></pre>
<p>The loop way is the most direct. We’re going to be looking at
combinations of fruits and other fruits, so we’ll need two loops one
inside the other. It’s easier for this to work with column numbers,
which here are 1 through 6, and we’ll make a matrix <code>m</code> with
the dissimilarities in it, which we have to initialize first. I’ll
initialize it to a <span class="math inline">\(6\times 6\)</span> matrix of <code>-1</code>, since the final
dissimilarities are 0 or bigger, and this way I’ll know if I forgot
anything.</p>
<p>Here’s where we are at so far:</p>
<div class="sourceCode" id="cb3721"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3721-1" data-line-number="1">fruit_m &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">6</span>, <span class="dv">6</span>)</a>
<a class="sourceLine" id="cb3721-2" data-line-number="2"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">6</span>) {</a>
<a class="sourceLine" id="cb3721-3" data-line-number="3">  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">6</span>) {</a>
<a class="sourceLine" id="cb3721-4" data-line-number="4">    fruit_m[i, j] &lt;-<span class="st"> </span><span class="dv">3</span> <span class="co"># dissim between fruit i and fruit j</span></a>
<a class="sourceLine" id="cb3721-5" data-line-number="5">  }</a>
<a class="sourceLine" id="cb3721-6" data-line-number="6">}</a></code></pre></div>
<p>This, of course, doesn’t run yet. The sticking point is how to
calculate the dissimilarity between two columns. I think that is a
separate thought process that should be in a function of its own. The
inputs are the two column numbers, and a data frame to get those
columns from:</p>
<div class="sourceCode" id="cb3722"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3722-1" data-line-number="1">dissim &lt;-<span class="st"> </span><span class="cf">function</span>(i, j, d) {</a>
<a class="sourceLine" id="cb3722-2" data-line-number="2">  x &lt;-<span class="st"> </span>d <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(i)</a>
<a class="sourceLine" id="cb3722-3" data-line-number="3">  y &lt;-<span class="st"> </span>d <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(j)</a>
<a class="sourceLine" id="cb3722-4" data-line-number="4">  <span class="kw">sum</span>(x <span class="op">!=</span><span class="st"> </span>y)</a>
<a class="sourceLine" id="cb3722-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb3722-6" data-line-number="6"><span class="kw">dissim</span>(<span class="dv">1</span>, <span class="dv">2</span>, fruit2)</a></code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>Apple and orange differ by one (not being crunchy). The process is:
grab the <span class="math inline">\(i\)</span>-th column and call it <code>x</code>, grab the <span class="math inline">\(j\)</span>-th column
and call it <code>y</code>. These are two one-column data frames with four
rows each (the four properties). <code>x!=y</code> goes down the rows, and
for each one gives a <code>TRUE</code> if they’re different and a
<code>FALSE</code> if they’re the same. So <code>x!=y</code> is a collection
of four T-or-F values. This seems backwards, but I was thinking of
what we want to do: we want to count the number of different
ones. Numerically, <code>TRUE</code> counts as 1 and <code>FALSE</code> as 0,
so we should make the thing we’re counting (the different ones) come
out as <code>TRUE</code>. To count the number of <code>TRUE</code>s (1s), add
them up.</p>
<p>That was a complicated thought process, so it was probably wise to
write a function to do it. Now, in our loop, we only have to call the
function (having put some thought into getting it right):</p>
<div class="sourceCode" id="cb3724"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3724-1" data-line-number="1">fruit_m &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">6</span>, <span class="dv">6</span>)</a>
<a class="sourceLine" id="cb3724-2" data-line-number="2"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">6</span>) {</a>
<a class="sourceLine" id="cb3724-3" data-line-number="3">  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">6</span>) {</a>
<a class="sourceLine" id="cb3724-4" data-line-number="4">    fruit_m[i, j] &lt;-<span class="st"> </span><span class="kw">dissim</span>(i, j, fruit2)</a>
<a class="sourceLine" id="cb3724-5" data-line-number="5">  }</a>
<a class="sourceLine" id="cb3724-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb3724-7" data-line-number="7">fruit_m</a></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6]
## [1,]    0    1    3    2    3    3
## [2,]    1    0    2    3    2    2
## [3,]    3    2    0    1    2    2
## [4,]    2    3    1    0    3    3
## [5,]    3    2    2    3    0    2
## [6,]    3    2    2    3    2    0</code></pre>
<p>The last step is re-associate the fruit names with this matrix. This
is a <code>matrix</code> so it has a <code>rownames</code> and a
<code>colnames</code>. We set both of those, but first we have to get the
fruit names from <code>fruit2</code>:</p>
<div class="sourceCode" id="cb3726"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3726-1" data-line-number="1">fruit_names &lt;-<span class="st"> </span><span class="kw">names</span>(fruit2)</a>
<a class="sourceLine" id="cb3726-2" data-line-number="2"><span class="kw">rownames</span>(fruit_m) &lt;-<span class="st"> </span>fruit_names</a>
<a class="sourceLine" id="cb3726-3" data-line-number="3"><span class="kw">colnames</span>(fruit_m) &lt;-<span class="st"> </span>fruit_names</a>
<a class="sourceLine" id="cb3726-4" data-line-number="4">fruit_m</a></code></pre></div>
<pre><code>##            Apple Orange Banana Pear Strawberry Blueberry
## Apple          0      1      3    2          3         3
## Orange         1      0      2    3          2         2
## Banana         3      2      0    1          2         2
## Pear           2      3      1    0          3         3
## Strawberry     3      2      2    3          0         2
## Blueberry      3      2      2    3          2         0</code></pre>
<p>This is good to go into the cluster analysis (happening later).</p>
<p>There is a <code>tidyverse</code> way to do this also. It’s actually a lot
like the loop way in its conception, but the coding looks
different. We start by making all combinations of the fruit names with
each other, which is <code>crossing</code>:</p>
<div class="sourceCode" id="cb3728"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3728-1" data-line-number="1">combos &lt;-<span class="st"> </span><span class="kw">crossing</span>(<span class="dt">fruit =</span> fruit_names, <span class="dt">other =</span> fruit_names)</a>
<a class="sourceLine" id="cb3728-2" data-line-number="2">combos</a></code></pre></div>
<pre><code>## # A tibble: 36 x 2
##    fruit  other     
##    &lt;chr&gt;  &lt;chr&gt;     
##  1 Apple  Apple     
##  2 Apple  Banana    
##  3 Apple  Blueberry 
##  4 Apple  Orange    
##  5 Apple  Pear      
##  6 Apple  Strawberry
##  7 Banana Apple     
##  8 Banana Banana    
##  9 Banana Blueberry 
## 10 Banana Orange    
## # … with 26 more rows</code></pre>
<p>Now, we want a function that, given any two fruit <em>names</em>, works
out the dissimilarity between them. A happy coincidence is that we can
use the function we had before, <em>unmodified</em>! How? Take a look:</p>
<div class="sourceCode" id="cb3730"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3730-1" data-line-number="1">dissim &lt;-<span class="st"> </span><span class="cf">function</span>(i, j, d) {</a>
<a class="sourceLine" id="cb3730-2" data-line-number="2">  x &lt;-<span class="st"> </span>d <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(i)</a>
<a class="sourceLine" id="cb3730-3" data-line-number="3">  y &lt;-<span class="st"> </span>d <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(j)</a>
<a class="sourceLine" id="cb3730-4" data-line-number="4">  <span class="kw">sum</span>(x <span class="op">!=</span><span class="st"> </span>y)</a>
<a class="sourceLine" id="cb3730-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb3730-6" data-line-number="6"><span class="kw">dissim</span>(<span class="st">&quot;Apple&quot;</span>, <span class="st">&quot;Orange&quot;</span>, fruit2)</a></code></pre></div>
<pre><code>## [1] 1</code></pre>
<p><code>select</code> can take a column number <em>or a column name</em>, so
that running it with column names gives the right answer.</p>
<p>Now, we want to run this function for each of the pairs in
<code>combos</code>. The “for each” is <code>fruit</code> and <code>other</code>
in parallel, so it’s <code>map2</code> rather than <code>map</code>. Also, the
dissimilarity is a whole number each time, so we need
<code>map2_int</code>. So we can do this:</p>
<div class="sourceCode" id="cb3732"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3732-1" data-line-number="1">combos <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(<span class="dt">dissim =</span> <span class="kw">map2_int</span>(fruit, other, dissim, fruit2))</a></code></pre></div>
<pre><code>## # A tibble: 36 x 3
##    fruit  other      dissim
##    &lt;chr&gt;  &lt;chr&gt;       &lt;int&gt;
##  1 Apple  Apple           0
##  2 Apple  Banana          3
##  3 Apple  Blueberry       3
##  4 Apple  Orange          1
##  5 Apple  Pear            2
##  6 Apple  Strawberry      3
##  7 Banana Apple           3
##  8 Banana Banana          0
##  9 Banana Blueberry       2
## 10 Banana Orange          2
## # … with 26 more rows</code></pre>
<p>This would work just as well using <code>fruit1</code> rather than
<code>fruit</code>, since we are picking out the columns by name rather
than number.</p>
<p>To make this into something we can turn into a <code>dist</code> object
later, we need to <code>spread</code> the column <code>other</code> to make a
square array:</p>
<div class="sourceCode" id="cb3734"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3734-1" data-line-number="1">fruit_spread &lt;-<span class="st"> </span>combos <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3734-2" data-line-number="2"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">dissim =</span> <span class="kw">map2_int</span>(fruit, other, dissim, fruit2)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3734-3" data-line-number="3"><span class="st">  </span><span class="kw">spread</span>(other, dissim)</a>
<a class="sourceLine" id="cb3734-4" data-line-number="4">fruit_spread</a></code></pre></div>
<pre><code>## # A tibble: 6 x 7
##   fruit      Apple Banana Blueberry Orange  Pear Strawberry
##   &lt;chr&gt;      &lt;int&gt;  &lt;int&gt;     &lt;int&gt;  &lt;int&gt; &lt;int&gt;      &lt;int&gt;
## 1 Apple          0      3         3      1     2          3
## 2 Banana         3      0         2      2     1          2
## 3 Blueberry      3      2         0      2     3          2
## 4 Orange         1      2         2      0     3          2
## 5 Pear           2      1         3      3     0          3
## 6 Strawberry     3      2         2      2     3          0</code></pre>
<p>Done!</p>
<ol start="3" style="list-style-type: lower-alpha">
<li>Do a hierarchical cluster analysis using complete
linkage. Display your dendrogram.</li>
</ol>
<p>Solution</p>
<p>First, we need to take one of our matrices of dissimilarities
and turn it into a <code>dist</code> object. Since I asked you to
save yours into a file, let’s start from there. Mine is aligned
columns:</p>
<div class="sourceCode" id="cb3736"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3736-1" data-line-number="1">dissims &lt;-<span class="st"> </span><span class="kw">read_table</span>(<span class="st">&quot;fruits.txt&quot;</span>)</a></code></pre></div>
<pre><code>## Parsed with column specification:
## cols(
##   fruit = col_character(),
##   Apple = col_double(),
##   Orange = col_double(),
##   Banana = col_double(),
##   Pear = col_double(),
##   Strawberry = col_double(),
##   Blueberry = col_double()
## )</code></pre>
<div class="sourceCode" id="cb3738"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3738-1" data-line-number="1">dissims</a></code></pre></div>
<pre><code>## # A tibble: 6 x 7
##   fruit      Apple Orange Banana  Pear Strawberry Blueberry
##   &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;     &lt;dbl&gt;
## 1 Apple          0      1      3     2          3         3
## 2 Orange         1      0      2     3          2         2
## 3 Banana         3      2      0     1          2         2
## 4 Pear           2      3      1     0          3         3
## 5 Strawberry     3      2      2     3          0         2
## 6 Blueberry      3      2      2     3          2         0</code></pre>
<p>Then turn it into a <code>dist</code> object. The first step is to take
off the first column, since <code>as.dist</code> can get the names from
the columns:</p>
<div class="sourceCode" id="cb3740"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3740-1" data-line-number="1">d &lt;-<span class="st"> </span>dissims <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3740-2" data-line-number="2"><span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>fruit) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3740-3" data-line-number="3"><span class="st">  </span><span class="kw">as.dist</span>()</a>
<a class="sourceLine" id="cb3740-4" data-line-number="4">d</a></code></pre></div>
<pre><code>##            Apple Orange Banana Pear Strawberry
## Orange         1                              
## Banana         3      2                       
## Pear           2      3      1                
## Strawberry     3      2      2    3           
## Blueberry      3      2      2    3          2</code></pre>
<p>If you forget to take off the first column, this happens:</p>
<div class="sourceCode" id="cb3742"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3742-1" data-line-number="1"><span class="kw">as.dist</span>(dissims)</a></code></pre></div>
<pre><code>## Warning in storage.mode(m) &lt;- &quot;numeric&quot;: NAs introduced by coercion</code></pre>
<pre><code>## Warning in as.dist.default(dissims): non-square matrix</code></pre>
<pre><code>## Error in dimnames(df) &lt;- if (is.null(labels)) list(seq_len(size), seq_len(size)) else list(labels, : length of &#39;dimnames&#39; [1] not equal to array extent</code></pre>
<p>The key thing here is “non-square matrix”: you have one more column
than you have rows, since you have a column of fruit names.</p>
<p>This one is <code>as.dist</code> since you already have dissimilarities
and you want to arrange them into the right type of
thing. <code>dist</code> is for <em>calculating</em> dissimilarities, which
we did before, so we don’t want to do that now.</p>
<p>Now, after all that work, the actual cluster analysis and dendrogram:</p>
<div class="sourceCode" id="cb3746"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3746-1" data-line-number="1">fruits<span class="fl">.1</span> &lt;-<span class="st"> </span><span class="kw">hclust</span>(d, <span class="dt">method =</span> <span class="st">&quot;complete&quot;</span>)</a>
<a class="sourceLine" id="cb3746-2" data-line-number="2"><span class="kw">plot</span>(fruits<span class="fl">.1</span>)</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/hkadh-1.png" width="672"  /></p>
<ol start="4" style="list-style-type: lower-alpha">
<li>How many clusters, of what fruits, do you seem to have?
Explain briefly.</li>
</ol>
<p>Solution</p>
<p>I reckon I have three clusters: strawberry and blueberry in one,
apple and orange in the second, and banana and pear in the
third. (If your dissimilarities were different from mine, your
dendrogram will be different also.)</p>
<ol start="5" style="list-style-type: lower-alpha">
<li>Pick a pair of clusters (with at least 2 fruits in each)
from your dendrogram. Verify that
the complete-linkage distance on your dendrogram is correct.</li>
</ol>
<p>Solution</p>
<p>I’ll pick strawberry-blueberry and and apple-orange. I’ll arrange
the dissimilarities like this:</p>
<pre><code>
apple   orange
strawberry    3       2
blueberry     3       2
</code></pre>
<p>The largest of those is 3, so that’s the complete-linkage
distance. That’s also what the dendrogram says.
(Likewise, the smallest of those is 2, so 2 is the
single-linkage distance.) That is to say, the largest distance or
dissimilarity
from anything in one cluster to anything in the other is 3, and
the smallest is 2.
I don’t mind which pair of clusters you take, as long as you spell
out the dissimilarity (distance) between each fruit in each
cluster, and take the maximum of those. Besides, if your
dissimilarities are different from mine, your complete-linkage
distance could be different from mine also. The grader will have
to use her judgement!
<label for="tufte-mn-238" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-238" class="margin-toggle"><span class="marginnote">That’s two cups of coffee I owe the grader now.</span><br />
The important point is that you assess the dissimilarities between
fruits in one cluster and fruits in the other. The dissimilarities
between fruits in the same cluster don’t enter into it xxx.
<label for="tufte-mn-239" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-239" class="margin-toggle"><span class="marginnote">I now have a mental image of John Cleese saying <em>it don’t enter into it</em> in the infamous Dead Parrot sketch, <a href="https://www.youtube.com/watch?v=vnciwwsvNcc" class="uri">https://www.youtube.com/watch?v=vnciwwsvNcc</a>. Not to mention <em>How to defend yourself against an assailant armed with fresh fruit</em>, <a href="https://www.youtube.com/watch?v=4JgbOkLdRaE" class="uri">https://www.youtube.com/watch?v=4JgbOkLdRaE</a>. </span>
As it happens, all my complete-linkage distances between clusters
(of at least 2 fruits) are 3. The single-linkage ones are
different, though:</p>
<div class="sourceCode" id="cb3748"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3748-1" data-line-number="1">fruits<span class="fl">.2</span> &lt;-<span class="st"> </span><span class="kw">hclust</span>(d, <span class="dt">method =</span> <span class="st">&quot;single&quot;</span>)</a>
<a class="sourceLine" id="cb3748-2" data-line-number="2"><span class="kw">plot</span>(fruits<span class="fl">.2</span>)</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/lhsdjhad-1.png" width="672"  /></p>
<p>All the single-linkage cluster distances are 2. (OK, so this wasn’t a
very interesting example, but I wanted to give you one where you could
calculate what was going on.)</p>
</div>
<div id="similarity-of-species" class="section level2">
<h2><span class="header-section-number">26.3</span> Similarity of species</h2>
<p>Two scientists assessed the dissimilarity
between a number
of species by recording the number of positions in the protein
molecule cytochrome-<span class="math inline">\(c\)</span> where the two species being compared have
different amino acids. The dissimilarities that they recorded are in
<a href="http://www.utsc.utoronto.ca/~butler/d29/species.txt">link</a>.</p>
<ol style="list-style-type: lower-alpha">
<li>Read the data into a data frame and take a look at it.</li>
</ol>
<p>Solution</p>
<p>Nothing much new here:</p>
<div class="sourceCode" id="cb3749"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3749-1" data-line-number="1">my_url &lt;-<span class="st"> &quot;http://www.utsc.utoronto.ca/~butler/d29/species.txt&quot;</span></a>
<a class="sourceLine" id="cb3749-2" data-line-number="2">species &lt;-<span class="st"> </span><span class="kw">read_delim</span>(my_url, <span class="st">&quot; &quot;</span>)</a></code></pre></div>
<pre><code>## Parsed with column specification:
## cols(
##   what = col_character(),
##   Man = col_double(),
##   Monkey = col_double(),
##   Horse = col_double(),
##   Pig = col_double(),
##   Pigeon = col_double(),
##   Tuna = col_double(),
##   Mould = col_double(),
##   Fungus = col_double()
## )</code></pre>
<div class="sourceCode" id="cb3751"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3751-1" data-line-number="1">species</a></code></pre></div>
<pre><code>## # A tibble: 8 x 9
##   what     Man Monkey Horse   Pig Pigeon  Tuna Mould Fungus
##   &lt;chr&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1 Man        0      1    17    13     16    31    63     66
## 2 Monkey     1      0    16    12     15    32    62     65
## 3 Horse     17     16     0     5     16    27    64     68
## 4 Pig       13     12     5     0     13    25    64     67
## 5 Pigeon    16     15    16    13      0    27    59     66
## 6 Tuna      31     32    27    25     27     0    72     69
## 7 Mould     63     62    64    64     59    72     0     61
## 8 Fungus    66     65    68    67     66    69    61      0</code></pre>
<p>This is a square array of dissimilarities between the eight species.</p>
<p>The data set came from the 1960s, hence the use of “Man” rather than
“human”. It probably also came from the UK, judging by the spelling
of <code>Mould</code>.</p>
<p>(I gave the first column the name <code>what</code> so that you could
safely use <code>species</code> for the whole data frame.)</p>
<ol start="2" style="list-style-type: lower-alpha">
<li>Bearing in mind that the values you read in are
<em>already</em> dissimilarities, convert them into a <code>dist</code>
object suitable for running a cluster analysis on, and display the
results. (Note that you need to get rid of any columns that don’t
contain numbers.)</li>
</ol>
<p>Solution</p>
<p>The point here is that the values you have are <em>already</em>
dissimilarities, so no conversion of the numbers is required. Thus
this is a job for <code>as.dist</code>, which merely changes how it
looks. Use a pipeline to get rid of the first column first:</p>
<div class="sourceCode" id="cb3753"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3753-1" data-line-number="1">species <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3753-2" data-line-number="2"><span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>what) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3753-3" data-line-number="3"><span class="st">  </span><span class="kw">as.dist</span>() -&gt;<span class="st"> </span>d</a>
<a class="sourceLine" id="cb3753-4" data-line-number="4">d</a></code></pre></div>
<pre><code>##        Man Monkey Horse Pig Pigeon Tuna Mould
## Monkey   1                                   
## Horse   17     16                            
## Pig     13     12     5                      
## Pigeon  16     15    16  13                  
## Tuna    31     32    27  25     27           
## Mould   63     62    64  64     59   72      
## Fungus  66     65    68  67     66   69    61</code></pre>
<p>This doesn’t display anything that it doesn’t need to: we know that the
dissimilarity between a species and itself is zero (no need to show
that), and that the dissimilarity between B and A is the same as
between A and B, so no need to show everything twice. It might look as
if you are missing a row and a column, but one of the species (Fungus)
appears only in a row and one of them (Man) only in a column.</p>
<p>This also works, to select only the numerical columns:</p>
<div class="sourceCode" id="cb3755"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3755-1" data-line-number="1">species <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3755-2" data-line-number="2"><span class="st">  </span><span class="kw">select_if</span>(is.numeric) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3755-3" data-line-number="3"><span class="st">  </span><span class="kw">as.dist</span>()</a></code></pre></div>
<pre><code>##        Man Monkey Horse Pig Pigeon Tuna Mould
## Monkey   1                                   
## Horse   17     16                            
## Pig     13     12     5                      
## Pigeon  16     15    16  13                  
## Tuna    31     32    27  25     27           
## Mould   63     62    64  64     59   72      
## Fungus  66     65    68  67     66   69    61</code></pre>
<p>Extra: data frames officially have an attribute called “row names”,
that is displayed where the row numbers display, but which isn’t
actually a column of the data frame. In the past, when we used
<code>read.table</code> with a dot, the first column of data read in from
the file could be nameless (that is, you could have one more column of
data than you had column names) and the first column would be treated
as row names. People used row names for things like identifier
variables. But row names have this sort of half-existence, and when
Hadley Wickham designed the <code>tidyverse</code>, he decided not to use
row names, taking the attitude that if it’s part of the data, it
should be in the data frame as a genuine column. This means that when
you use a <code>read_</code> function, you have to have exactly as many
column names as columns.</p>
<p>For these data, I previously had the column here called
<code>what</code> as row names, and <code>as.dist</code> automatically got rid
of the row names when formatting the distances. Now, it’s a
genuine column, so I have to get rid of it before running
<code>as.dist</code>. This is more work, but it’s also more honest, and
doesn’t involve thinking about row names at all. So, on balance, I
think it’s a win.</p>
<ol start="3" style="list-style-type: lower-alpha">
<li>Run a cluster analysis using single-linkage and obtain a dendrogram.</li>
</ol>
<p>Solution</p>
<p>Something like this:</p>
<div class="sourceCode" id="cb3757"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3757-1" data-line-number="1">species<span class="fl">.1</span> &lt;-<span class="st"> </span><span class="kw">hclust</span>(d, <span class="dt">method =</span> <span class="st">&quot;single&quot;</span>)</a>
<a class="sourceLine" id="cb3757-2" data-line-number="2"><span class="kw">plot</span>(species<span class="fl">.1</span>)</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/unnamed-chunk-60-1.png" width="672"  /></p>
<ol start="4" style="list-style-type: lower-alpha">
<li>Run a cluster analysis using Ward’s method and obtain a dendrogram.</li>
</ol>
<p>Solution</p>
<p>Not much changes here in the code, but the result is noticeably
different:</p>
<div class="sourceCode" id="cb3758"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3758-1" data-line-number="1">species<span class="fl">.2</span> &lt;-<span class="st"> </span><span class="kw">hclust</span>(d, <span class="dt">method =</span> <span class="st">&quot;ward.D&quot;</span>)</a>
<a class="sourceLine" id="cb3758-2" data-line-number="2"><span class="kw">plot</span>(species<span class="fl">.2</span>)</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/unnamed-chunk-61-1.png" width="672"  /></p>
<p>Fewer points this time since you’re doing much of the same stuff over again.</p>
<p>Don’t forget to take care with the <code>method</code>: it has to be
<code>ward</code> in lowercase (even though it’s someone’s name) followed
by a D in uppercase.</p>
<ol start="5" style="list-style-type: lower-alpha">
<li>Describe how the two dendrograms from the last two parts
look different.</li>
</ol>
<p>Solution</p>
<p>This is (as ever with this kind of thing) a judgement call. Your
job is to come up with something reasonable.
For myself, I was thinking about how single-linkage tends to
produce “stringy” clusters that join single objects (species)
onto already-formed clusters. Is that happening here? Apart from
the first two clusters, man and monkey, horse and pig,
<em>everything</em> that gets joined on is a single species joined
on to a bigger cluster, including mould and fungus right at the
end. Contrast that with the output from Ward’s method, where, for
the most part, groups are formed first and then joined onto other
groups. For example, in Ward’s method, mould and fungus are joined
earlier, and also the man-monkey group is joined to the
pigeon-horse-pig group.
<label for="tufte-mn-240" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-240" class="margin-toggle"><span class="marginnote">Tuna is an exception, but usually Ward tends to join fairly dissimilar things that are nonetheless more similar to each other than to anything else. This is like Hungarian and Finnish in the example in class: they are very dissimilar languages, but they are more similar to each other than to anything else.</span>
You might prefer to look at the specifics of what gets joined. I
think the principal difference from this angle is that mould and
fungus get joined together (much) earlier in Ward. Also, pigeon
gets joined to horse and pig first under Ward, but <em>after</em>
those have been joined to man and monkey under
single-linkage. This is also a reasonable kind of observation.</p>
<ol start="6" style="list-style-type: lower-alpha">
<li>Looking at your clustering for Ward’s method, what seems to
be a sensible number of clusters? Draw boxes around those clusters.</li>
</ol>
<p>Solution</p>
<p>Pretty much any number of clusters bigger than 1 and smaller than
8 is ok here, but I would prefer to see something between 2 and
5, because a number of clusters of that sort offers (i) some
insight (“these things are like these other things”) and (ii) a
number of clusters of that sort is supported by the data.
To draw those clusters, you need <code>rect.hclust</code>, and
before that you’ll need to plot the cluster object again. For 2
clusters, that would look like this:</p>
<div class="sourceCode" id="cb3759"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3759-1" data-line-number="1"><span class="kw">plot</span>(species<span class="fl">.2</span>)</a>
<a class="sourceLine" id="cb3759-2" data-line-number="2"><span class="kw">rect.hclust</span>(species<span class="fl">.2</span>, <span class="dv">2</span>)</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/unnamed-chunk-62-1.png" width="672"  /></p>
<p>This one is “mould and fungus vs. everything else”. (My red boxes
seem to have gone off the side, sorry.)</p>
<p>Or we could go to the other end of the scale:</p>
<div class="sourceCode" id="cb3760"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3760-1" data-line-number="1"><span class="kw">plot</span>(species<span class="fl">.2</span>)</a>
<a class="sourceLine" id="cb3760-2" data-line-number="2"><span class="kw">rect.hclust</span>(species<span class="fl">.2</span>, <span class="dv">5</span>)</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/unnamed-chunk-63-1.png" width="672"  /></p>
<p>Five is not really an insightful number of clusters with 8 species,
but it seems to correspond (for me at least) with a reasonable
division of these species into “kinds of living things”. That is, I
am bringing some outside knowledge into my number-of-clusters division.</p>
<ol start="7" style="list-style-type: lower-alpha">
<li>List which cluster each species is in, for your preferred
number of clusters (from Ward’s method).</li>
</ol>
<p>Solution</p>
<p>This is <code>cutree</code>. For 2 clusters it would be this:</p>
<div class="sourceCode" id="cb3761"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3761-1" data-line-number="1"><span class="kw">cutree</span>(species<span class="fl">.2</span>, <span class="dv">2</span>)</a></code></pre></div>
<pre><code>##    Man Monkey  Horse    Pig Pigeon   Tuna  Mould Fungus 
##      1      1      1      1      1      1      2      2</code></pre>
<p>For 5 it would be this:</p>
<div class="sourceCode" id="cb3763"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3763-1" data-line-number="1"><span class="kw">cutree</span>(species<span class="fl">.2</span>, <span class="dv">5</span>)</a></code></pre></div>
<pre><code>##    Man Monkey  Horse    Pig Pigeon   Tuna  Mould Fungus 
##      1      1      2      2      2      3      4      5</code></pre>
<p>and anything in between is in between.</p>
<p>These ones came out sorted, so there is no need to sort them (so you
don’t need the methods of the next question).</p>
</div>
<div id="rating-beer" class="section level2">
<h2><span class="header-section-number">26.4</span> Rating beer</h2>
<p>Thirty-two students each rated 10 brands of beer:</p>
<ul>
<li><p>Anchor Steam</p></li>
<li><p>Bass</p></li>
<li><p>Beck’s</p></li>
<li><p>Corona</p></li>
<li><p>Gordon Biersch</p></li>
<li><p>Guinness</p></li>
<li><p>Heineken</p></li>
<li><p>Pete’s Wicked Ale</p></li>
<li><p>Sam Adams</p></li>
<li><p>Sierra Nevada</p></li>
</ul>
<p>The ratings are on a scale of 1 to 9, with a higher
rating being better.
The data are in
<a href="http://www.utsc.utoronto.ca/~butler/d29/beer.txt">link</a>. I
abbreviated the beer names for the data file. I hope you can figure
out which is which.</p>
<ol style="list-style-type: lower-alpha">
<li>Read in the data, and look at the first few rows.</li>
</ol>
<p>Solution</p>
<p>Data values are aligned in columns, but the column headers are
not aligned with them, so <code>read_table2</code>:</p>
<div class="sourceCode" id="cb3765"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3765-1" data-line-number="1">my_url &lt;-<span class="st"> &quot;http://www.utsc.utoronto.ca/~butler/d29/beer.txt&quot;</span></a>
<a class="sourceLine" id="cb3765-2" data-line-number="2">beer &lt;-<span class="st"> </span><span class="kw">read_table2</span>(my_url)</a></code></pre></div>
<pre><code>## Parsed with column specification:
## cols(
##   student = col_character(),
##   AnchorS = col_double(),
##   Bass = col_double(),
##   Becks = col_double(),
##   Corona = col_double(),
##   GordonB = col_double(),
##   Guinness = col_double(),
##   Heineken = col_double(),
##   PetesW = col_double(),
##   SamAdams = col_double(),
##   SierraN = col_double()
## )</code></pre>
<div class="sourceCode" id="cb3767"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3767-1" data-line-number="1">beer</a></code></pre></div>
<pre><code>## # A tibble: 32 x 11
##    student AnchorS  Bass Becks Corona GordonB Guinness Heineken PetesW
##    &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;
##  1 S001          5     9     7      1       7        6        6      5
##  2 S008          7     5     6      8       8        4        8      8
##  3 S015          7     7     5      6       6        1        8      4
##  4 S022          7     7     5      2       5        8        4      6
##  5 S029          9     7     3      1       6        8        2      7
##  6 S036          7     6     4      3       7        6        6      5
##  7 S043          5     5     5      6       6        4        7      5
##  8 S050          5     3     1      5       5        5        3      5
##  9 S057          9     3     2      6       4        6        1      5
## 10 S064          2     6     6      5       6        4        8      4
## # … with 22 more rows, and 2 more variables: SamAdams &lt;dbl&gt;, SierraN &lt;dbl&gt;</code></pre>
<p>32 rows (students), 11 columns (10 beers, plus a column of student
IDs). All seems to be kosher. If beer can be kosher.
<label for="tufte-mn-241" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-241" class="margin-toggle"><span class="marginnote">I investigated. It can; in fact, I found a long list of kosher beers that included Anchor Steam.</span></p>
<ol start="2" style="list-style-type: lower-alpha">
<li>The researcher who collected the data wants to see which
beers are rated similarly to which other beers. Try to create a
distance matrix from these data and explain why it didn’t do what
you wanted. (Remember to get rid of the <code>student</code> column
first.)</li>
</ol>
<p>Solution</p>
<p>The obvious thing is to feed these ratings into <code>dist</code>
(we are <em>creating</em> distances rather than re-formatting
things that are already distances). We need to skip the first
column, since those are student identifiers:</p>
<div class="sourceCode" id="cb3769"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3769-1" data-line-number="1">beer <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3769-2" data-line-number="2"><span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>student) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3769-3" data-line-number="3"><span class="st">  </span><span class="kw">dist</span>() -&gt;<span class="st"> </span>d</a>
<a class="sourceLine" id="cb3769-4" data-line-number="4"><span class="kw">glimpse</span>(d)</a></code></pre></div>
<pre><code>##  &#39;dist&#39; num [1:496] 9.8 8.49 6.56 8.89 8.19 ...
##  - attr(*, &quot;Size&quot;)= int 32
##  - attr(*, &quot;Diag&quot;)= logi FALSE
##  - attr(*, &quot;Upper&quot;)= logi FALSE
##  - attr(*, &quot;method&quot;)= chr &quot;euclidean&quot;
##  - attr(*, &quot;call&quot;)= language dist(x = .)</code></pre>
<p>The 496 distances are:</p>
<div class="sourceCode" id="cb3771"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3771-1" data-line-number="1"><span class="dv">32</span> <span class="op">*</span><span class="st"> </span><span class="dv">31</span> <span class="op">/</span><span class="st"> </span><span class="dv">2</span></a></code></pre></div>
<pre><code>## [1] 496</code></pre>
<p>the number of ways of choosing 2 objects out of 32, when order does
not matter.
Feel free to be offended by my choice of the letter <code>d</code> to
denote both data frames (that I didn’t want to give a better name to)
and dissimilarities in <code>dist</code> objects.</p>
<p>You can look at the whole thing if you like, though it is rather
large. A <code>dist</code> object is stored internally as a long vector
(here of 496 values); it’s displayed as a nice triangle. The clue here
is the thing called <code>Size</code>, which indicates that we have a
<span class="math inline">\(32\times 32\)</span> matrix of distances <em>between the 32 students</em>, so
that if we were to go on and do a cluster analysis based on this
<code>d</code>, we’d get a clustering of the <em>students</em> rather than
of the <em>beers</em>, as we want. (If you just print out <code>d</code>,
you’ll see that is of distances between 32 (unlabelled) objects, which
by inference must be the 32 students.)</p>
<p>It might be interesting to do a cluster analysis of the 32 students
(it would tell you which of the students have similar taste in beer),
but that’s not what we have in mind here.</p>
<ol start="3" style="list-style-type: lower-alpha">
<li>The R function <code>t()</code> <em>transposes</em> a matrix: that
is, it interchanges rows and columns. Feed the transpose of your
read-in beer ratings into <code>dist</code>. Does this now give
distances between beers?</li>
</ol>
<p>Solution</p>
<p>Again, omit the first column. The pipeline code looks a bit weird:</p>
<div class="sourceCode" id="cb3773"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3773-1" data-line-number="1">beer <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3773-2" data-line-number="2"><span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>student) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3773-3" data-line-number="3"><span class="st">  </span><span class="kw">t</span>() <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3773-4" data-line-number="4"><span class="st">  </span><span class="kw">dist</span>() -&gt;<span class="st"> </span>d</a></code></pre></div>
<p>so you should feel free to do it in a couple of steps. This way shows
that you can also refer to columns by number:</p>
<div class="sourceCode" id="cb3774"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3774-1" data-line-number="1">beer <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(<span class="op">-</span><span class="dv">1</span>) -&gt;<span class="st"> </span>beer2</a>
<a class="sourceLine" id="cb3774-2" data-line-number="2">d &lt;-<span class="st"> </span><span class="kw">dist</span>(<span class="kw">t</span>(beer2))</a></code></pre></div>
<p>Either way gets you to the same place:</p>
<div class="sourceCode" id="cb3775"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3775-1" data-line-number="1">d</a></code></pre></div>
<pre><code>##           AnchorS     Bass    Becks   Corona  GordonB Guinness Heineken
## Bass     15.19868                                                      
## Becks    16.09348 13.63818                                             
## Corona   20.02498 17.83255 17.54993                                    
## GordonB  13.96424 11.57584 14.42221 13.34166                           
## Guinness 14.93318 13.49074 16.85230 20.59126 14.76482                  
## Heineken 20.66398 15.09967 13.78405 14.89966 14.07125 18.54724         
## PetesW   11.78983 14.00000 16.37071 17.72005 11.57584 14.28286 19.49359
## SamAdams 14.62874 11.61895 14.73092 14.93318 10.90871 15.90597 14.52584
## SierraN  12.60952 15.09967 17.94436 16.97056 11.74734 13.34166 19.07878
##            PetesW SamAdams
## Bass                      
## Becks                     
## Corona                    
## GordonB                   
## Guinness                  
## Heineken                  
## PetesW                    
## SamAdams 14.45683         
## SierraN  13.41641 12.12436</code></pre>
<p>There are 10 beers with these names, so this is good.</p>
<ol start="4" style="list-style-type: lower-alpha">
<li>Try to explain briefly why I used <code>as.dist</code> in the
class example (the languages one) but <code>dist</code> here. (Think
about the form of the input to each function.)</li>
</ol>
<p>Solution</p>
<p><code>as.dist</code> is used if you <em>already</em> have
dissimilarities (and you just want to format them right), but
<code>dist</code> is used if you have
<em>data on variables</em> and you want to <em>calculate</em>
dissimilarities.</p>
<ol start="5" style="list-style-type: lower-alpha">
<li><a name="part:beer-dendro">*</a> Obtain a clustering of the beers, using Ward’s method. Show
the dendrogram.</li>
</ol>
<p>Solution</p>
<p>This:</p>
<div class="sourceCode" id="cb3777"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3777-1" data-line-number="1">beer<span class="fl">.1</span> &lt;-<span class="st"> </span><span class="kw">hclust</span>(d, <span class="dt">method =</span> <span class="st">&quot;ward.D&quot;</span>)</a>
<a class="sourceLine" id="cb3777-2" data-line-number="2"><span class="kw">plot</span>(beer<span class="fl">.1</span>)</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/khas-1.png" width="672"  /></p>
<ol start="6" style="list-style-type: lower-alpha">
<li>What seems to be a sensible number of clusters? Which
beers are in which cluster?</li>
</ol>
<p>Solution</p>
<p>This is a judgement call. Almost anything sensible is
reasonable. I personally think that two clusters is good, beers
Anchor Steam, Pete’s Wicked Ale, Guinness and Sierra Nevada in
the first, and Bass, Gordon Biersch, Sam Adams, Corona, Beck’s,
and Heineken in the second.
You could make a case for three clusters, splitting off
Corona, Beck’s and Heineken into their own cluster, or even
about 5 clusters as
Anchor Steam, Pete’s Wicked Ale; Guinness, Sierra Nevada; Bass,
Gordon Biersch, Sam Adams; Corona; Beck’s, Heineken.</p>
<p>The idea is to have a number of clusters sensibly smaller than
the 10 observations, so that you are getting some actual
insight. Having 8 clusters for 10 beers wouldn’t be very
informative! (This is where you use your own knowledge about
beer to help you rationalize your choice of number of clusters.)</p>
<p>Extra: as to why the clusters split up like this, I think the four
beers on the left of my dendrogram are “dark” and the six on
the right are “light” (in colour), and I would expect the
students to tend to like all the beers of one type and not so
much all the beers of the other type.</p>
<p>You knew I would have to investigate this, didn’t you? Let’s aim
for a scatterplot of all the ratings for the dark beers,
against the ones for the light beers.</p>
<p>Start with the data frame read in from the file:</p>
<div class="sourceCode" id="cb3778"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3778-1" data-line-number="1">beer</a></code></pre></div>
<pre><code>## # A tibble: 32 x 11
##    student AnchorS  Bass Becks Corona GordonB Guinness Heineken PetesW
##    &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;
##  1 S001          5     9     7      1       7        6        6      5
##  2 S008          7     5     6      8       8        4        8      8
##  3 S015          7     7     5      6       6        1        8      4
##  4 S022          7     7     5      2       5        8        4      6
##  5 S029          9     7     3      1       6        8        2      7
##  6 S036          7     6     4      3       7        6        6      5
##  7 S043          5     5     5      6       6        4        7      5
##  8 S050          5     3     1      5       5        5        3      5
##  9 S057          9     3     2      6       4        6        1      5
## 10 S064          2     6     6      5       6        4        8      4
## # … with 22 more rows, and 2 more variables: SamAdams &lt;dbl&gt;, SierraN &lt;dbl&gt;</code></pre>
<p>The aim is to find the average rating for a dark beer and a light beer
for each student, and then plot them against each other. Does a
student who likes dark beer tend not to like light beer, and vice versa?</p>
<p>Let’s think about what to do first.</p>
<p>We need to: <code>pivot_longer</code> all the rating columns into one, labelled
by <code>name</code> of beer. Then create a variable that is <code>dark</code>
if we’re looking at one of the dark beers and <code>light</code>
otherwise. <code>ifelse</code> works like “if” in a spreadsheet: a
logical thing that is either true or false, followed by a value if
true and a value if false. There is a nice R command <code>%in%</code>
which is <code>TRUE</code> if the thing in the first variable is to be
found somewhere in the list of things given next (here, one of the
apparently dark beers). (Another way to do this, which will appeal to
you more if you like databases, is to create a second data frame with
two columns, the first being the beer names, and the second being
<code>dark</code> or <code>light</code> as appropriate for that beer. Then you
use a “left join” to look up beer type from beer name.)</p>
<p>Next, group by beer type within student. Giving two things to
<code>group_by</code> does it this way: the second thing within
(or “for each of”) the first.</p>
<p>Then calculate the mean
rating within each group. This gives one column of students, one
column of beer types,
and one column of rating means.</p>
<p>Then we need to <code>pivot_wider</code> beer type
into two columns so that we can make a scatterplot of the mean ratings
for light and dark against
each other.</p>
<p>Finally, we make a scatterplot.</p>
<p>You’ll see the final version of this that worked, but rest assured
that there were many intervening versions of this that didn’t!</p>
<p>I urge you to examine the chain one line at a time and see what each
line does. That was how I debugged it.</p>
<p>Off we go:</p>
<div class="sourceCode" id="cb3780"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3780-1" data-line-number="1">beer <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3780-2" data-line-number="2"><span class="st">  </span><span class="kw">pivot_longer</span>(<span class="op">-</span>student, <span class="dt">names_to=</span><span class="st">&quot;name&quot;</span>, <span class="dt">values_to=</span><span class="st">&quot;rating&quot;</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3780-3" data-line-number="3"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">beer.type =</span> <span class="kw">ifelse</span>(name <span class="op">%in%</span></a>
<a class="sourceLine" id="cb3780-4" data-line-number="4"><span class="st">    </span><span class="kw">c</span>(<span class="st">&quot;AnchorS&quot;</span>, <span class="st">&quot;PetesW&quot;</span>, <span class="st">&quot;Guinness&quot;</span>, <span class="st">&quot;SierraN&quot;</span>), <span class="st">&quot;dark&quot;</span>, <span class="st">&quot;light&quot;</span>)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3780-5" data-line-number="5"><span class="st">  </span><span class="kw">group_by</span>(student, beer.type) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3780-6" data-line-number="6"><span class="st">  </span><span class="kw">summarize</span>(<span class="dt">mean.rat =</span> <span class="kw">mean</span>(rating)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3780-7" data-line-number="7"><span class="st">  </span><span class="kw">pivot_wider</span>(<span class="dt">names_from=</span>beer.type, <span class="dt">values_from=</span>mean.rat) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3780-8" data-line-number="8"><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> dark, <span class="dt">y =</span> light)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>()</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/iyrpoydf-1.png" width="672"  /></p>
<p>After all that work, not really. There are some students who like
light beer but not dark beer (top left), there is a sort of vague
straggle down to the bottom right, where some students like dark beer
but not light beer, but there are definitely students at the top
right, who just like beer!</p>
<p>The only really empty part of this plot is
the bottom left, which says that these students don’t hate both kinds
of beer; they like either dark beer, or light beer, or both.</p>
<p>The reason a <code>ggplot</code> fits into this “workflow” is that the
first thing you feed into <code>ggplot</code> is a data frame, the one
created by the chain here. Because it’s in a pipeline,
you don’t have the
first thing on <code>ggplot</code>, so you can concentrate on the
<code>aes</code> (“what to plot”) and then the “how to plot it”.
Now back to your regularly-scheduled programming.</p>
<ol start="7" style="list-style-type: lower-alpha">
<li>Re-draw your dendrogram with your clusters indicated.</li>
</ol>
<p>Solution</p>
<p><code>rect.hclust</code>, with your chosen number of clusters:</p>
<div class="sourceCode" id="cb3781"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3781-1" data-line-number="1"><span class="kw">plot</span>(beer<span class="fl">.1</span>)</a>
<a class="sourceLine" id="cb3781-2" data-line-number="2"><span class="kw">rect.hclust</span>(beer<span class="fl">.1</span>, <span class="dv">2</span>)</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/sdkjdh-1.png" width="672"  /></p>
<p>Or if you prefer 5 clusters, like this:</p>
<div class="sourceCode" id="cb3782"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3782-1" data-line-number="1"><span class="kw">plot</span>(beer<span class="fl">.1</span>)</a>
<a class="sourceLine" id="cb3782-2" data-line-number="2"><span class="kw">rect.hclust</span>(beer<span class="fl">.1</span>, <span class="dv">5</span>)</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/ljashkjsdah-1.png" width="672"  /></p>
<p>Same idea with any other number of clusters. If you follow through
with your preferred number of clusters from the previous part, I’m good.</p>
<ol start="8" style="list-style-type: lower-alpha">
<li>Obtain a K-means
clustering with 2 clusters.
<label for="tufte-mn-242" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-242" class="margin-toggle"><span class="marginnote">If you haven’t gotten to K-means clustering yet, leave this and save it for later.</span>
Note that you will need to use the (transposed)
<em>original data</em>, not the distances. Use a suitably large value of
<code>nstart</code>. (The data are ratings all on the same scale, so
there is no need for <code>scale</code> here. In case you were
wondering.)</li>
</ol>
<p>Solution</p>
<p>I used 20 for <code>nstart</code>. This is the pipe way:</p>
<div class="sourceCode" id="cb3783"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3783-1" data-line-number="1">beer<span class="fl">.2</span> &lt;-<span class="st"> </span>beer <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3783-2" data-line-number="2"><span class="st">  </span><span class="kw">select</span>(<span class="op">-</span><span class="dv">1</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3783-3" data-line-number="3"><span class="st">  </span><span class="kw">t</span>() <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3783-4" data-line-number="4"><span class="st">  </span><span class="kw">kmeans</span>(<span class="dv">2</span>, <span class="dt">nstart =</span> <span class="dv">20</span>)</a></code></pre></div>
<p>Not everyone (probably) will get the same answer, because of the
random nature of the procedure, but the above code should be good
whatever output it produces.</p>
<ol style="list-style-type: lower-roman">
<li>How many beers are in each cluster?</li>
</ol>
<p>Solution</p>
<p>On mine:</p>
<div class="sourceCode" id="cb3784"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3784-1" data-line-number="1">beer<span class="fl">.2</span><span class="op">$</span>size</a></code></pre></div>
<pre><code>## [1] 4 6</code></pre>
<p>You might get the same numbers the other way around.</p>
<ol start="10" style="list-style-type: lower-alpha">
<li><em>Which</em> beers are in each cluster? You can do this
simply by obtaining the cluster memberships and using
<code>sort</code> as in the last question, or you can do it as I did
in class by obtaining the
names of the things to be clustered and picking out the ones of
them that are in cluster 1, 2, 3, .)</li>
</ol>
<p>Solution</p>
<p>The cluster numbers of each beer are these:</p>
<div class="sourceCode" id="cb3786"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3786-1" data-line-number="1">beer<span class="fl">.2</span><span class="op">$</span>cluster</a></code></pre></div>
<pre><code>##  AnchorS     Bass    Becks   Corona  GordonB Guinness Heineken   PetesW 
##        1        2        2        2        2        1        2        1 
## SamAdams  SierraN 
##        2        1</code></pre>
<p>This is what is known in the business as a “named vector”: it has values (the cluster numbers) and each value has a name attached to it (the name of a beer).</p>
<p>Named vectors are handily turned into a data frame with <code>enframe</code>:</p>
<div class="sourceCode" id="cb3788"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3788-1" data-line-number="1">x &lt;-<span class="st"> </span><span class="kw">enframe</span>(beer<span class="fl">.2</span><span class="op">$</span>cluster)</a>
<a class="sourceLine" id="cb3788-2" data-line-number="2">x</a></code></pre></div>
<pre><code>## # A tibble: 10 x 2
##    name     value
##    &lt;chr&gt;    &lt;int&gt;
##  1 AnchorS      1
##  2 Bass         2
##  3 Becks        2
##  4 Corona       2
##  5 GordonB      2
##  6 Guinness     1
##  7 Heineken     2
##  8 PetesW       1
##  9 SamAdams     2
## 10 SierraN      1</code></pre>
<p>Or, to go back the other way, <code>deframe</code>:</p>
<div class="sourceCode" id="cb3790"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3790-1" data-line-number="1"><span class="kw">deframe</span>(x)</a></code></pre></div>
<pre><code>##  AnchorS     Bass    Becks   Corona  GordonB Guinness Heineken   PetesW 
##        1        2        2        2        2        1        2        1 
## SamAdams  SierraN 
##        2        1</code></pre>
<p>or, give the columns better names and arrange them by cluster:</p>
<div class="sourceCode" id="cb3792"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3792-1" data-line-number="1"><span class="kw">enframe</span>(beer<span class="fl">.2</span><span class="op">$</span>cluster, <span class="dt">name =</span> <span class="st">&quot;beer&quot;</span>, <span class="dt">value =</span> <span class="st">&quot;cluster&quot;</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3792-2" data-line-number="2"><span class="st">  </span><span class="kw">arrange</span>(cluster)</a></code></pre></div>
<pre><code>## # A tibble: 10 x 2
##    beer     cluster
##    &lt;chr&gt;      &lt;int&gt;
##  1 AnchorS        1
##  2 Guinness       1
##  3 PetesW         1
##  4 SierraN        1
##  5 Bass           2
##  6 Becks          2
##  7 Corona         2
##  8 GordonB        2
##  9 Heineken       2
## 10 SamAdams       2</code></pre>
<p>These happen to be the same clusters as in my 2-cluster solution using
Ward’s method.</p>
</div>
<div id="clustering-the-swiss-bills" class="section level2">
<h2><span class="header-section-number">26.5</span> Clustering the Swiss bills</h2>
<p>This question is about the Swiss bank counterfeit bills
again. This time we’re going to ignore whether each bill is
counterfeit or not, and see what groups they break into. Then, at
the end, we’ll see whether cluster analysis was able to pick out the
counterfeit ones or not.</p>
<ol style="list-style-type: lower-alpha">
<li>Read the data in again (just like last time), and look at
the first few rows. This is just the same as before.</li>
</ol>
<p>Solution</p>
<p>The data file was aligned in columns, so:</p>
<div class="sourceCode" id="cb3794"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3794-1" data-line-number="1">my_url &lt;-<span class="st"> &quot;http://www.utsc.utoronto.ca/~butler/d29/swiss1.txt&quot;</span></a>
<a class="sourceLine" id="cb3794-2" data-line-number="2">swiss &lt;-<span class="st"> </span><span class="kw">read_table</span>(my_url)</a></code></pre></div>
<pre><code>## Parsed with column specification:
## cols(
##   length = col_double(),
##   left = col_double(),
##   right = col_double(),
##   bottom = col_double(),
##   top = col_double(),
##   diag = col_double(),
##   status = col_character()
## )</code></pre>
<div class="sourceCode" id="cb3796"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3796-1" data-line-number="1">swiss</a></code></pre></div>
<pre><code>## # A tibble: 200 x 7
##    length  left right bottom   top  diag status 
##     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;  
##  1   215.  131   131.    9     9.7  141  genuine
##  2   215.  130.  130.    8.1   9.5  142. genuine
##  3   215.  130.  130.    8.7   9.6  142. genuine
##  4   215.  130.  130.    7.5  10.4  142  genuine
##  5   215   130.  130.   10.4   7.7  142. genuine
##  6   216.  131.  130.    9    10.1  141. genuine
##  7   216.  130.  130.    7.9   9.6  142. genuine
##  8   214.  130.  129.    7.2  10.7  142. genuine
##  9   215.  129.  130.    8.2  11    142. genuine
## 10   215.  130.  130.    9.2  10    141. genuine
## # … with 190 more rows</code></pre>
<ol start="2" style="list-style-type: lower-alpha">
<li>The variables in this data frame are on different
scales. Standardize them so that they all have mean 0 and standard
deviation 1. (Don’t try to standardize the <code>status</code> column!)</li>
</ol>
<p>Solution</p>
<div class="sourceCode" id="cb3798"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3798-1" data-line-number="1">swiss.s &lt;-<span class="st"> </span>swiss <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3798-2" data-line-number="2"><span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>status) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3798-3" data-line-number="3"><span class="st">  </span><span class="kw">scale</span>()</a></code></pre></div>
<p>What kind of thing do we have?</p>
<div class="sourceCode" id="cb3799"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3799-1" data-line-number="1"><span class="kw">class</span>(swiss.s)</a></code></pre></div>
<pre><code>## [1] &quot;matrix&quot;</code></pre>
<p>so something like this is needed to display some of it (rather than
all of it):</p>
<div class="sourceCode" id="cb3801"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3801-1" data-line-number="1"><span class="kw">head</span>(swiss.s)</a></code></pre></div>
<pre><code>##          length      left      right     bottom        top      diag
## [1,] -0.2549435  2.433346  2.8299417 -0.2890067 -1.1837648 0.4482473
## [2,] -0.7860757 -1.167507 -0.6347880 -0.9120152 -1.4328473 1.0557460
## [3,] -0.2549435 -1.167507 -0.6347880 -0.4966762 -1.3083061 1.4896737
## [4,] -0.2549435 -1.167507 -0.8822687 -1.3273542 -0.3119759 1.3161027
## [5,]  0.2761888 -1.444496 -0.6347880  0.6801176 -3.6745902 1.1425316
## [6,]  2.1351516  1.879368  1.3450576 -0.2890067 -0.6855997 0.7953894</code></pre>
<ol start="3" style="list-style-type: lower-alpha">
<li>We are going to make a scree plot. First, calculate the total
within-cluster SS for each number of clusters from 2 to 10.</li>
</ol>
<p>Solution</p>
<p>When I first made this problem,
I thought the obvious answer was a loop, but now that I’ve been
steeped in the Tidyverse a while, I think <code>map</code> is much
clearer, so I’ll do that first.
Start by making a <code>tibble</code> that has one column called <code>clusters</code> containing the numbers 2 through 10:</p>
<div class="sourceCode" id="cb3803"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3803-1" data-line-number="1"><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">2</span><span class="op">:</span><span class="dv">10</span>)</a></code></pre></div>
<pre><code>## # A tibble: 9 x 1
##   clusters
##      &lt;int&gt;
## 1        2
## 2        3
## 3        4
## 4        5
## 5        6
## 6        7
## 7        8
## 8        9
## 9       10</code></pre>
<p>Now, for each of these numbers of clusters (think <code>map</code>), calculate the total within-cluster sum of squares for <em>it</em> (that number of clusters). To do that, think about how you’d do it for something like three clusters:</p>
<div class="sourceCode" id="cb3805"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3805-1" data-line-number="1"><span class="kw">kmeans</span>(swiss.s, <span class="dv">3</span>, <span class="dt">nstart =</span> <span class="dv">20</span>)<span class="op">$</span>tot.withinss</a></code></pre></div>
<pre><code>## [1] 576.466</code></pre>
<p>and then use that within your <code>map</code>, replacing the 3 with a dot:</p>
<div class="sourceCode" id="cb3807"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3807-1" data-line-number="1"><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">2</span><span class="op">:</span><span class="dv">10</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3807-2" data-line-number="2"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">wss =</span> <span class="kw">map_dbl</span>(clusters, <span class="op">~</span><span class="st"> </span><span class="kw">kmeans</span>(swiss.s, ., <span class="dt">nstart =</span> <span class="dv">20</span>)<span class="op">$</span>tot.withinss)) -&gt;<span class="st"> </span>wssq</a>
<a class="sourceLine" id="cb3807-3" data-line-number="3">wssq</a></code></pre></div>
<pre><code>## # A tibble: 9 x 2
##   clusters   wss
##      &lt;int&gt; &lt;dbl&gt;
## 1        2  701.
## 2        3  576.
## 3        4  492.
## 4        5  449.
## 5        6  413.
## 6        7  383.
## 7        8  355.
## 8        9  334.
## 9       10  313.</code></pre>
<p>Another way is to save <em>all</em> the output from the <code>kmeans</code> and then <em>extract</em> the thing you want, thus:</p>
<div class="sourceCode" id="cb3809"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3809-1" data-line-number="1"><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">2</span><span class="op">:</span><span class="dv">10</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3809-2" data-line-number="2"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">km =</span> <span class="kw">map</span>(clusters, <span class="op">~</span><span class="st"> </span><span class="kw">kmeans</span>(swiss.s, ., <span class="dt">nstart =</span> <span class="dv">20</span>))) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3809-3" data-line-number="3"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">wss =</span> <span class="kw">map_dbl</span>(km, <span class="st">&quot;tot.withinss&quot;</span>)) -&gt;<span class="st"> </span>wssq<span class="fl">.2</span></a>
<a class="sourceLine" id="cb3809-4" data-line-number="4">wssq<span class="fl">.2</span></a></code></pre></div>
<pre><code>## # A tibble: 9 x 3
##   clusters km         wss
##      &lt;int&gt; &lt;list&gt;   &lt;dbl&gt;
## 1        2 &lt;kmeans&gt;  701.
## 2        3 &lt;kmeans&gt;  576.
## 3        4 &lt;kmeans&gt;  492.
## 4        5 &lt;kmeans&gt;  449.
## 5        6 &lt;kmeans&gt;  413.
## 6        7 &lt;kmeans&gt;  382.
## 7        8 &lt;kmeans&gt;  355.
## 8        9 &lt;kmeans&gt;  334.
## 9       10 &lt;kmeans&gt;  313.</code></pre>
<p>The first one here is a <code>map</code> since it gets the <em>whole</em>
<code>kmeans</code> output; the second one is a <code>map_dbl</code> since it
pulls just one number out of that output. (I somehow got this the
wrong way around the first time. I think I copied and pasted and
didn’t check that I had changed what I needed to change.)</p>
<p>We now have an extra list-column containing everything from each
K-means fit, which means we can extract the output from here for the number of
clusters we eventually choose, rather than running <code>kmeans</code> again.
If you prefer, do it as a loop, like this:</p>
<div class="sourceCode" id="cb3811"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3811-1" data-line-number="1">clus &lt;-<span class="st"> </span><span class="dv">2</span><span class="op">:</span><span class="dv">10</span></a>
<a class="sourceLine" id="cb3811-2" data-line-number="2">wss<span class="fl">.1</span> &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb3811-3" data-line-number="3"><span class="cf">for</span> (i <span class="cf">in</span> clus)</a>
<a class="sourceLine" id="cb3811-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb3811-5" data-line-number="5">  wss<span class="fl">.1</span>[i] &lt;-<span class="st"> </span><span class="kw">kmeans</span>(swiss.s, i, <span class="dt">nstart =</span> <span class="dv">20</span>)<span class="op">$</span>tot.withinss</a>
<a class="sourceLine" id="cb3811-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb3811-7" data-line-number="7">wss<span class="fl">.1</span></a></code></pre></div>
<pre><code>##  [1]       NA 701.2054 576.4660 491.7085 449.3900 412.9139 381.3926
##  [8] 355.3168 333.5024 313.2374</code></pre>
<p>Note that there are 10 <code>wss</code> values, but the first one is
missing, since we didn’t do one cluster.
<label for="tufte-mn-243" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-243" class="margin-toggle"><span class="marginnote">R vectors start from 1, unlike C arrays or Python lists, which start from 0.</span></p>
<p>The <code>numeric(0)</code> says “<code>wss</code> has nothing in it, but if it had anything, it would be numbers”. Or, you can initialize
<code>wss</code> to however long it’s going to be (here 10), which is
actually more efficient (R doesn’t have to keep making it
“a bit longer”). If you initialize it to length 10, the 10 values will have
<code>NA</code>s in them when you start.
It doesn’t matter what <code>nstart</code> is: Ideally, big enough to have a decent
chance of finding the best clustering, but small enough that it
doesn’t take too long to run.
Whichever way you create your total within-cluster sums of squares, you can use it to make a scree plot (next part).</p>
<ol start="4" style="list-style-type: lower-alpha">
<li><a name="part:howmany">*</a> Make a scree plot (creating a data frame
first if you need). How many clusters do you think you
should use?</li>
</ol>
<p>Solution</p>
<p>The easiest is to use the output from the <code>map_dbl</code>,
which I called <code>wssq</code>:</p>
<div class="sourceCode" id="cb3813"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3813-1" data-line-number="1"><span class="kw">ggplot</span>(wssq, <span class="kw">aes</span>(<span class="dt">x =</span> clusters, <span class="dt">y =</span> wss)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>()</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/unnamed-chunk-89-1.png" width="672"  /></p>
<p>If you did it the loop way, you’ll have to make a data frame
first, which you can then pipe into <code>ggplot</code>:</p>
<div class="sourceCode" id="cb3814"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3814-1" data-line-number="1"><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">wss =</span> wss<span class="fl">.1</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3814-2" data-line-number="2"><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> clusters, <span class="dt">y =</span> wss)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>()</a></code></pre></div>
<pre><code>## Warning: Removed 1 rows containing missing values (geom_point).</code></pre>
<pre><code>## Warning: Removed 1 rows containing missing values (geom_path).</code></pre>
<p><img src="22-thingy_files/figure-html/sasjhgajs-1.png" width="576"  /></p>
<p>If you started at 2 clusters, your <code>wss</code> will start at 2
clusters also, and you’ll need to be careful to have something like
<code>clusters=2:10</code> (not <code>1:10</code>) in the definition of your
data frame.</p>
<p>Interpretation: I see a small elbow at 4 clusters, so that’s how many I think we
should use. Any place you can reasonably see an elbow is good.</p>
<p>The warning is about the missing within-cluster total sum of squares
for one cluster, since the loop way didn’t supply a total
within-cluster sum of squares for one cluster.</p>
<ol start="5" style="list-style-type: lower-alpha">
<li>Run K-means with the number of clusters that you found in
(<a href="#part:howmany">here</a>). How many bills are in each cluster?</li>
</ol>
<p>Solution</p>
<p>I’m going to start by setting the random number seed (so that
my results don’t change every time I run this). You don’t need
to do that, though you might want to in something like R
Markdown code (for example, in an R Notebook):</p>
<div class="sourceCode" id="cb3817"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3817-1" data-line-number="1"><span class="kw">set.seed</span>(<span class="dv">457299</span>)</a></code></pre></div>
<p>Now, down to business:</p>
<div class="sourceCode" id="cb3818"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3818-1" data-line-number="1">swiss<span class="fl">.7</span> &lt;-<span class="st"> </span><span class="kw">kmeans</span>(swiss.s, <span class="dv">4</span>, <span class="dt">nstart =</span> <span class="dv">20</span>)</a>
<a class="sourceLine" id="cb3818-2" data-line-number="2">swiss<span class="fl">.7</span><span class="op">$</span>size</a></code></pre></div>
<pre><code>## [1] 50 32 68 50</code></pre>
<p>This many. Note that my clusters 1 and 4 (and also 2 and 3) add up to
100 bills. There were 100 genuine and 100 counterfeit bills in the
original data set.
I don’t know why “7”. I just felt like it.
Extra: you might remember that back before I actually <em>ran</em>
K-means on each of the numbers of clusters from 2 to 10. How can we
extract that output? Something like this. Here’s where the output was:</p>
<div class="sourceCode" id="cb3820"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3820-1" data-line-number="1">wssq<span class="fl">.2</span></a></code></pre></div>
<pre><code>## # A tibble: 9 x 3
##   clusters km         wss
##      &lt;int&gt; &lt;list&gt;   &lt;dbl&gt;
## 1        2 &lt;kmeans&gt;  701.
## 2        3 &lt;kmeans&gt;  576.
## 3        4 &lt;kmeans&gt;  492.
## 4        5 &lt;kmeans&gt;  449.
## 5        6 &lt;kmeans&gt;  413.
## 6        7 &lt;kmeans&gt;  382.
## 7        8 &lt;kmeans&gt;  355.
## 8        9 &lt;kmeans&gt;  334.
## 9       10 &lt;kmeans&gt;  313.</code></pre>
<p>Now we need to pull out the 4th row and the <code>km</code> column. We need the output as an actual thing, not a data frame, so:</p>
<div class="sourceCode" id="cb3822"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3822-1" data-line-number="1">wssq<span class="fl">.2</span> <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3822-2" data-line-number="2"><span class="st">  </span><span class="kw">filter</span>(clusters <span class="op">==</span><span class="st"> </span><span class="dv">4</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3822-3" data-line-number="3"><span class="st">  </span><span class="kw">pull</span>(km) -&gt;<span class="st"> </span>swiss<span class="fl">.7</span>a</a></code></pre></div>
<p>Is that the right thing?</p>
<div class="sourceCode" id="cb3823"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3823-1" data-line-number="1">swiss<span class="fl">.7</span>a</a></code></pre></div>
<pre><code>## [[1]]
## K-means clustering with 4 clusters of sizes 50, 50, 68, 32
## 
## Cluster means:
##       length       left      right     bottom         top       diag
## 1 -0.5683115  0.2617543  0.3254371  1.3197396  0.04670298 -0.8483286
## 2  0.1062264  0.6993965  0.8352473  0.1927865  1.18251937 -0.9316427
## 3 -0.2002681 -1.0290130 -0.9878119 -0.8397381 -0.71307204  0.9434354
## 4  1.1475776  0.6848546  0.2855308 -0.5788787 -0.40538184  0.7764051
## 
## Clustering vector:
##   [1] 4 3 3 3 3 4 3 3 3 4 4 3 4 3 3 3 3 3 3 3 3 4 4 4 3 4 4 4 4 3 4 3 3 4 4
##  [36] 4 4 3 4 3 3 3 3 4 3 3 3 3 3 3 3 4 3 4 3 3 4 3 4 3 3 3 3 3 3 4 3 3 3 2
##  [71] 3 3 3 3 3 3 3 3 4 3 3 3 3 4 4 3 3 3 4 3 3 4 3 3 3 4 4 3 3 3 2 2 2 2 1
## [106] 1 2 2 2 2 2 2 2 1 1 2 1 1 1 2 2 1 2 2 1 2 2 2 2 2 1 1 2 2 1 1 1 2 1 1
## [141] 2 1 1 2 1 1 1 2 1 2 1 1 1 1 1 1 1 1 1 2 2 1 1 1 1 2 4 2 2 1 2 1 1 1 1
## [176] 1 1 2 2 2 1 2 2 2 1 1 2 1 2 1 2 2 1 2 1 2 2 2 2 1
## 
## Within cluster sum of squares by cluster:
## [1]  95.51948 137.68573 166.12573  92.37757
##  (between_SS / total_SS =  58.8 %)
## 
## Available components:
## 
## [1] &quot;cluster&quot;      &quot;centers&quot;      &quot;totss&quot;        &quot;withinss&quot;    
## [5] &quot;tot.withinss&quot; &quot;betweenss&quot;    &quot;size&quot;         &quot;iter&quot;        
## [9] &quot;ifault&quot;</code></pre>
<p>Looks like it. But I should check:</p>
<div class="sourceCode" id="cb3825"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3825-1" data-line-number="1">swiss<span class="fl">.7</span>a<span class="op">$</span>centers</a></code></pre></div>
<pre><code>## NULL</code></pre>
<p>Ah. <code>swiss.7a</code> is actually a <code>list</code>, as evidenced by the <code>[[1]]</code> at the top of the output, so I get things from it thus:</p>
<div class="sourceCode" id="cb3827"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3827-1" data-line-number="1">swiss<span class="fl">.7</span>a[[<span class="dv">1</span>]]<span class="op">$</span>centers</a></code></pre></div>
<pre><code>##       length       left      right     bottom         top       diag
## 1 -0.5683115  0.2617543  0.3254371  1.3197396  0.04670298 -0.8483286
## 2  0.1062264  0.6993965  0.8352473  0.1927865  1.18251937 -0.9316427
## 3 -0.2002681 -1.0290130 -0.9878119 -0.8397381 -0.71307204  0.9434354
## 4  1.1475776  0.6848546  0.2855308 -0.5788787 -0.40538184  0.7764051</code></pre>
<p>This would be because it came from a list-column; using <code>pull</code> removed the data-frameness from <code>swiss.7a</code>, but not its listness.</p>
<ol start="6" style="list-style-type: lower-alpha">
<li>Make a table showing cluster membership against actual
status (counterfeit or genuine). Are the counterfeit bills mostly
in certain clusters?</li>
</ol>
<p>Solution</p>
<p><code>table</code>. <code>swiss.7$cluster</code> shows the actual
cluster numbers:</p>
<div class="sourceCode" id="cb3829"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3829-1" data-line-number="1"><span class="kw">table</span>(swiss<span class="op">$</span>status, swiss<span class="fl">.7</span><span class="op">$</span>cluster)</a></code></pre></div>
<pre><code>##              
##                1  2  3  4
##   counterfeit 50  1  0 49
##   genuine      0 31 68  1</code></pre>
<p>Or, if you prefer,</p>
<div class="sourceCode" id="cb3831"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3831-1" data-line-number="1"><span class="kw">tibble</span>(<span class="dt">obs =</span> swiss<span class="op">$</span>status, <span class="dt">pred =</span> swiss<span class="fl">.7</span><span class="op">$</span>cluster) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3831-2" data-line-number="2"><span class="st">  </span><span class="kw">count</span>(obs, pred)</a></code></pre></div>
<pre><code>## # A tibble: 6 x 3
##   obs          pred     n
##   &lt;chr&gt;       &lt;int&gt; &lt;int&gt;
## 1 counterfeit     1    50
## 2 counterfeit     2     1
## 3 counterfeit     4    49
## 4 genuine         2    31
## 5 genuine         3    68
## 6 genuine         4     1</code></pre>
<p>or even</p>
<div class="sourceCode" id="cb3833"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3833-1" data-line-number="1"><span class="kw">tibble</span>(<span class="dt">obs =</span> swiss<span class="op">$</span>status, <span class="dt">pred =</span> swiss<span class="fl">.7</span><span class="op">$</span>cluster) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3833-2" data-line-number="2"><span class="st">  </span><span class="kw">count</span>(obs, pred) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3833-3" data-line-number="3"><span class="st">  </span><span class="kw">spread</span>(pred, n, <span class="dt">fill =</span> <span class="dv">0</span>)</a></code></pre></div>
<pre><code>## # A tibble: 2 x 5
##   obs           `1`   `2`   `3`   `4`
##   &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 counterfeit    50     1     0    49
## 2 genuine         0    31    68     1</code></pre>
<p>In my case (yours might be different), 99 of the 100 counterfeit bills
are in clusters 1 and 4, and 99 of the 100 genuine bills are in
clusters 2 and 3.
<label for="tufte-mn-244" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-244" class="margin-toggle"><span class="marginnote">This is again where <em>set.seed</em> is valuable: write this text once and it never needs to change.</span> So the
clustering has done a very good job of distinguishing the genuine
bills from the counterfeit ones. (You could imagine, if you were an
employee at the bank, saying that a bill in cluster 1 or 4 is
counterfeit, and being right 99% of the time.) This is kind of a
by-product of the clustering, though: we weren’t <em>trying</em> to
distinguish counterfeit bills (that would have been the discriminant
analysis that we did before); we were just trying to divide them into
groups of different ones, and part of what made them different was
that some of them were genuine bills and some of them were
counterfeit.</p>
</div>
<div id="grouping-similar-cars" class="section level2">
<h2><span class="header-section-number">26.6</span> Grouping similar cars</h2>
<p>The file
<a href="http://www.utsc.utoronto.ca/~butler/d29/car-cluster.csv">link</a> contains
information on seven variables
for 32 different cars. The variables are:</p>
<ul>
<li><p><code>Carname</code>: name of the car (duh!)</p></li>
<li><p><code>mpg</code>: gas consumption in miles per US gallon (higher means the car uses less gas)</p></li>
<li><p><code>disp</code>: engine displacement (total volume of cylinders in engine): higher is more powerful</p></li>
<li><p><code>hp</code>: engine horsepower (higher means a more powerful engine)</p></li>
<li><p><code>drat</code>: rear axle ratio (higher means more powerful but worse gas mileage)</p></li>
<li><p><code>wt</code>: car weight in US tons</p></li>
<li><p><code>qsec</code>: time needed for the car to cover a quarter mile (lower means faster)</p></li>
</ul>
<ol style="list-style-type: lower-alpha">
<li>Read in the data and display its structure. Do you have the
right number of cars and variables?</li>
</ol>
<div class="sourceCode" id="cb3835"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3835-1" data-line-number="1">my_url &lt;-<span class="st"> &quot;http://www.utsc.utoronto.ca/~butler/d29/car-cluster.csv&quot;</span></a>
<a class="sourceLine" id="cb3835-2" data-line-number="2">cars &lt;-<span class="st"> </span><span class="kw">read_csv</span>(my_url)</a></code></pre></div>
<pre><code>## Parsed with column specification:
## cols(
##   Carname = col_character(),
##   mpg = col_double(),
##   disp = col_double(),
##   hp = col_double(),
##   drat = col_double(),
##   wt = col_double(),
##   qsec = col_double()
## )</code></pre>
<div class="sourceCode" id="cb3837"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3837-1" data-line-number="1">cars</a></code></pre></div>
<pre><code>## # A tibble: 32 x 7
##    Carname             mpg  disp    hp  drat    wt  qsec
##    &lt;chr&gt;             &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 Mazda RX4          21    160    110  3.9   2.62  16.5
##  2 Mazda RX4 Wag      21    160    110  3.9   2.88  17.0
##  3 Datsun 710         22.8  108     93  3.85  2.32  18.6
##  4 Hornet 4 Drive     21.4  258    110  3.08  3.22  19.4
##  5 Hornet Sportabout  18.7  360    175  3.15  3.44  17.0
##  6 Valiant            18.1  225    105  2.76  3.46  20.2
##  7 Duster 360         14.3  360    245  3.21  3.57  15.8
##  8 Merc 240D          24.4  147.    62  3.69  3.19  20  
##  9 Merc 230           22.8  141.    95  3.92  3.15  22.9
## 10 Merc 280           19.2  168.   123  3.92  3.44  18.3
## # … with 22 more rows</code></pre>
<p>Check, both on number of cars and number of variables.</p>
<ol start="2" style="list-style-type: lower-alpha">
<li>The variables are all measured on different scales. Use
<code>scale</code> to produce a matrix of standardized (<span class="math inline">\(z\)</span>-score) values
for the columns of your data that are numbers.</li>
</ol>
<p>Solution</p>
<p>All but the first column needs to be scaled, so:</p>
<div class="sourceCode" id="cb3839"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3839-1" data-line-number="1">cars <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(<span class="op">-</span>Carname) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">scale</span>() -&gt;<span class="st"> </span>cars.s</a></code></pre></div>
<p>This is a <code>matrix</code>, as we’ve seen before.</p>
<p>Another way is like this:</p>
<div class="sourceCode" id="cb3840"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3840-1" data-line-number="1">cars <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select_if</span>(is.numeric) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">scale</span>() -&gt;<span class="st"> </span>h</a></code></pre></div>
<p>I would prefer to have a look at my result, so that I can see that it
has sane things in it:</p>
<div class="sourceCode" id="cb3841"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3841-1" data-line-number="1"><span class="kw">head</span>(cars.s)</a></code></pre></div>
<pre><code>##             mpg        disp         hp       drat           wt       qsec
## [1,]  0.1508848 -0.57061982 -0.5350928  0.5675137 -0.610399567 -0.7771651
## [2,]  0.1508848 -0.57061982 -0.5350928  0.5675137 -0.349785269 -0.4637808
## [3,]  0.4495434 -0.99018209 -0.7830405  0.4739996 -0.917004624  0.4260068
## [4,]  0.2172534  0.22009369 -0.5350928 -0.9661175 -0.002299538  0.8904872
## [5,] -0.2307345  1.04308123  0.4129422 -0.8351978  0.227654255 -0.4637808
## [6,] -0.3302874 -0.04616698 -0.6080186 -1.5646078  0.248094592  1.3269868</code></pre>
<p>or,</p>
<div class="sourceCode" id="cb3843"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3843-1" data-line-number="1"><span class="kw">head</span>(h)</a></code></pre></div>
<pre><code>##             mpg        disp         hp       drat           wt       qsec
## [1,]  0.1508848 -0.57061982 -0.5350928  0.5675137 -0.610399567 -0.7771651
## [2,]  0.1508848 -0.57061982 -0.5350928  0.5675137 -0.349785269 -0.4637808
## [3,]  0.4495434 -0.99018209 -0.7830405  0.4739996 -0.917004624  0.4260068
## [4,]  0.2172534  0.22009369 -0.5350928 -0.9661175 -0.002299538  0.8904872
## [5,] -0.2307345  1.04308123  0.4129422 -0.8351978  0.227654255 -0.4637808
## [6,] -0.3302874 -0.04616698 -0.6080186 -1.5646078  0.248094592  1.3269868</code></pre>
<p>These look right. Or, perhaps better, this:</p>
<div class="sourceCode" id="cb3845"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3845-1" data-line-number="1"><span class="kw">summary</span>(cars.s)</a></code></pre></div>
<pre><code>##       mpg               disp               hp               drat        
##  Min.   :-1.6079   Min.   :-1.2879   Min.   :-1.3810   Min.   :-1.5646  
##  1st Qu.:-0.7741   1st Qu.:-0.8867   1st Qu.:-0.7320   1st Qu.:-0.9661  
##  Median :-0.1478   Median :-0.2777   Median :-0.3455   Median : 0.1841  
##  Mean   : 0.0000   Mean   : 0.0000   Mean   : 0.0000   Mean   : 0.0000  
##  3rd Qu.: 0.4495   3rd Qu.: 0.7688   3rd Qu.: 0.4859   3rd Qu.: 0.6049  
##  Max.   : 2.2913   Max.   : 1.9468   Max.   : 2.7466   Max.   : 2.4939  
##        wt               qsec         
##  Min.   :-1.7418   Min.   :-1.87401  
##  1st Qu.:-0.6500   1st Qu.:-0.53513  
##  Median : 0.1101   Median :-0.07765  
##  Mean   : 0.0000   Mean   : 0.00000  
##  3rd Qu.: 0.4014   3rd Qu.: 0.58830  
##  Max.   : 2.2553   Max.   : 2.82675</code></pre>
<p>The mean is exactly zero, for all variables, which is as it should
be. Also, the standardized values look about as they should; even the
extreme ones don’t go beyond <span class="math inline">\(\pm 3\)</span>.</p>
<p>This doesn’t show the standard deviation of each variable, though,
which should be exactly 1 (since that’s what “standardizing”
means). To get <em>that</em>, <em>this</em>:</p>
<div class="sourceCode" id="cb3847"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3847-1" data-line-number="1"><span class="kw">as_tibble</span>(cars.s) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3847-2" data-line-number="2"><span class="st">  </span><span class="kw">summarize_all</span>(<span class="op">~</span><span class="st"> </span><span class="kw">sd</span>(.))</a></code></pre></div>
<pre><code>## # A tibble: 1 x 6
##     mpg  disp    hp  drat    wt  qsec
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1    1.     1     1     1     1</code></pre>
<p>The idea here is “take the matrix <code>cars.s</code>, turn it into a data frame, and for each <em>column</em>, calculate the SD of it”.
<label for="tufte-mn-245" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-245" class="margin-toggle"><span class="marginnote">The <em>scale</em> function can take a data frame, as here, but always produces a matrix. That’s why we had to turn it back into a data frame.</span></p>
<p>As you realize now, the same idea will get the mean of each column too:</p>
<div class="sourceCode" id="cb3849"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3849-1" data-line-number="1"><span class="kw">as_tibble</span>(cars.s) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3849-2" data-line-number="2"><span class="st">  </span><span class="kw">summarize_all</span>(<span class="op">~</span><span class="st"> </span><span class="kw">mean</span>(.))</a></code></pre></div>
<pre><code>## # A tibble: 1 x 6
##        mpg      disp       hp      drat       wt     qsec
##      &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;
## 1 7.11e-17 -9.08e-17 1.04e-17 -2.92e-16 4.68e-17 5.30e-16</code></pre>
<p>and we see that the means are all zero, to about 15 decimals, anyway.</p>
<ol start="3" style="list-style-type: lower-alpha">
<li>Run a K-means cluster analysis for these data, obtaining 3
clusters, and display the results. Take whatever action you need to
obtain the best (random) result from a number of runs.</li>
</ol>
<p>Solution</p>
<p>The hint at the end says “use <code>nstart</code>”, so something like this:</p>
<div class="sourceCode" id="cb3851"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3851-1" data-line-number="1"><span class="kw">set.seed</span>(<span class="dv">457299</span>)</a>
<a class="sourceLine" id="cb3851-2" data-line-number="2">cars<span class="fl">.1</span> &lt;-<span class="st"> </span><span class="kw">kmeans</span>(cars.s, <span class="dv">3</span>, <span class="dt">nstart =</span> <span class="dv">20</span>)</a>
<a class="sourceLine" id="cb3851-3" data-line-number="3">cars<span class="fl">.1</span></a></code></pre></div>
<pre><code>## K-means clustering with 3 clusters of sizes 6, 14, 12
## 
## Cluster means:
##          mpg       disp         hp       drat         wt       qsec
## 1  1.6552394 -1.1624447 -1.0382807  1.2252295 -1.3738462  0.3075550
## 2 -0.8280518  0.9874085  0.9119628 -0.6869112  0.7991807 -0.6024854
## 3  0.1384407 -0.5707543 -0.5448163  0.1887816 -0.2454544  0.5491221
## 
## Clustering vector:
##  [1] 3 3 3 3 2 3 2 3 3 3 3 2 2 2 2 2 2 1 1 1 3 2 2 2 2 1 1 1 2 3 2 3
## 
## Within cluster sum of squares by cluster:
## [1]  7.76019 33.37849 24.95528
##  (between_SS / total_SS =  64.5 %)
## 
## Available components:
## 
## [1] &quot;cluster&quot;      &quot;centers&quot;      &quot;totss&quot;        &quot;withinss&quot;    
## [5] &quot;tot.withinss&quot; &quot;betweenss&quot;    &quot;size&quot;         &quot;iter&quot;        
## [9] &quot;ifault&quot;</code></pre>
<p>You don’t need the <code>set.seed</code>, but if you run again, you’ll get
a different answer. With the <code>nstart</code>, you’ll probably get the
same clustering every time you run, but the clusters might have
different numbers, so that when you talk about “cluster 1” and then
re-run, what you were talking about might have moved to cluster 3, say.</p>
<p>If you are using R Markdown, for this reason, having a
<code>set.seed</code> before anything involving random number generation
is a smart move.
<label for="tufte-mn-246" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-246" class="margin-toggle"><span class="marginnote">I forgot this, and then realized that I would have to rewrite a whole paragraph. In case you think I remember everything the first time.</span></p>
<ol start="4" style="list-style-type: lower-alpha">
<li>Display the car names together with which cluster they are
in. If you display them all at once, sort by cluster so that it’s
easier to see which clusters contain which cars. (You may have to make
a data frame first.)</li>
</ol>
<p>Solution</p>
<p>As below. The car names are in the <code>Carname</code> column of the
original <code>cars</code> data frame, and the cluster numbers are in
the <code>cluster</code> part of the output from <code>kmeans</code>. You’ll
need to take some action to display everything (there are only 32
cars, so it’s perfectly all right to display all of them):</p>
<div class="sourceCode" id="cb3853"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3853-1" data-line-number="1"><span class="kw">tibble</span>(<span class="dt">car =</span> cars<span class="op">$</span>Carname, <span class="dt">cluster =</span> cars<span class="fl">.1</span><span class="op">$</span>cluster) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3853-2" data-line-number="2"><span class="st">  </span><span class="kw">arrange</span>(cluster) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3853-3" data-line-number="3"><span class="st">  </span><span class="kw">print</span>(<span class="dt">n =</span> <span class="ot">Inf</span>)</a></code></pre></div>
<pre><code>## # A tibble: 32 x 2
##    car                 cluster
##    &lt;chr&gt;                 &lt;int&gt;
##  1 Fiat 128                  1
##  2 Honda Civic               1
##  3 Toyota Corolla            1
##  4 Fiat X1-9                 1
##  5 Porsche 914-2             1
##  6 Lotus Europa              1
##  7 Hornet Sportabout         2
##  8 Duster 360                2
##  9 Merc 450SE                2
## 10 Merc 450SL                2
## 11 Merc 450SLC               2
## 12 Cadillac Fleetwood        2
## 13 Lincoln Continental       2
## 14 Chrysler Imperial         2
## 15 Dodge Challenger          2
## 16 AMC Javelin               2
## 17 Camaro Z28                2
## 18 Pontiac Firebird          2
## 19 Ford Pantera L            2
## 20 Maserati Bora             2
## 21 Mazda RX4                 3
## 22 Mazda RX4 Wag             3
## 23 Datsun 710                3
## 24 Hornet 4 Drive            3
## 25 Valiant                   3
## 26 Merc 240D                 3
## 27 Merc 230                  3
## 28 Merc 280                  3
## 29 Merc 280C                 3
## 30 Toyota Corona             3
## 31 Ferrari Dino              3
## 32 Volvo 142E                3</code></pre>
<p>Or start from the original data frame as read in from the file and
grab only what you want:</p>
<div class="sourceCode" id="cb3855"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3855-1" data-line-number="1">cars <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3855-2" data-line-number="2"><span class="st">  </span><span class="kw">select</span>(Carname) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3855-3" data-line-number="3"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">cluster =</span> cars<span class="fl">.1</span><span class="op">$</span>cluster) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3855-4" data-line-number="4"><span class="st">  </span><span class="kw">arrange</span>(cluster) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3855-5" data-line-number="5"><span class="st">  </span><span class="kw">print</span>(<span class="dt">n =</span> <span class="ot">Inf</span>)</a></code></pre></div>
<pre><code>## # A tibble: 32 x 2
##    Carname             cluster
##    &lt;chr&gt;                 &lt;int&gt;
##  1 Fiat 128                  1
##  2 Honda Civic               1
##  3 Toyota Corolla            1
##  4 Fiat X1-9                 1
##  5 Porsche 914-2             1
##  6 Lotus Europa              1
##  7 Hornet Sportabout         2
##  8 Duster 360                2
##  9 Merc 450SE                2
## 10 Merc 450SL                2
## 11 Merc 450SLC               2
## 12 Cadillac Fleetwood        2
## 13 Lincoln Continental       2
## 14 Chrysler Imperial         2
## 15 Dodge Challenger          2
## 16 AMC Javelin               2
## 17 Camaro Z28                2
## 18 Pontiac Firebird          2
## 19 Ford Pantera L            2
## 20 Maserati Bora             2
## 21 Mazda RX4                 3
## 22 Mazda RX4 Wag             3
## 23 Datsun 710                3
## 24 Hornet 4 Drive            3
## 25 Valiant                   3
## 26 Merc 240D                 3
## 27 Merc 230                  3
## 28 Merc 280                  3
## 29 Merc 280C                 3
## 30 Toyota Corona             3
## 31 Ferrari Dino              3
## 32 Volvo 142E                3</code></pre>
<p>This time we want to <em>keep</em> the car names and throw away
everything else.</p>
<ol start="5" style="list-style-type: lower-alpha">
<li>I have no idea whether 3 is a sensible number of clusters. To
find out, we will draw a scree plot (in a moment). Write a function
that accepts the number of clusters and the (scaled) data,
and returns the total within-cluster sum of squares.</li>
</ol>
<p>Solution</p>
<p>I failed to guess (in conversation with students, back when this was
a question to be handed in) what you might
do. There are two equally good ways to tackle this part and the next:</p>
<ul>
<li><p>Write a function to calculate the total within-cluster sum
of squares (in this part) and somehow use it in the next part,
eg. via <code>map_dbl</code> or a loop, to get the total
within-cluster sum of squares for <em>each</em> number of clusters.</p></li>
<li><p>Skip the function-writing part and go directly to a loop in
the next part.</p></li>
</ul>
<p>I’m good with either approach: as long as you obtain, somehow, the
total within-cluster sum of squares for each number of clusters, and
use them for making a scree plot, I think you should get the
points for this part and the next.
I’ll talk about the function way here and the loop way in the next part.</p>
<p>The function way is just like the one in the previous question:</p>
<div class="sourceCode" id="cb3857"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3857-1" data-line-number="1">wss &lt;-<span class="st"> </span><span class="cf">function</span>(howmany, data, <span class="dt">nstart =</span> <span class="dv">20</span>) {</a>
<a class="sourceLine" id="cb3857-2" data-line-number="2">  <span class="kw">kmeans</span>(data, howmany, <span class="dt">nstart =</span> <span class="dv">20</span>)<span class="op">$</span>tot.withinss</a>
<a class="sourceLine" id="cb3857-3" data-line-number="3">}</a></code></pre></div>
<p>The data and number of clusters can have any names, as long as you use
whatever input names you chose within the function.</p>
<p>I should probably check that this works, at least on 3
clusters. Before we had</p>
<div class="sourceCode" id="cb3858"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3858-1" data-line-number="1">cars<span class="fl">.1</span><span class="op">$</span>tot.withinss</a></code></pre></div>
<pre><code>## [1] 66.09396</code></pre>
<p>and the function gives</p>
<div class="sourceCode" id="cb3860"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3860-1" data-line-number="1"><span class="kw">wss</span>(<span class="dv">3</span>, cars.s)</a></code></pre></div>
<pre><code>## [1] 66.09396</code></pre>
<p>Check.
I need to make sure that I used my scaled <code>cars</code> data, but I
don’t need to say anything about <code>nstart</code>, since that defaults
to the perfectly suitable 20.</p>
<ol start="6" style="list-style-type: lower-alpha">
<li>Calculate the total within-group sum of squares for each
number of clusters from 2 to 10, using the function you just wrote.</li>
</ol>
<p>Solution</p>
<p>The loop way. I like to define my possible numbers of clusters into
a vector first:</p>
<div class="sourceCode" id="cb3862"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3862-1" data-line-number="1">w &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb3862-2" data-line-number="2">nclus &lt;-<span class="st"> </span><span class="dv">2</span><span class="op">:</span><span class="dv">10</span></a>
<a class="sourceLine" id="cb3862-3" data-line-number="3"><span class="cf">for</span> (i <span class="cf">in</span> nclus) {</a>
<a class="sourceLine" id="cb3862-4" data-line-number="4">  w[i] &lt;-<span class="st"> </span><span class="kw">wss</span>(i, cars.s)</a>
<a class="sourceLine" id="cb3862-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb3862-6" data-line-number="6">w</a></code></pre></div>
<pre><code>##  [1]       NA 87.29448 66.09396 50.94273 38.22004 29.28816 24.23138
##  [8] 20.76061 17.58753 15.19850</code></pre>
<p>Now that I look at this again, it occurs to me that there is no great
need to write a function to do this: you can just do what you need to
do within the loop, like this:</p>
<div class="sourceCode" id="cb3864"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3864-1" data-line-number="1">w &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb3864-2" data-line-number="2">nclus &lt;-<span class="st"> </span><span class="dv">2</span><span class="op">:</span><span class="dv">10</span></a>
<a class="sourceLine" id="cb3864-3" data-line-number="3"><span class="cf">for</span> (i <span class="cf">in</span> nclus) {</a>
<a class="sourceLine" id="cb3864-4" data-line-number="4">  w[i] &lt;-<span class="st"> </span><span class="kw">kmeans</span>(cars.s, i, <span class="dt">nstart =</span> <span class="dv">20</span>)<span class="op">$</span>tot.withinss</a>
<a class="sourceLine" id="cb3864-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb3864-6" data-line-number="6">w</a></code></pre></div>
<pre><code>##  [1]       NA 87.29448 66.09396 50.94273 38.22004 29.28816 24.23138
##  [8] 20.76061 18.22591 15.51232</code></pre>
<p>You ought to have an <code>nstart</code> somewhere to make sure that
<code>kmeans</code> gets run a number of times and the best result taken.</p>
<p>If you initialize your <code>w</code> with <code>numeric(10)</code> rather
than <code>numeric(0)</code>, it apparently gets filled with zeroes rather
than <code>NA</code> values. This means, later, when you come to plot your
<code>w</code>-values, the within-cluster total sum of squares will appear
to be zero, a legitimate value, for one cluster, even though it is
definitely not. (Or, I suppose, you could start your loop at 1
cluster, and get a legitimate, though very big, value for it.)
In both of the above cases, the curly brackets are optional because
there is only one line within the loop.
<label for="tufte-mn-247" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-247" class="margin-toggle"><span class="marginnote">I am m accustomed to using the curly brackets all the time, partly because my single-line loops have a habit of expanding to more than one line as I embellish what they do, and partly because I’m used to the programming language Perl where the curly brackets are obligatory even with only one line. Curly brackets in Perl serve the same purpose as indentation serves in Python: figuring out what is inside a loop or an <em>if</em> and what is outside.</span></p>
<p>What is <em>actually</em> happening here is an implicit
loop-within-a-loop. There is a loop over <code>i</code> that goes over all
clusters, and then there is a loop over another variable, <code>j</code>
say, that loops over the <code>nstart</code> runs that we’re doing for
<code>i</code> clusters, where we find the <code>tot.withinss</code> for
<code>i</code> clusters on the <code>j</code>th run, and if it’s the best one
so far for <code>i</code> clusters, we save it. Or, at least,
<code>kmeans</code> saves it.</p>
<p>Or, using <code>map_dbl</code>, which I like better (perhaps because I
have mastered how it works):</p>
<div class="sourceCode" id="cb3866"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3866-1" data-line-number="1">wwx &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">2</span><span class="op">:</span><span class="dv">10</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3866-2" data-line-number="2"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">wss =</span> <span class="kw">map_dbl</span>(clusters, wss, cars.s))</a>
<a class="sourceLine" id="cb3866-3" data-line-number="3">wwx</a></code></pre></div>
<pre><code>## # A tibble: 9 x 2
##   clusters   wss
##      &lt;int&gt; &lt;dbl&gt;
## 1        2  87.3
## 2        3  66.1
## 3        4  50.9
## 4        5  38.2
## 5        6  29.3
## 6        7  24.9
## 7        8  20.8
## 8        9  17.3
## 9       10  15.2</code></pre>
<p>Note that <code>w</code> starts at 1, but <code>wwx</code> starts at 2. For
this way, you <em>have</em> to define a function first to calculate the
total within-cluster sum of squares for a given number of clusters. If
you must, you can define the function within the <code>map_dbl</code>,
but I find that very confusing to read, so I’d rather define the
function first, and then use it later.</p>
<p>This one is just about simple enough to define the function within the <code>map_dbl</code>:</p>
<div class="sourceCode" id="cb3868"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3868-1" data-line-number="1">wwx &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">2</span><span class="op">:</span><span class="dv">10</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3868-2" data-line-number="2"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">wss =</span> <span class="kw">map_dbl</span>(clusters, <span class="op">~</span><span class="st"> </span><span class="kw">kmeans</span>(cars.s, ., <span class="dt">nstart =</span> <span class="dv">20</span>)<span class="op">$</span>tot.withinss))</a>
<a class="sourceLine" id="cb3868-3" data-line-number="3">wwx</a></code></pre></div>
<pre><code>## # A tibble: 9 x 2
##   clusters   wss
##      &lt;int&gt; &lt;dbl&gt;
## 1        2  87.3
## 2        3  66.1
## 3        4  50.9
## 4        5  38.2
## 5        6  29.3
## 6        7  24.2
## 7        8  20.8
## 8        9  17.3
## 9       10  15.2</code></pre>
<p>Instead of having a function name as the second thing in the
<code>map_dbl</code>, I have a so-called “one-sided model formula” that
begins with a squiggle, and then the definition of what I want. The
for-each part finds its way into here as a dot (the number of
clusters, here); this is the equivalent of the <code>i</code> in the loop.</p>
<p>The upshot of all of this is that if you had obtained a total
within-cluster sum of squares for each number of clusters,
<em>somehow</em>, and it’s correct, you should have gotten the
points
<label for="tufte-mn-248" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-248" class="margin-toggle"><span class="marginnote">When this was a question to hand in, which it is not any more.</span> for this part and the last part. This is a common principle
of mine, and works on exams as well as assignments; it goes back to
the idea of “get the job done” that you first saw in C32.</p>
<ol start="7" style="list-style-type: lower-alpha">
<li>Make a scree plot, using the total within-cluster sums of
squares values that you calculated in the previous part.</li>
</ol>
<p>Solution</p>
<p>If you did this the loop way, it’s tempting to leap into this:</p>
<div class="sourceCode" id="cb3870"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3870-1" data-line-number="1">d &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">clusters =</span> nclus, <span class="dt">wss =</span> w)</a></code></pre></div>
<pre><code>## Error in data.frame(clusters = nclus, wss = w): arguments imply differing number of rows: 9, 10</code></pre>
<p>and then wonder why it doesn’t work. The problem is that <code>w</code>
has 10 things in it, including an <code>NA</code> at the front (as a
placeholder for 1 cluster):</p>
<div class="sourceCode" id="cb3872"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3872-1" data-line-number="1">w</a></code></pre></div>
<pre><code>##  [1]       NA 87.29448 66.09396 50.94273 38.22004 29.28816 24.23138
##  [8] 20.76061 18.22591 15.51232</code></pre>
<div class="sourceCode" id="cb3874"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3874-1" data-line-number="1">nclus</a></code></pre></div>
<pre><code>## [1]  2  3  4  5  6  7  8  9 10</code></pre>
<p>while <code>nclus</code> only has 9. So do something like this instead:</p>
<div class="sourceCode" id="cb3876"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3876-1" data-line-number="1"><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">wss =</span> w) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3876-2" data-line-number="2"><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> clusters, <span class="dt">y =</span> wss)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>()</a></code></pre></div>
<pre><code>## Warning: Removed 1 rows containing missing values (geom_point).</code></pre>
<pre><code>## Warning: Removed 1 rows containing missing values (geom_path).</code></pre>
<p><img src="22-thingy_files/figure-html/unnamed-chunk-120-1.png" width="672"  /></p>
<p>This gives a warning because there is no 1-cluster <code>w</code>-value,
but the point is properly omitted from the plot, so the plot you get
is fine.</p>
<p>Or plot the output from <code>map_dbl</code>, which is easier since it’s
already a data frame:</p>
<div class="sourceCode" id="cb3879"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3879-1" data-line-number="1">wwx <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> clusters, <span class="dt">y =</span> wss)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>()</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/unnamed-chunk-121-1.png" width="672"  /></p>
<ol start="8" style="list-style-type: lower-alpha">
<li>What is a suitable number of clusters for K-means, based on
your scree plot?</li>
</ol>
<p>Solution</p>
<p>That seems to me to have a clear elbow at 6, suggesting six
clusters.
<label for="tufte-mn-249" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-249" class="margin-toggle"><span class="marginnote">We do something similar on scree plots for principal components later, but then, for reasons that will become clear then, we take elbow <em>minus 1</em>.</span> Look for where the plot
“turns the corner” from going down to going out, or the point that is the
“last one on the mountain and the first one on the scree”. This
mountainside goes down to 6, and from there it seems to turn the
corner and go out after that.</p>
<p>This is a judgement call, but this particular one is about as clear as
you can expect to see.</p>
<p>I wanted a picture of some real scree. This one shows what I mean:</p>
<p><img src="scree.png" /></p>
<p>Note the rock face and
the loose rock below, which is the scree. Imagine looking at the rock
face and scree from side-on. This is in north Wales, the
other end of Wales from Llanederyn/Llanedeyrn and Caldicot.</p>
<p>The above photo is from <a href="http://www.geograph.org.uk/photo/159935">link</a>.</p>
<ol style="list-style-type: lower-roman">
<li>Run a K-means analysis using the number of clusters suggested
by your scree plot, and list the car names together with the clusters
they belong to, <em>sorted by cluster</em>.</li>
</ol>
<p>Solution</p>
<p>This is the same idea as above. The <code>arrange</code> idea from above
seems to be the cleanest way to arrange the output:
The K-means analysis is thus:</p>
<div class="sourceCode" id="cb3880"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3880-1" data-line-number="1">cars<span class="fl">.2</span> &lt;-<span class="st"> </span><span class="kw">kmeans</span>(cars.s, <span class="dv">6</span>, <span class="dt">nstart =</span> <span class="dv">20</span>)</a></code></pre></div>
<p>or use whatever number of clusters you thought was good from your
scree plot.</p>
<p>Then display them:</p>
<div class="sourceCode" id="cb3881"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3881-1" data-line-number="1">cars <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3881-2" data-line-number="2"><span class="st">  </span><span class="kw">select</span>(Carname) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3881-3" data-line-number="3"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">cluster =</span> cars<span class="fl">.2</span><span class="op">$</span>cluster) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3881-4" data-line-number="4"><span class="st">  </span><span class="kw">arrange</span>(cluster) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3881-5" data-line-number="5"><span class="st">  </span><span class="kw">print</span>(<span class="dt">n =</span> <span class="ot">Inf</span>)</a></code></pre></div>
<pre><code>## # A tibble: 32 x 2
##    Carname             cluster
##    &lt;chr&gt;                 &lt;int&gt;
##  1 Fiat 128                  1
##  2 Honda Civic               1
##  3 Toyota Corolla            1
##  4 Fiat X1-9                 1
##  5 Porsche 914-2             1
##  6 Lotus Europa              1
##  7 Hornet 4 Drive            2
##  8 Valiant                   2
##  9 Merc 240D                 2
## 10 Merc 230                  2
## 11 Toyota Corona             2
## 12 Cadillac Fleetwood        3
## 13 Lincoln Continental       3
## 14 Chrysler Imperial         3
## 15 Hornet Sportabout         4
## 16 Merc 450SE                4
## 17 Merc 450SL                4
## 18 Merc 450SLC               4
## 19 Dodge Challenger          4
## 20 AMC Javelin               4
## 21 Pontiac Firebird          4
## 22 Duster 360                5
## 23 Camaro Z28                5
## 24 Ford Pantera L            5
## 25 Maserati Bora             5
## 26 Mazda RX4                 6
## 27 Mazda RX4 Wag             6
## 28 Datsun 710                6
## 29 Merc 280                  6
## 30 Merc 280C                 6
## 31 Ferrari Dino              6
## 32 Volvo 142E                6</code></pre>
<p>The logic to this is the same as above.
I don’t have a good feeling for what the cars within a cluster have in
common, by eyeballing the names, except for possibly a couple of
things: my cluster 1 seems to be mostly family cars, and my cluster 3
appears to contain “boats” (large cars that consume a lot of
gas). Your clusters ought to be about the same in terms of membership,
but might be numbered differently.</p>
<p>To understand these clusters further, we can use them as input to a
discriminant analysis. There isn’t any real need to run a MANOVA
first, since we kind of know that these groups will be different
(that’s why we ran a cluster analysis).</p>
<p>So, first we’ll make a data frame with the whole original data set
plus the clusters that came out of the K-means. We are adding the
clusters to <code>cars</code>, so it makes sense to use the same ideas as I used
above (without the <code>arrange</code>, that being only for looking at,
and without the <code>select</code>, since this time I want all the
variables that were in <code>cars</code>):</p>
<div class="sourceCode" id="cb3883"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3883-1" data-line-number="1">carsx &lt;-<span class="st"> </span>cars <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(<span class="dt">cluster =</span> cars<span class="fl">.2</span><span class="op">$</span>cluster)</a></code></pre></div>
<p>Now we fire away:</p>
<div class="sourceCode" id="cb3884"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3884-1" data-line-number="1">carsx<span class="fl">.1</span> &lt;-<span class="st"> </span><span class="kw">lda</span>(cluster <span class="op">~</span><span class="st"> </span>mpg <span class="op">+</span><span class="st"> </span>disp <span class="op">+</span><span class="st"> </span>hp <span class="op">+</span><span class="st"> </span>drat <span class="op">+</span><span class="st"> </span>wt <span class="op">+</span><span class="st"> </span>qsec, <span class="dt">data =</span> carsx)</a>
<a class="sourceLine" id="cb3884-2" data-line-number="2">carsx<span class="fl">.1</span></a></code></pre></div>
<pre><code>## Call:
## lda(cluster ~ mpg + disp + hp + drat + wt + qsec, data = carsx)
## 
## Prior probabilities of groups:
##       1       2       3       4       5       6 
## 0.18750 0.15625 0.09375 0.21875 0.12500 0.21875 
## 
## Group means:
##        mpg     disp       hp     drat       wt     qsec
## 1 30.06667  86.6500  75.5000 4.251667 1.873000 18.39833
## 2 21.64000 178.1200  93.8000 3.430000 3.096000 20.51400
## 3 11.83333 457.3333 216.6667 3.053333 5.339667 17.74000
## 4 16.78571 315.6286 170.0000 3.050000 3.688571 17.32000
## 5 14.60000 340.5000 272.2500 3.675000 3.537500 15.08750
## 6 20.41429 147.0286 120.4286 3.888571 2.892143 17.62714
## 
## Coefficients of linear discriminants:
##              LD1           LD2         LD3          LD4          LD5
## mpg  -0.19737944 -0.0155769096 -0.27978549  0.353766928  0.035582922
## disp  0.01950855 -0.0001094137 -0.02090998  0.001034719  0.001680201
## hp    0.02804348  0.0251253160 -0.01727355 -0.015955928 -0.017220548
## drat  0.94348424  1.8928372037  0.56645563  1.264185553 -2.015644662
## wt    0.39068831 -1.3973097325  1.84808828  2.963377419 -0.300573153
## qsec  0.33992344 -0.3010056176 -0.66690927 -0.755053279 -0.738889640
## 
## Proportion of trace:
##    LD1    LD2    LD3    LD4    LD5 
## 0.7977 0.1234 0.0368 0.0299 0.0122</code></pre>
<p>At the bottom (in <code>trace</code>) you see that <code>LD1</code> is clearly
the most important thing for splitting into groups, <code>LD2</code> might
be slightly relevant, and the other <code>LD</code>s are basically
meaningless. So a plot of the first two <code>LD</code>s should tell the story.</p>
<p>Before we get to that, however, we can take a look at the Coefficients
of Linear Discriminants, for <code>LD1</code> and <code>LD2</code>
anyway. <code>LD1</code> depends principally on <code>drat</code>, <code>wt</code>
and <code>qsec</code> (positively) and maybe negatively on
<code>mpg</code>. That means <code>LD1</code> will be large if the car is
powerful, heavy, <em>slow</em> (since a larger <code>qsec</code> means the
car takes longer to go a quarter mile) and consumes a lot of gas. I
think I can summarize this as “powerful”.</p>
<p><code>LD2</code> also depends on <code>drat</code> and <code>wt</code>,
but note the signs: it is contrasting <code>drat</code> (displacement
ratio) with <code>wt</code> (weight), so that a car with a large
displacement ratio relative to its weight would be large (plus) on
<code>LD2</code>. That is, <code>LD2</code> is “powerful for its weight”.</p>
<p>All right, now for a plot, with the points colour-coded by
cluster. There are two ways to do this; the easy one is
<code>ggbiplot</code>. The only weirdness here is that the
<code>cluster</code>s are numbered, so you have to turn that into a factor
first (unless you like shades of blue). I didn’t load the package
first, so I call it here with the package name and the two colons:</p>
<div class="sourceCode" id="cb3886"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3886-1" data-line-number="1">ggbiplot<span class="op">::</span><span class="kw">ggbiplot</span>(carsx<span class="fl">.1</span>, <span class="dt">groups =</span> <span class="kw">factor</span>(carsx<span class="op">$</span>cluster))</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/unnamed-chunk-126-1.png" width="672"  /></p>
<p>Or you can do the predictions, then plot <code>LD1</code> against
<code>LD2</code>, coloured by cluster:</p>
<div class="sourceCode" id="cb3887"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3887-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">predict</span>(carsx<span class="fl">.1</span>)</a>
<a class="sourceLine" id="cb3887-2" data-line-number="2"><span class="kw">data.frame</span>(p<span class="op">$</span>x, <span class="dt">cluster =</span> <span class="kw">factor</span>(carsx<span class="op">$</span>cluster)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3887-3" data-line-number="3"><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> LD1, <span class="dt">y =</span> LD2, <span class="dt">colour =</span> cluster)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb3887-4" data-line-number="4"><span class="st">  </span><span class="kw">coord_fixed</span>()</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/unnamed-chunk-127-1.png" width="672"  /></p>
<p>The pattern of coloured points is the same. The advantage to the
biplot is that you see which original variables contribute to the
<code>LD</code> scores and thus distinguish the clusters; on the second
plot, you have to figure out for yourself which original variables
contribute, and how, to the <code>LD</code> scores.</p>
<p>You should include <code>coord_fixed</code> to make the axis scales the
same, since allowing them to be different will distort the picture
(the picture should come out square). You do the same thing in
multidimensional scaling.</p>
<p>As you see, <code>LD1</code> is doing the best job of separating the
clusters, but <code>LD2</code> is also doing something: separating
clusters 1 and 5, and also 2 and 4 (though 4 is a bit bigger than 2 on
<code>LD1</code> also).</p>
<p>I suggested above that <code>LD1</code> seems to be “powerful”
(on the right) vs. not (on the left). The displacement ratio is a
measure of the power of an engine, so a car
that is large on <code>LD2</code> is powerful for its weight.</p>
<p>Let’s find the clusters I mentioned before. Cluster 3 was the
“boats”: big engines and heavy cars, but not fast. So they
should be large <code>LD1</code> and small (negative)
<code>LD2</code>. Cluster 1 I called “family cars”: they are not
powerful, but have moderate-to-good power for their weight.</p>
<p>With that in mind, we can have a crack at the other clusters. Cluster
2 is neither powerful nor powerful-for-weight (I don’t know these
cars, so can’t
comment further) while cluster 5 is powerful and also powerful for
their weight, so these
might be sports cars. Clusters 6 and 4 are less and more
powerful, both averagely powerful for their size.</p>
</div>
<div id="running-jumping-and-throwing" class="section level2">
<h2><span class="header-section-number">26.7</span> Running, jumping, and throwing</h2>
<p>The decathlon is a men’s
<label for="tufte-mn-250" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-250" class="margin-toggle"><span class="marginnote">Women compete in a similar competition called the <em>heptathlon</em> with seven events.</span> track-and-field competition in which competitors complete 10
events over two days as follows, requiring the skills shown:</p>

<p>These are a mixture of running, jumping and throwing disciplines. The
performance (time, distance or height) achieved in each event is
converted to a number of points using standard tables,
<label for="tufte-mn-251" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-251" class="margin-toggle"><span class="marginnote">How I understand it works is that a <em>good</em> performance in an event is worth 1000 points, and then, according to the event, each second or centimetre better or worse than this is worth a certain number of points up or down from 1000. At this level, the winner of the whole decathlon will get somewhere near 10,000 points. A look at the Wikipedia article reveals that it is not quite as simple as this, but this is the idea.</span> and the winner of the entire decathlon is the
competitor with the largest total of points. (A good decathlete has to
be at least reasonably good at all the disciplines.)</p>
<p>For the decathlon competition at the 2013 Track and Field World
Championship, a record was kept of each competitor’s performance in
each event (for the competitors that competed in all ten
events). These values are in
<a href="http://www.utsc.utoronto.ca/~butler/d29/dec2013.txt">link</a>.</p>
<ol style="list-style-type: lower-alpha">
<li>Read in the data and verify that you have the right number
of variables.</li>
</ol>
<p>Solution</p>
<p>Checking the file, this is delimited by single spaces. You might
be concerned by the quotes; we’ll read them in and see what
happens to them.</p>
<div class="sourceCode" id="cb3888"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3888-1" data-line-number="1">my_url &lt;-<span class="st"> &quot;http://www.utsc.utoronto.ca/~butler/d29/dec2013.txt&quot;</span></a>
<a class="sourceLine" id="cb3888-2" data-line-number="2">decathlon0 &lt;-<span class="st"> </span><span class="kw">read_delim</span>(my_url, <span class="st">&quot; &quot;</span>)</a></code></pre></div>
<pre><code>## Parsed with column specification:
## cols(
##   name = col_character(),
##   x100m = col_double(),
##   long.jump = col_double(),
##   shot.put = col_double(),
##   high.jump = col_double(),
##   x400m = col_double(),
##   x110mh = col_double(),
##   discus = col_double(),
##   pole.vault = col_double(),
##   javelin = col_double(),
##   x1500m = col_double()
## )</code></pre>
<div class="sourceCode" id="cb3890"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3890-1" data-line-number="1">decathlon0</a></code></pre></div>
<pre><code>## # A tibble: 24 x 11
##    name  x100m long.jump shot.put high.jump x400m x110mh discus pole.vault
##    &lt;chr&gt; &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;
##  1 Asht…  10.4      7.73     14.4      1.93  46.0   13.7   45          5.2
##  2 Dami…  10.4      7.39     14.2      2.05  48.4   14.0   44.1        4.8
##  3 Rico…  10.6      7.22     14.8      1.99  48.0   13.9   48.7        4.9
##  4 Miha…  10.7      7.51     13.4      1.96  47.7   14.6   44.1        4.9
##  5 Mich…  10.7      7.85     14.6      1.99  47.7   14.3   46.4        5  
##  6 Carl…  10.8      7.54     14.5      1.96  48.8   14.0   45.8        5.1
##  7 Gunn…  10.8      7.8      14.7      2.14  48.6   14.6   42.4        4.6
##  8 Eelc…  10.8      7.65     14.1      2.02  48.2   14.2   39.2        5.3
##  9 Pasc…  11.0      7.19     15.9      1.99  48.4   14.5   45.7        4.7
## 10 Will…  11.0      7.44     13.9      2.05  48.3   14.3   43.2        4.5
## # … with 14 more rows, and 2 more variables: javelin &lt;dbl&gt;, x1500m &lt;dbl&gt;</code></pre>
<p>The names got shortened for display, but the quotes seem to have
properly disappeared.</p>
<p>Note that the columns that would otherwise start with digits have
<code>x</code> on the front of their names, so as to guarantee that the
column names are legal variable names (and thus won’t require any
special treatment later).</p>
<ol start="2" style="list-style-type: lower-alpha">
<li>Some of the performances are times in seconds, and some of
them are distances (or heights) in metres. Also, some of the columns
are more variable than others. Produce a matrix of standardized
performances in each event, making sure not to try to standardize
the names!</li>
</ol>
<p>Solution</p>
<p><code>scale</code> is what I am trying to hint towards. Leave off the
first column. I would rather specify this by name than by
number. (People have an annoying habit of changing the order of
columns, but the column <em>name</em> is more work to change and
thus it is less likely that it will change.)</p>
<div class="sourceCode" id="cb3892"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3892-1" data-line-number="1">decathlon0 <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3892-2" data-line-number="2"><span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>name) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3892-3" data-line-number="3"><span class="st">  </span><span class="kw">scale</span>() -&gt;<span class="st"> </span>decathlon</a>
<a class="sourceLine" id="cb3892-4" data-line-number="4"><span class="kw">round</span>(decathlon, <span class="dv">2</span>)</a></code></pre></div>
<pre><code>##       x100m long.jump shot.put high.jump x400m x110mh discus pole.vault javelin x1500m
##  [1,] -2.21      1.24     0.29     -0.95 -2.43  -1.77   0.27       1.10    0.55  -0.49
##  [2,] -1.92      0.16     0.03      0.74 -0.46  -1.23  -0.06      -0.39    0.52  -0.46
##  [3,] -1.33     -0.38     0.96     -0.11 -0.75  -1.37   1.71      -0.02   -1.17   0.63
##  [4,] -1.08      0.54    -1.24     -0.53 -1.02   0.17  -0.09      -0.02   -0.60  -0.93
##  [5,] -0.87      1.62     0.57     -0.11 -1.08  -0.50   0.82       0.36    0.72  -1.10
##  [6,] -0.69      0.64     0.46     -0.53 -0.13  -1.03   0.59       0.73   -0.42   0.37
##  [7,] -0.48      1.46     0.77      2.01 -0.33   0.13  -0.73      -1.14   -0.82   0.35
##  [8,] -0.45      0.99    -0.21      0.32 -0.59  -0.74  -1.95       1.48   -1.06  -1.20
##  [9,] -0.10     -0.47     2.68     -0.11 -0.46  -0.12   0.53      -0.76    1.00   0.54
## [10,] -0.10      0.32    -0.54      0.74 -0.53  -0.47  -0.40      -1.51    1.45  -1.21
## [11,] -0.02      0.03    -0.54      0.74 -0.47  -0.39  -0.09       1.85   -0.52   0.50
## [12,] -0.02      0.26    -0.10     -0.53 -0.13   0.69   1.42      -1.14   -2.26   0.06
## [13,]  0.01     -0.12    -0.02     -1.37  1.80   1.60   0.37      -1.51    1.46   1.82
## [14,]  0.33     -0.03    -0.02     -1.37 -0.62   0.24   0.81      -0.02    1.30  -1.31
## [15,]  0.40      0.95    -1.04      0.74  0.03   0.33  -1.20       0.73    0.65   0.64
## [16,]  0.47     -0.79     0.36     -0.11  0.04  -0.68  -0.09       0.36   -0.05  -0.05
## [17,]  0.57     -0.19    -0.60      0.32  1.07   1.51  -0.69      -1.51   -0.95   0.72
## [18,]  0.61     -2.09    -1.63     -1.37 -0.24  -0.32  -2.39       0.73    0.46   0.36
## [19,]  0.75      0.16     1.03      1.59  0.57  -0.16   0.70       0.73   -0.42   0.88
## [20,]  0.82     -0.25    -0.86      1.59  1.36   1.74  -0.94      -0.02   -0.49   2.07
## [21,]  0.89      0.51    -0.73      0.74  0.47  -0.68   0.41       1.10    0.80  -1.14
## [22,]  1.24     -0.69     1.07     -0.11  0.73   0.06   1.26       0.36    0.16  -0.02
## [23,]  1.56     -2.28     0.98     -1.80  1.32   1.18  -0.69      -1.51   -1.44  -1.83
## [24,]  1.63     -1.58    -1.69     -0.53  1.85   1.80   0.39      -0.02    1.11   0.78
## attr(,&quot;scaled:center&quot;)
##      x100m  long.jump   shot.put  high.jump      x400m     x110mh     discus pole.vault 
##  10.977083   7.339167  14.209583   1.997500  48.960000  14.512500  44.288333   4.904167 
##    javelin     x1500m 
##  62.069583 273.306667 
## attr(,&quot;scaled:scale&quot;)
##      x100m  long.jump   shot.put  high.jump      x400m     x110mh     discus pole.vault 
## 0.28433720 0.31549708 0.61480629 0.07091023 1.20878667 0.44795429 2.60828224 0.26780779 
##    javelin     x1500m 
## 5.01529875 7.22352899</code></pre>
<p>I think the matrix of standardized values is small enough to look at
all of, particularly if I round off the values to a small number of
decimals. (Note that the means and SDs
appear at the bottom as “attributes”.)</p>
<ol start="3" style="list-style-type: lower-alpha">
<li>We are going to make a scree plot to decide on the number
of clusters our K-means clustering should use. Using a loop, or
otherwise,
<label for="tufte-mn-252" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-252" class="margin-toggle"><span class="marginnote">I grew up in the UK, and when I saw that in an exam, it was code for <em>the way they say is obvious but long, and the otherwise-way is clever but short</em>. I think this is one of those.</span> obtain the total within-cluster sum of squares for these
data for each number of clusters for 2 up to 20.</li>
</ol>
<p>Solution</p>
<p>Having kind of given the game away in the footnote, I guess I now
have to keep up my end of the deal and show you the obvious way
and the clever way.
The obvious way is to do a Python-style loop, thus:</p>
<div class="sourceCode" id="cb3894"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3894-1" data-line-number="1">maxclust</a></code></pre></div>
<pre><code>## [1] 20</code></pre>
<div class="sourceCode" id="cb3896"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3896-1" data-line-number="1">w &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb3896-2" data-line-number="2"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span>maxclust) {</a>
<a class="sourceLine" id="cb3896-3" data-line-number="3">  sol &lt;-<span class="st"> </span><span class="kw">kmeans</span>(decathlon, i, <span class="dt">nstart =</span> <span class="dv">20</span>)</a>
<a class="sourceLine" id="cb3896-4" data-line-number="4">  w[i] &lt;-<span class="st"> </span>sol<span class="op">$</span>tot.withinss</a>
<a class="sourceLine" id="cb3896-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb3896-6" data-line-number="6">w</a></code></pre></div>
<pre><code>##  [1]        NA 175.03246 151.08750 131.30247 113.59681 102.61744  89.64931  78.89089
##  [9]  68.99662  60.77665  54.29991  47.64227  41.40352  35.39181  29.52008  25.05344
## [17]  21.02841  17.28444  13.80627  10.44197</code></pre>
<p>I defined <code>maxclust</code> earlier, surreptitiously. (Actually, what
happened was that I changed my mind about how many clusters I wanted
you to go up to, so that instead of hard-coding the maximum number of
clusters, I decided to put it in a variable so that I only had to
change it once if I changed my mind again.)</p>
<p>I decided to split the stuff within the loop into two lines, first
getting the <span class="math inline">\(i\)</span>-cluster solution, and then pulling out the total
within-cluster sum of squares from it and saving it in the right place
in <code>w</code>. You can do it in one step or two; I don’t mind.</p>
<p>The first value in <code>w</code> is missing, because we didn’t calculate
a value for 1 cluster (so that this <code>w</code> has 20 values, one of
which is missing).</p>
<p>Not that there’s anything wrong with this,
<label for="tufte-mn-253" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-253" class="margin-toggle"><span class="marginnote">I have to sneak a Seinfeld quote in there somewhere.</span> and if it works, it’s good, but the
True R Way
<label for="tufte-mn-254" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-254" class="margin-toggle"><span class="marginnote">Like Buddhism. I keep feeling that R should have something called the Eight Noble Truths or similar. See the Extra at the end of this part.</span> is not to use a
loop, but get the whole thing in one shot.
The first stage is to figure out what you want to do for some number of clusters. In this case, it’s something like this:</p>
<div class="sourceCode" id="cb3898"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3898-1" data-line-number="1"><span class="kw">kmeans</span>(decathlon, <span class="dv">3</span>, <span class="dt">nstart =</span> <span class="dv">20</span>)<span class="op">$</span>tot.withinss</a></code></pre></div>
<pre><code>## [1] 151.0875</code></pre>
<p>There’s nothing special about 3; any number will do.</p>
<p>The second stage is to run this for each desired number of
clusters, without using a loop.
This uses a family of functions whose
names start with <code>map</code>. To figure out which one to
use, take a look at your line of code above: ours returns a single number, a
<code>double</code> in the jargon (decimal number), so the <code>map</code>
function we need is called <code>map_dbl</code>, and it goes like
this. You can do it inside or outside a data frame, but I prefer to do
it inside with a <code>mutate</code>:</p>
<div class="sourceCode" id="cb3900"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3900-1" data-line-number="1"><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">2</span><span class="op">:</span>maxclust) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3900-2" data-line-number="2"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">wss =</span> <span class="kw">map_dbl</span>(clusters, <span class="op">~</span><span class="st"> </span><span class="kw">kmeans</span>(decathlon, .,</a>
<a class="sourceLine" id="cb3900-3" data-line-number="3">    <span class="dt">nstart =</span> <span class="dv">20</span></a>
<a class="sourceLine" id="cb3900-4" data-line-number="4">  )<span class="op">$</span>tot.withinss)) -&gt;<span class="st"> </span>ww</a>
<a class="sourceLine" id="cb3900-5" data-line-number="5">ww</a></code></pre></div>
<pre><code>## # A tibble: 19 x 2
##    clusters   wss
##       &lt;int&gt; &lt;dbl&gt;
##  1        2 175. 
##  2        3 151. 
##  3        4 131. 
##  4        5 114. 
##  5        6 100. 
##  6        7  89.5
##  7        8  78.8
##  8        9  69.0
##  9       10  60.8
## 10       11  54.3
## 11       12  48.1
## 12       13  41.4
## 13       14  35.4
## 14       15  29.5
## 15       16  25.1
## 16       17  21.0
## 17       18  17.3
## 18       19  13.8
## 19       20  10.4</code></pre>
<p>I have to say that I got this right the first time, but I think I
benefitted greatly in that regard by writing out that explanation for
you first. <code>wss</code> in <code>ww</code> has the same values as
<code>w</code>, but without the missing one.</p>
<p>There was (still is) also a function <code>sapply</code> that does the
same thing, but the <code>map</code> functions work more uniformly. I
learned <code>sapply</code> and friends a long time ago, and now, with the
arrival of purrr, I think I need to unlearn them.</p>
<p>If the thing in the “for each” slot of a <code>map</code> is a data
frame (or if you pipe a data frame into it), then the function is
applied to every column of that data frame, so that if I go back to
<code>decathlon0</code>, which was a data frame, and do this:</p>
<div class="sourceCode" id="cb3902"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3902-1" data-line-number="1">decathlon0 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(<span class="op">-</span>name) -&gt;<span class="st"> </span>decathlon.tmp</a>
<a class="sourceLine" id="cb3902-2" data-line-number="2">decathlon.tmp <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">map_dbl</span>(<span class="op">~</span><span class="st"> </span><span class="kw">mean</span>(.))</a></code></pre></div>
<pre><code>##      x100m  long.jump   shot.put  high.jump      x400m     x110mh 
##  10.977083   7.339167  14.209583   1.997500  48.960000  14.512500 
##     discus pole.vault    javelin     x1500m 
##  44.288333   4.904167  62.069583 273.306667</code></pre>
<p>then what I get is the mean of each (numeric) column. I first get rid
of the name column, and save the result in a new temporary data frame
<code>decathlon.tmp</code>;
the <code>name</code> column would be a
pretty silly thing to take the mean of.</p>
<p>I wrote this out a couple of years ago, and realize that I no longer
like doing things this way; what I prefer is <code>summarize_at</code> or
<code>summarize_if</code> or
<code>summarize_all</code>. These work in much
the same way as a <code>map</code>, dot and all. The last one is easiest:</p>
<div class="sourceCode" id="cb3904"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3904-1" data-line-number="1">decathlon0 <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3904-2" data-line-number="2"><span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>name) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3904-3" data-line-number="3"><span class="st">  </span><span class="kw">summarize_all</span>(<span class="op">~</span><span class="st"> </span><span class="kw">mean</span>(.))</a></code></pre></div>
<pre><code>## # A tibble: 1 x 10
##   x100m long.jump shot.put high.jump x400m x110mh discus pole.vault
##   &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;
## 1  11.0      7.34     14.2      2.00  49.0   14.5   44.3       4.90
## # … with 2 more variables: javelin &lt;dbl&gt;, x1500m &lt;dbl&gt;</code></pre>
<p>That is, “for each column, find the mean of it”.</p>
<p>The <code>_if</code> variant uses only those columns that have a property
like being numeric (so that these are the only columns for which
finding the mean makes sense):</p>
<div class="sourceCode" id="cb3906"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3906-1" data-line-number="1">decathlon0 <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3906-2" data-line-number="2"><span class="st">  </span><span class="kw">summarize_if</span>(is.numeric, <span class="op">~</span><span class="st"> </span><span class="kw">mean</span>(.))</a></code></pre></div>
<pre><code>## # A tibble: 1 x 10
##   x100m long.jump shot.put high.jump x400m x110mh discus pole.vault
##   &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;
## 1  11.0      7.34     14.2      2.00  49.0   14.5   44.3       4.90
## # … with 2 more variables: javelin &lt;dbl&gt;, x1500m &lt;dbl&gt;</code></pre>
<p>In words, “for each column that is numeric, find the mean of it”.
This way, we no longer have to explicitly remove the names.</p>
<p>The <code>_at</code> variant only uses the columns whose <em>names</em>
satisfy some property, like beginning with <code>x</code>:</p>
<div class="sourceCode" id="cb3908"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3908-1" data-line-number="1">decathlon0 <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3908-2" data-line-number="2"><span class="st">  </span><span class="kw">summarize_at</span>(<span class="kw">vars</span>(<span class="kw">starts_with</span>(<span class="st">&quot;x&quot;</span>)), <span class="op">~</span><span class="st"> </span><span class="kw">mean</span>(.))</a></code></pre></div>
<pre><code>## # A tibble: 1 x 4
##   x100m x400m x110mh x1500m
##   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
## 1  11.0  49.0   14.5   273.</code></pre>
<p>In words, “for each variable whose name starts with <code>x</code>, find the mean of it.”
Now, what happens, I hear you asking, if the function returns more than one
thing, like for example <code>quantile</code>, which returns a vector
containing the five-number summary? Well, then you use <code>map_df</code>
and you get this:</p>
<div class="sourceCode" id="cb3910"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3910-1" data-line-number="1">decathlon.tmp <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">map_df</span>(<span class="op">~</span><span class="st"> </span><span class="kw">quantile</span>(.))</a></code></pre></div>
<pre><code>## # A tibble: 5 x 10
##   x100m long.jump shot.put high.jump x400m x110mh discus pole.vault
##   &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;
## 1  10.4      6.62     13.2      1.87  46.0   13.7   38.1       4.5 
## 2  10.8      7.21     13.8      1.96  48.3   14.2   42.5       4.68
## 3  11.0      7.37     14.2      1.99  48.7   14.4   44.6       4.9 
## 4  11.2      7.52     14.6      2.05  49.7   14.7   45.9       5.1 
## 5  11.4      7.85     15.9      2.14  51.2   15.3   48.7       5.4 
## # … with 2 more variables: javelin &lt;dbl&gt;, x1500m &lt;dbl&gt;</code></pre>
<p>The idea is that <code>quantile</code> returns something that can be
treated as a one-column data frame, and <code>map_df</code> says
“<code>quantile</code> returns a data frame rather than just a number.”
The only downside is that <code>quantile</code> actually (for each
variable) returns a vector with a name attribute (the names of the
five percentiles that were calculated), and the <code>tidyverse</code>
treats those like row names and discards them.</p>
<p>Another way that might work (and might keep the quantiles) is</p>
<div class="sourceCode" id="cb3912"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3912-1" data-line-number="1">decathlon.tmp <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3912-2" data-line-number="2"><span class="st">  </span><span class="kw">map_df</span>(<span class="op">~</span><span class="st"> </span><span class="kw">enframe</span>(<span class="kw">quantile</span>(.)))</a></code></pre></div>
<pre><code>## # A tibble: 50 x 2
##    name  value
##    &lt;chr&gt; &lt;dbl&gt;
##  1 0%    10.4 
##  2 25%   10.8 
##  3 50%   11.0 
##  4 75%   11.2 
##  5 100%  11.4 
##  6 0%     6.62
##  7 25%    7.21
##  8 50%    7.37
##  9 75%    7.52
## 10 100%   7.85
## # … with 40 more rows</code></pre>
<p>This keeps the quantiles, but loses the variable names!</p>
<p>All right, let’s make the data frame long before taking quantiles,
since the Tidyverse likes that kind of thing better anyway. This is
the same kind of idea that you might have seen for plotting the
residuals against <em>all</em> the <span class="math inline">\(x\)</span>-variables in a multiple regression:</p>
<div class="sourceCode" id="cb3914"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3914-1" data-line-number="1">decathlon.tmp <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3914-2" data-line-number="2"><span class="st">  </span><span class="kw">pivot_longer</span>(<span class="kw">everything</span>(), <span class="dt">names_to=</span><span class="st">&quot;event&quot;</span>, <span class="dt">values_to=</span><span class="st">&quot;performance&quot;</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3914-3" data-line-number="3"><span class="st">  </span><span class="kw">nest</span>(<span class="op">-</span>event) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3914-4" data-line-number="4"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">quantile =</span> <span class="kw">map</span>(data, <span class="op">~</span><span class="st"> </span><span class="kw">enframe</span>(<span class="kw">quantile</span>(.<span class="op">$</span>performance),</a>
<a class="sourceLine" id="cb3914-5" data-line-number="5">    <span class="dt">name =</span> <span class="st">&quot;quantile&quot;</span>,</a>
<a class="sourceLine" id="cb3914-6" data-line-number="6">    <span class="dt">value =</span> <span class="st">&quot;perf&quot;</span></a>
<a class="sourceLine" id="cb3914-7" data-line-number="7">  ))) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3914-8" data-line-number="8"><span class="st">  </span><span class="kw">unnest</span>(quantile) -&gt;<span class="st"> </span>quantiles.long</a></code></pre></div>
<pre><code>## Warning: All elements of `...` must be named.
## Did you want `data = c(performance)`?</code></pre>
<div class="sourceCode" id="cb3916"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3916-1" data-line-number="1">quantiles.long</a></code></pre></div>
<pre><code>## # A tibble: 50 x 4
##    event               data quantile  perf
##    &lt;chr&gt;     &lt;list&lt;df[,1]&gt;&gt; &lt;chr&gt;    &lt;dbl&gt;
##  1 x100m           [24 × 1] 0%       10.4 
##  2 x100m           [24 × 1] 25%      10.8 
##  3 x100m           [24 × 1] 50%      11.0 
##  4 x100m           [24 × 1] 75%      11.2 
##  5 x100m           [24 × 1] 100%     11.4 
##  6 long.jump       [24 × 1] 0%        6.62
##  7 long.jump       [24 × 1] 25%       7.21
##  8 long.jump       [24 × 1] 50%       7.37
##  9 long.jump       [24 × 1] 75%       7.52
## 10 long.jump       [24 × 1] 100%      7.85
## # … with 40 more rows</code></pre>
<p>To follow this, run it one line at a time. The <code>nest(-event)</code>
line creates a two-column data frame that contains a column called
<code>event</code> and a second column <code>data</code> that contains
everything else (just <code>performance</code> in this case). Then the big <code>mutate</code> line says “for each data frame in <code>data</code>, calculate the quantiles of the performance column in it, giving names to the columns of the output”.
This produces a second list-column called <code>quantile</code>, which I
then <code>unnest</code> to display all the quantiles for each event.</p>
<p>Almost there. Now we have both the events and the quantiles, but it would be nice to put the quantiles in columns. Which seems to be <code>pivot_wider</code>:</p>
<div class="sourceCode" id="cb3918"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3918-1" data-line-number="1">quantiles.long <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pivot_wider</span>(<span class="dt">names_from=</span>quantile, <span class="dt">values_from=</span>perf)</a></code></pre></div>
<pre><code>## # A tibble: 10 x 7
##    event                data   `0%`  `25%`  `50%`  `75%` `100%`
##    &lt;chr&gt;      &lt;list&lt;df[,1]&gt;&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
##  1 x100m            [24 × 1]  10.4   10.8   11.0   11.2   11.4 
##  2 long.jump        [24 × 1]   6.62   7.21   7.37   7.52   7.85
##  3 shot.put         [24 × 1]  13.2   13.8   14.2   14.6   15.9 
##  4 high.jump        [24 × 1]   1.87   1.96   1.99   2.05   2.14
##  5 x400m            [24 × 1]  46.0   48.3   48.7   49.7   51.2 
##  6 x110mh           [24 × 1]  13.7   14.2   14.4   14.7   15.3 
##  7 discus           [24 × 1]  38.1   42.5   44.6   45.9   48.7 
##  8 pole.vault       [24 × 1]   4.5    4.68   4.9    5.1    5.4 
##  9 javelin          [24 × 1]  50.7   58.8   62.4   65.8   69.4 
## 10 x1500m           [24 × 1] 260.   266.   275.   278.   288.</code></pre>
<p>and that looks nice.</p>
<p>Extra: I made a post on Twitter, <a href="https://twitter.com/KenButler12/status/1100133496637542401">link</a>.
To which Malcolm Barrett replied with this: <a href="https://twitter.com/malco_barrett/status/1100141130186780672">link</a>
and this: <a href="https://twitter.com/malco_barrett/status/1100140736945647616">link</a>.
So now you know all about the Four Noble R Truths.</p>
<ol start="4" style="list-style-type: lower-alpha">
<li>Using what you calculated in the previous part, draw a scree
plot. (You may have to create a data frame first.) How does your
scree plot tell you that 5 is a possible number of clusters? Explain
briefly.</li>
</ol>
<p>Solution</p>
<p>This requires a teeny bit of care. If you went the loop way, what I
called <code>w</code> has a missing value first (unless you were
especially careful), so you have to plot it against <em>1</em> through 20:</p>
<div class="sourceCode" id="cb3920"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3920-1" data-line-number="1"><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">1</span><span class="op">:</span>maxclust, <span class="dt">wss =</span> w) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3920-2" data-line-number="2"><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> clusters, <span class="dt">y =</span> wss)) <span class="op">+</span></a>
<a class="sourceLine" id="cb3920-3" data-line-number="3"><span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>()</a></code></pre></div>
<pre><code>## Warning: Removed 1 rows containing missing values (geom_point).</code></pre>
<pre><code>## Warning: Removed 1 rows containing missing values (geom_path).</code></pre>
<p><img src="22-thingy_files/figure-html/freddo-1.png" width="672"  /></p>
<p>The warning message is to say that you don’t have a total
within-cluster sum of squares for 1 cluster, which you knew already.</p>
<p>Or you can save the data frame first and then feed it into
<code>ggplot</code>.</p>
<p>If you went the <code>map</code> way, you will have the <code>wss</code>
values for 2 through 20 clusters already in a data
frame, so it is a fair bit simpler:</p>
<div class="sourceCode" id="cb3923"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3923-1" data-line-number="1">ww <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3923-2" data-line-number="2"><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> clusters, <span class="dt">y =</span> wss)) <span class="op">+</span></a>
<a class="sourceLine" id="cb3923-3" data-line-number="3"><span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>()</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/bilharzia-1.png" width="672"  /></p>
<p>There is, I suppose, the tiniest elbow at 5 clusters. It’s not very
clear, though. I would have liked it to be clearer.</p>
<ol start="5" style="list-style-type: lower-alpha">
<li>Run K-means with 5 clusters. Produce an output that shows
which competitors are in which cluster.</li>
</ol>
<p>Solution</p>
<p>If you’re using R Markdown, you might like to start with this:</p>
<div class="sourceCode" id="cb3924"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3924-1" data-line-number="1"><span class="kw">set.seed</span>(<span class="dv">457299</span>)</a></code></pre></div>
<p>or some other random number seed of your choice. Using
<code>nstart=20</code> or similar will give you the same <em>clustering</em>,
but which cluster is cluster 1 might vary between runs. So if you talk
about cluster 1 (below), and re-knit the document, you might otherwise
find that cluster 1 has changed identity since the last time you
knitted it. (I just remembered that for these solutions.)</p>
<p>Running the <code>kmeans</code> itself is a piece of cake, since you have
done it a bunch of times already (in your loop or <code>map</code>):</p>
<div class="sourceCode" id="cb3925"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3925-1" data-line-number="1">decathlon<span class="fl">.1</span> &lt;-<span class="st"> </span><span class="kw">kmeans</span>(decathlon, <span class="dv">5</span>, <span class="dt">nstart =</span> <span class="dv">20</span>)</a>
<a class="sourceLine" id="cb3925-2" data-line-number="2">decathlon<span class="fl">.1</span></a></code></pre></div>
<pre><code>## K-means clustering with 5 clusters of sizes 6, 5, 8, 1, 4
## 
## Cluster means:
##         x100m   long.jump   shot.put     high.jump      x400m
## 1 -0.97448850  0.64184430 -0.1484207 -2.467909e-01 -1.0216857
## 2  0.28457995  0.07871177 -0.8288519  2.326886e-01 -0.1588370
## 3 -0.02051555  0.02245134  0.9034011  2.644188e-01 -0.0589434
## 4  1.55771620 -2.27947172  0.9765949 -1.798048e+00  1.3236413
## 5  0.75760985 -0.53619092 -0.7922550 -1.554312e-15  1.5180512
##       x110mh     discus  pole.vault     javelin     x1500m
## 1 -0.5934385  0.2274805 -0.07779211  0.65707285 -0.9136808
## 2 -0.3582955 -1.0406594  1.17932839  0.06548297 -0.1670467
## 3 -0.3097414  0.6739749 -0.10890895 -0.49565010  0.3441300
## 4  1.1775755 -0.6894704 -1.50916693 -1.43751822 -1.8269002
## 5  1.6631161 -0.2159787 -0.76236268  0.28321676  1.3477946
## 
## Clustering vector:
##  [1] 1 1 3 1 1 3 3 2 3 1 2 3 5 1 2 3 5 2 3 5 2 3 4 5
## 
## Within cluster sum of squares by cluster:
## [1] 27.08131 26.24500 41.40072  0.00000 18.86978
##  (between_SS / total_SS =  50.6 %)
## 
## Available components:
## 
## [1] &quot;cluster&quot;      &quot;centers&quot;      &quot;totss&quot;        &quot;withinss&quot;    
## [5] &quot;tot.withinss&quot; &quot;betweenss&quot;    &quot;size&quot;         &quot;iter&quot;        
## [9] &quot;ifault&quot;</code></pre>
<p>I displayed the result, so that I would know which of the things I
needed later. The <code>Available components</code> at the bottom is a big
hint with this.</p>
<p>To display who is in which cluster, it’s easiest to
make a data frame of names and clusters and sort it:</p>
<div class="sourceCode" id="cb3927"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3927-1" data-line-number="1"><span class="kw">tibble</span>(<span class="dt">name =</span> decathlon0<span class="op">$</span>name, <span class="dt">cluster =</span> decathlon<span class="fl">.1</span><span class="op">$</span>cluster) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3927-2" data-line-number="2"><span class="st">  </span><span class="kw">arrange</span>(cluster) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3927-3" data-line-number="3"><span class="st">  </span><span class="kw">print</span>(<span class="dt">n =</span> <span class="ot">Inf</span>)</a></code></pre></div>
<pre><code>## # A tibble: 24 x 2
##    name                    cluster
##    &lt;chr&gt;                     &lt;int&gt;
##  1 Ashton Eaton                  1
##  2 Damian Warner                 1
##  3 Mihail Dudas                  1
##  4 Michael Schrader              1
##  5 Willem Coertzen               1
##  6 Leonel Suarez                 1
##  7 Eelco Sintnicolaas            2
##  8 Ilya Shkurenyov               2
##  9 Thomas van der Plaetsen       2
## 10 Pelle Rietveld                2
## 11 Kevin Mayer                   2
## 12 Rico Freimuth                 3
## 13 Carlos Chinin                 3
## 14 Gunnar Nixon                  3
## 15 Pascal Behrenbruch            3
## 16 Eduard Mikhan                 3
## 17 Artem Lukyanenko              3
## 18 Andrei Krauchanka             3
## 19 Mikk Pahapill                 3
## 20 Marcus Nilsson                4
## 21 Sergey Sviridov               5
## 22 Brent Newdick                 5
## 23 Maicel Uibo                   5
## 24 Keisuke Ushiro                5</code></pre>
<ol start="6" style="list-style-type: lower-alpha">
<li>Display the cluster means for all of the events. (This has
already been calculated; you just have to display it.) Find the
cluster mean, looking at all of the events, that is farthest from
zero, and see if you can describe the strengths and weaknesses of the
athletes in that cluster (look at all the events for the cluster that
has that extreme mean). Bear in mind (i) that these are the original
performances standardized, and (ii) for a running event, a
<em>smaller</em> value is better.</li>
</ol>
<p>Solution</p>
<p>This is the thing called <code>centers</code>:
<label for="tufte-mn-255" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-255" class="margin-toggle"><span class="marginnote">We are no longer in the <em>tidyverse</em>, so you no longer have the option of using British or American spelling.</span></p>
<div class="sourceCode" id="cb3929"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3929-1" data-line-number="1">decathlon<span class="fl">.1</span><span class="op">$</span>centers</a></code></pre></div>
<pre><code>##         x100m   long.jump   shot.put     high.jump      x400m
## 1 -0.97448850  0.64184430 -0.1484207 -2.467909e-01 -1.0216857
## 2  0.28457995  0.07871177 -0.8288519  2.326886e-01 -0.1588370
## 3 -0.02051555  0.02245134  0.9034011  2.644188e-01 -0.0589434
## 4  1.55771620 -2.27947172  0.9765949 -1.798048e+00  1.3236413
## 5  0.75760985 -0.53619092 -0.7922550 -1.554312e-15  1.5180512
##       x110mh     discus  pole.vault     javelin     x1500m
## 1 -0.5934385  0.2274805 -0.07779211  0.65707285 -0.9136808
## 2 -0.3582955 -1.0406594  1.17932839  0.06548297 -0.1670467
## 3 -0.3097414  0.6739749 -0.10890895 -0.49565010  0.3441300
## 4  1.1775755 -0.6894704 -1.50916693 -1.43751822 -1.8269002
## 5  1.6631161 -0.2159787 -0.76236268  0.28321676  1.3477946</code></pre>
<p>My most extreme value is the <span class="math inline">\(-2.28\)</span> in the long jump column, cluster
4. Yours may well be different, since the formation of clusters is
random: it will probably not be the same number cluster, and it might
not even be the same value. Use whatever you have. (I asked you to
find the most extreme one so that the other events in the same cluster
are likely to be extreme as well and you have something to say.)</p>
<p>So I have to look along my cluster 4 row. I see:</p>
<ul>
<li><p>100m run high (bad)</p></li>
<li><p>long jump low (bad)</p></li>
<li><p>shot put high (good)</p></li>
<li><p>high jump low (bad)</p></li>
<li><p>400m run high (bad)</p></li>
<li><p>110m hurdles run high (bad)</p></li>
<li><p>discus lowish (bad)</p></li>
<li><p>pole vault low (bad)</p></li>
<li><p>javelin low (bad)</p></li>
<li><p>1500m low (good)</p></li>
</ul>
<p>The only two good events here are shot put (throwing a heavy ball) and
1500m (a long run). So what these athletes have in common is good strength
and endurance, and bad speed and agility. (You can use my
“skills required” in the table at the top of the question as a guide.)</p>
<p>I said “these athletes”. I actually meant “this athlete”, since
this is the cluster with just Marcus Nilsson in it. I ought to have
checked that we were looking at a cluster with several athletes in it,
and then this question would have made more sense, but the thought
process is the same, so it doesn’t matter so much.</p>
<p>Your cluster may well be different; I’m looking for some sensible
discussion based on the values you have. I’m hoping that the athletes
in your cluster will tend to be good at something and bad at something
else, and the things they are good at (or bad at) will have something
in common.</p>
<p>What would have made more sense would have been to take the
<em>biggest</em> cluster:</p>
<div class="sourceCode" id="cb3931"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3931-1" data-line-number="1">decathlon<span class="fl">.1</span><span class="op">$</span>size</a></code></pre></div>
<pre><code>## [1] 6 5 8 1 4</code></pre>
<p>which in this case is cluster 3, and then</p>
<div class="sourceCode" id="cb3933"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3933-1" data-line-number="1">decathlon<span class="fl">.1</span><span class="op">$</span>centers</a></code></pre></div>
<pre><code>##         x100m   long.jump   shot.put     high.jump      x400m
## 1 -0.97448850  0.64184430 -0.1484207 -2.467909e-01 -1.0216857
## 2  0.28457995  0.07871177 -0.8288519  2.326886e-01 -0.1588370
## 3 -0.02051555  0.02245134  0.9034011  2.644188e-01 -0.0589434
## 4  1.55771620 -2.27947172  0.9765949 -1.798048e+00  1.3236413
## 5  0.75760985 -0.53619092 -0.7922550 -1.554312e-15  1.5180512
##       x110mh     discus  pole.vault     javelin     x1500m
## 1 -0.5934385  0.2274805 -0.07779211  0.65707285 -0.9136808
## 2 -0.3582955 -1.0406594  1.17932839  0.06548297 -0.1670467
## 3 -0.3097414  0.6739749 -0.10890895 -0.49565010  0.3441300
## 4  1.1775755 -0.6894704 -1.50916693 -1.43751822 -1.8269002
## 5  1.6631161 -0.2159787 -0.76236268  0.28321676  1.3477946</code></pre>
<p>which says that the eight athletes in cluster 3 are a bit above
average for shot put and discus, and below average for javelin, and,
taking a decision, about average for everything else. This is kind of
odd, since these are all throwing events, but the javelin is propelled
a long way by running fast, and the other two are propelled mainly
using strength rather than speed, so it makes some kind of sense
(after the fact, at least).</p>
<p>My guess is that someone good at javelin is likely to be good at
sprint running and possibly also the long jump, since that depends
primarily on speed, once you have enough technique. Well, one way to
figure out whether I was right:</p>
<div class="sourceCode" id="cb3935"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3935-1" data-line-number="1"><span class="kw">cor</span>(decathlon)</a></code></pre></div>
<pre><code>##                  x100m   long.jump    shot.put   high.jump
## x100m       1.00000000 -0.61351932 -0.17373396 -0.03703619
## long.jump  -0.61351932  1.00000000  0.08369570  0.46379852
## shot.put   -0.17373396  0.08369570  1.00000000  0.02012049
## high.jump  -0.03703619  0.46379852  0.02012049  1.00000000
## x400m       0.78909124 -0.54819716 -0.17251605  0.01521720
## x110mh      0.67372152 -0.39484085 -0.28310469 -0.08356323
## discus     -0.14989960  0.12891051  0.46449586 -0.11770266
## pole.vault -0.12087966  0.21976890 -0.19328449  0.13565269
## javelin     0.02363715  0.01969302 -0.11313467 -0.12454417
## x1500m      0.14913949 -0.11672283 -0.06156793  0.27779220
##                   x400m      x110mh      discus  pole.vault
## x100m       0.789091241  0.67372152 -0.14989960 -0.12087966
## long.jump  -0.548197160 -0.39484085  0.12891051  0.21976890
## shot.put   -0.172516054 -0.28310469  0.46449586 -0.19328449
## high.jump   0.015217204 -0.08356323 -0.11770266  0.13565269
## x400m       1.000000000  0.80285420 -0.06877820 -0.36182359
## x110mh      0.802854203  1.00000000 -0.13777771 -0.51871733
## discus     -0.068778203 -0.13777771  1.00000000 -0.10045072
## pole.vault -0.361823592 -0.51871733 -0.10045072  1.00000000
## javelin    -0.005823468 -0.05246857  0.02097743  0.05237715
## x1500m      0.446949386  0.39800522  0.01989086 -0.05988836
##                 javelin       x1500m
## x100m       0.023637150  0.149139491
## long.jump   0.019693022 -0.116722829
## shot.put   -0.113134672 -0.061567926
## high.jump  -0.124544175  0.277792195
## x400m      -0.005823468  0.446949386
## x110mh     -0.052468568  0.398005215
## discus      0.020977427  0.019890861
## pole.vault  0.052377148 -0.059888360
## javelin     1.000000000 -0.008858031
## x1500m     -0.008858031  1.000000000</code></pre>
<p>or, for this, maybe better:</p>
<div class="sourceCode" id="cb3937"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3937-1" data-line-number="1"><span class="kw">cor</span>(decathlon) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3937-2" data-line-number="2"><span class="st">  </span><span class="kw">as.data.frame</span>() <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3937-3" data-line-number="3"><span class="st">  </span><span class="kw">rownames_to_column</span>(<span class="st">&quot;event&quot;</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3937-4" data-line-number="4"><span class="st">  </span><span class="kw">pivot_longer</span>(<span class="op">-</span>event, <span class="dt">names_to=</span><span class="st">&quot;event2&quot;</span>, <span class="dt">values_to=</span><span class="st">&quot;corr&quot;</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3937-5" data-line-number="5"><span class="st">  </span><span class="kw">filter</span>(event <span class="op">&lt;</span><span class="st"> </span>event2) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3937-6" data-line-number="6"><span class="st">  </span><span class="kw">arrange</span>(<span class="kw">desc</span>(<span class="kw">abs</span>(corr)))</a></code></pre></div>
<pre><code>## # A tibble: 45 x 3
##    event      event2      corr
##    &lt;chr&gt;      &lt;chr&gt;      &lt;dbl&gt;
##  1 x110mh     x400m      0.803
##  2 x100m      x400m      0.789
##  3 x100m      x110mh     0.674
##  4 long.jump  x100m     -0.614
##  5 long.jump  x400m     -0.548
##  6 pole.vault x110mh    -0.519
##  7 discus     shot.put   0.464
##  8 high.jump  long.jump  0.464
##  9 x1500m     x400m      0.447
## 10 x110mh     x1500m     0.398
## # … with 35 more rows</code></pre>
<p>I should probably talk about the code:</p>
<ul>
<li><p>I want to grab the event names from the row names of the
matrix. This is a bit awkward, because I want to turn the matrix
into a data frame, but if I turn it into a <code>tibble</code>, the row
names will disappear.</p></li>
<li><p>Thus, I turn it into an old-fashioned <code>data.frame</code>, and
then it has row names, which I can grab and put into a column called
<code>event</code>.</p></li>
<li><p>Then I make the data frame longer, creating a column
<code>event2</code> which is the second thing that each correlation will
be between.</p></li>
<li><p>The correlations between an event and itself will be 1, and
between events B and A will be the same as between A and B. So I
take only the rows where the first event is alphabetically less than
the second one.</p></li>
<li><p>Then I arrange them in descending order of <em>absolute</em>
correlation, since a large negative correlation is also interesting.</p></li>
</ul>
<p>There are actually only a few high correlations:</p>
<ul>
<li><p>100m with long jump, 400m and 110m hurdles</p></li>
<li><p>long jump with 100m, high jump and 400m</p></li>
<li><p>shot put with discus</p></li>
<li><p>high jump with long jump</p></li>
<li><p>400m with all the other running events plus long jump</p></li>
<li><p>110m hurdles with the other running events plus pole vault</p></li>
<li><p>discus with shot put</p></li>
<li><p>pole vault with 110m hurdles and maybe 400m</p></li>
<li><p>javelin with <em>nothing</em></p></li>
<li><p>1500m with 400m</p></li>
</ul>
<p>Some of the correlations are negative as expected, since they are
between a running event and a jumping/throwing event (that is, a long distance goes with a small time, both of which are good).</p>
<p>I was wrong about javelin. It seems to be a unique skill in the
decathlon, which is presumably why it’s there: you want 10 events that
are as disparate as possible, rather than things that are highly
correlated.</p>
</div>
<div id="bridges-in-pittsburgh" class="section level2">
<h2><span class="header-section-number">26.8</span> Bridges in Pittsburgh</h2>
<p>The city of Pittsburgh, Pennsylvania, lies where three
rivers, the Allegheny, Monongahela, and Ohio,
meet.
<label for="tufte-mn-256" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-256" class="margin-toggle"><span class="marginnote">For a long time, the Pittsburgh Steelers football team played at the Three Rivers Stadium.</span>
It has long been important to build bridges there,
to enable its residents to cross the rivers safely. See
<a href="https://en.wikipedia.org/wiki/List_of_bridges_of_Pittsburgh">link</a> for
a listing (with pictures) of the bridges. The data at
<a href="http://www.utsc.utoronto.ca/~butler/d29/bridges.csv">link</a> contains
detail for a large number of past and present bridges in
Pittsburgh. All the variables we will use are categorical. Here they
are:</p>
<ul>
<li><p><code>id</code> identifying the bridge (we ignore)</p></li>
<li><p><code>river</code>: initial letter of river that the bridge crosses</p></li>
<li><p><code>location</code>: a numerical code indicating the location
within Pittsburgh (we ignore)</p></li>
<li><p><code>erected</code>: time period in which the bridge was built (a
name, from <code>CRAFTS</code>, earliest, to <code>MODERN</code>, most
recent.</p></li>
<li><p><code>purpose</code>: what the bridge carries: foot traffic
(“walk”), water (aqueduct), road or railroad.</p></li>
<li><p><code>length</code> categorized as long, medium or short.</p></li>
<li><p><code>lanes</code> of traffic (or number of railroad tracks): a
number, 1, 2, 4 or 6, that we will count as categorical.</p></li>
<li><p><code>clear_g</code>: whether a vertical navigation requirement was
included in the bridge design (that is, ships of a certain height
had to be able to get under the bridge). I think <code>G</code> means
“yes”.</p></li>
<li><p><code>t_d</code>: method of construction. <code>DECK</code> means the
bridge deck is on top of the construction, <code>THROUGH</code> means
that when you cross the bridge, some of the bridge supports are next
to you or above you.</p></li>
<li><p><code>material</code> the bridge is made of: iron, steel or wood.</p></li>
<li><p><code>span</code>: whether the bridge covers a short, medium or long
distance.</p></li>
<li><p><code>rel_l</code>: Relative length of the main span of the
bridge (between the two central piers) to the total crossing length.
The categories are <code>S</code>, <code>S-F</code> and <code>F</code>. I don’t
know what these mean.</p></li>
<li><p><code>type</code> of bridge: wood, suspension, arch and three types
of truss bridge: cantilever, continuous and simple.</p></li>
</ul>
<p>The website <a href="https://www.steelconstruction.info/Bridges">link</a> is an
excellent source of information about bridges. (That’s where I learned
the difference between <code>THROUGH</code> and <code>DECK</code>.) Wikipedia
also has a good article at
<a href="https://en.wikipedia.org/wiki/Bridge">link</a>. I also found
<a href="http://www.metaeventos.net/inscricoes/formularios_off/resumo_preenchido/DINCON/Pina-A_Colimodio-V_Silva-A_PinaFilho-A.pdf">link</a>
which is the best description I’ve seen of the variables.</p>
<ol style="list-style-type: lower-alpha">
<li>The bridges are stored in CSV format. Some of the
information is not known and was recorded in the spreadsheet as
<code>?</code>. Turn these into genuine missing values by adding
<code>na=&quot;?&quot;</code> to your file-reading command. Display some of your
data, enough to see that you have some missing data.</li>
</ol>
<p>Solution</p>
<p>This sort of thing:</p>
<div class="sourceCode" id="cb3939"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3939-1" data-line-number="1">my_url &lt;-<span class="st"> &quot;http://www.utsc.utoronto.ca/~butler/d29/bridges.csv&quot;</span></a>
<a class="sourceLine" id="cb3939-2" data-line-number="2">bridges0 &lt;-<span class="st"> </span><span class="kw">read_csv</span>(my_url, <span class="dt">na =</span> <span class="st">&quot;?&quot;</span>)</a></code></pre></div>
<pre><code>## Parsed with column specification:
## cols(
##   id = col_character(),
##   river = col_character(),
##   location = col_double(),
##   erected = col_character(),
##   purpose = col_character(),
##   length = col_character(),
##   lanes = col_double(),
##   clear_g = col_character(),
##   t_d = col_character(),
##   material = col_character(),
##   span = col_character(),
##   rel_l = col_character(),
##   type = col_character()
## )</code></pre>
<div class="sourceCode" id="cb3941"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3941-1" data-line-number="1">bridges0</a></code></pre></div>
<pre><code>## # A tibble: 108 x 13
##    id    river location erected purpose length lanes clear_g t_d  
##    &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;
##  1 E1    M            3 CRAFTS  HIGHWAY &lt;NA&gt;       2 N       THRO…
##  2 E2    A           25 CRAFTS  HIGHWAY MEDIUM     2 N       THRO…
##  3 E3    A           39 CRAFTS  AQUEDU… &lt;NA&gt;       1 N       THRO…
##  4 E5    A           29 CRAFTS  HIGHWAY MEDIUM     2 N       THRO…
##  5 E6    M           23 CRAFTS  HIGHWAY &lt;NA&gt;       2 N       THRO…
##  6 E7    A           27 CRAFTS  HIGHWAY SHORT      2 N       THRO…
##  7 E8    A           28 CRAFTS  AQUEDU… MEDIUM     1 N       THRO…
##  8 E9    M            3 CRAFTS  HIGHWAY MEDIUM     2 N       THRO…
##  9 E10   A           39 CRAFTS  AQUEDU… &lt;NA&gt;       1 N       DECK 
## 10 E11   A           29 CRAFTS  HIGHWAY MEDIUM     2 N       THRO…
## # … with 98 more rows, and 4 more variables: material &lt;chr&gt;,
## #   span &lt;chr&gt;, rel_l &lt;chr&gt;, type &lt;chr&gt;</code></pre>
<p>I have some missing values in the <code>length</code> column. (You
sometimes see <code>&lt;NA&gt;</code> instead of <code>NA</code>, as you do here;
this means the missing value is a missing piece of text rather than a
missing number.)
<label for="tufte-mn-257" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-257" class="margin-toggle"><span class="marginnote">Sometimes it’s necessary to distinguish between the different types of missing value; if that’s the case, you can use eg. <em>NA-real-</em> and <em>NA-character-</em> to distinguish missing decimal numbers from missing text. Those dashes should actually be underscores.</span></p>
<p>There are 108 bridges in the data set.</p>
<p>I’m saving the name <code>bridges</code> for my final data set, after I’m
finished organizing it.</p>
<ol start="2" style="list-style-type: lower-alpha">
<li>Verify that there are missing values in this dataset. To see
them, convert the text columns temporarily to <code>factor</code>s using
<code>mutate_if</code>, and pass the resulting data frame into
<code>summary</code>.</li>
</ol>
<p>Solution</p>
<p>I called my data frame <code>bridges0</code>, so this:</p>
<div class="sourceCode" id="cb3943"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3943-1" data-line-number="1">bridges0 <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3943-2" data-line-number="2"><span class="st">  </span><span class="kw">mutate_if</span>(is.character, <span class="op">~</span><span class="st"> </span><span class="kw">factor</span>(.)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3943-3" data-line-number="3"><span class="st">  </span><span class="kw">summary</span>()</a></code></pre></div>
<pre><code>##        id      river     location         erected       purpose  
##  E1     :  1   A:49   Min.   : 1.00   CRAFTS  :18   AQUEDUCT: 4  
##  E10    :  1   M:41   1st Qu.:15.50   EMERGING:15   HIGHWAY :71  
##  E100   :  1   O:15   Median :27.00   MATURE  :54   RR      :32  
##  E101   :  1   Y: 3   Mean   :25.98   MODERN  :21   WALK    : 1  
##  E102   :  1          3rd Qu.:37.50                              
##  E103   :  1          Max.   :52.00                              
##  (Other):102          NA&#39;s   :1                                  
##     length       lanes      clear_g        t_d      material 
##  LONG  :21   Min.   :1.00   G   :80   DECK   :15   IRON :11  
##  MEDIUM:48   1st Qu.:2.00   N   :26   THROUGH:87   STEEL:79  
##  SHORT :12   Median :2.00   NA&#39;s: 2   NA&#39;s   : 6   WOOD :16  
##  NA&#39;s  :27   Mean   :2.63                          NA&#39;s : 2  
##              3rd Qu.:4.00                                    
##              Max.   :6.00                                    
##              NA&#39;s   :16                                      
##      span     rel_l          type   
##  LONG  :30   F   :58   SIMPLE-T:44  
##  MEDIUM:53   S   :30   WOOD    :16  
##  SHORT : 9   S-F :15   ARCH    :13  
##  NA&#39;s  :16   NA&#39;s: 5   CANTILEV:11  
##                        SUSPEN  :11  
##                        (Other) :11  
##                        NA&#39;s    : 2</code></pre>
<p>There are missing values all over the place. <code>length</code> has the
most, but <code>lanes</code> and <code>span</code> also have a fair few.</p>
<p><code>mutate_if</code> requires a logical condition, something that is true or false, about the column and then something to do with it.
In words, “for each column that is text, replace it (temporarily) with the factor version of itself.”</p>
<p>Extra: I think the reason <code>summary</code> doesn’t handle text stuff very
well is that, originally, text columns that were read in from files
<em>got turned into</em> factors, and if you didn’t want that to happen,
you had to explicitly stop it yourself. Try mentioning
<code>stringsAsFactors=F</code> to a veteran R user, and watch their
reaction, or try it yourself by reading in a data file with text
columns using <code>read.table</code> instead of
<code>read_delim</code>. (This will read in an old-fashioned data frame,
so pipe it through <code>as_tibble</code> to see what the columns are.)</p>
<p>When Hadley Wickham designed <code>readr</code>, the corner of the
<code>tidyverse</code> where the <code>read_</code> functions live, he
deliberately chose to keep text as text (on the basis of being honest
about what kind of thing we have), with the result that we sometimes
have to create factors when what we are using requires them rather
than text.</p>
<ol start="3" style="list-style-type: lower-alpha">
<li>Use <code>drop_na</code> to remove any rows of the data frame with missing values in them. How many rows do you have left?</li>
</ol>
<p>Solution</p>
<p>This is as simple as:</p>
<div class="sourceCode" id="cb3945"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3945-1" data-line-number="1">bridges0 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">drop_na</span>() -&gt;<span class="st"> </span>bridges</a>
<a class="sourceLine" id="cb3945-2" data-line-number="2">bridges</a></code></pre></div>
<pre><code>## # A tibble: 70 x 13
##    id    river location erected purpose length lanes clear_g t_d  
##    &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;
##  1 E2    A           25 CRAFTS  HIGHWAY MEDIUM     2 N       THRO…
##  2 E5    A           29 CRAFTS  HIGHWAY MEDIUM     2 N       THRO…
##  3 E7    A           27 CRAFTS  HIGHWAY SHORT      2 N       THRO…
##  4 E8    A           28 CRAFTS  AQUEDU… MEDIUM     1 N       THRO…
##  5 E9    M            3 CRAFTS  HIGHWAY MEDIUM     2 N       THRO…
##  6 E11   A           29 CRAFTS  HIGHWAY MEDIUM     2 N       THRO…
##  7 E14   M            6 CRAFTS  HIGHWAY MEDIUM     2 N       THRO…
##  8 E16   A           25 CRAFTS  HIGHWAY MEDIUM     2 N       THRO…
##  9 E18   A           28 CRAFTS  RR      MEDIUM     2 N       THRO…
## 10 E19   A           29 CRAFTS  HIGHWAY MEDIUM     2 N       THRO…
## # … with 60 more rows, and 4 more variables: material &lt;chr&gt;,
## #   span &lt;chr&gt;, rel_l &lt;chr&gt;, type &lt;chr&gt;</code></pre>
<p>I have 70 rows left (out of the original 108).</p>
<ol start="4" style="list-style-type: lower-alpha">
<li>We are going to assess the dissimilarity between two bridges
by the number of the categorical variables they <em>disagree</em>
on. This is called a “simple matching coefficient”, and is the
same thing we did in the question about clustering fruits based on
their properties. This time, though, we want to count matches in
things that are <em>rows</em> of our data frame (properties of two
different bridges), so we will need to use a strategy like the one I
used in calculating the Bray-Curtis distances.
First, write a function that takes as input two vectors <code>v</code>
and <code>w</code> and counts the number of their entries that differ
(comparing the first with the first, the second with the second,
, the last with the last. I can think of a quick way and a
slow way, but either way is good.) To test your function, create two
vectors (using <code>c</code>) of the same length, and see whether it
correctly counts the number of corresponding values that are
different.</li>
</ol>
<p>Solution</p>
<p>The slow way is to loop through the elements of each vector, using
square brackets to pull out the ones you want, checking them for
differentness, then updating a counter which gets returned at the
end. If you’ve done Python, this is exactly the strategy you’d
use there:</p>
<div class="sourceCode" id="cb3947"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3947-1" data-line-number="1">count_diff &lt;-<span class="st"> </span><span class="cf">function</span>(v, w) {</a>
<a class="sourceLine" id="cb3947-2" data-line-number="2">  n &lt;-<span class="st"> </span><span class="kw">length</span>(v)</a>
<a class="sourceLine" id="cb3947-3" data-line-number="3">  <span class="kw">stopifnot</span>(<span class="kw">length</span>(v) <span class="op">==</span><span class="st"> </span><span class="kw">length</span>(w)) <span class="co"># I explain this below</span></a>
<a class="sourceLine" id="cb3947-4" data-line-number="4">  count &lt;-<span class="st"> </span><span class="dv">0</span></a>
<a class="sourceLine" id="cb3947-5" data-line-number="5">  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n) {</a>
<a class="sourceLine" id="cb3947-6" data-line-number="6">    <span class="cf">if</span> (v[i] <span class="op">!=</span><span class="st"> </span>w[i]) count &lt;-<span class="st"> </span>count <span class="op">+</span><span class="st"> </span><span class="dv">1</span></a>
<a class="sourceLine" id="cb3947-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb3947-8" data-line-number="8">  count</a>
<a class="sourceLine" id="cb3947-9" data-line-number="9">}</a></code></pre></div>
<p>This function makes no sense if <code>v</code> and <code>w</code> are of
different lengths, since we’re comparing <em>corresponding</em> elements
of them. The <code>stopifnot</code> line checks to see whether <code>v</code>
and <code>w</code> have the same number of things in them, and stops with
an informative error if they are of different lengths. (The thing
inside the <code>stopifnot</code> is what has to be <em>true</em>.)</p>
<p>Does it work?</p>
<div class="sourceCode" id="cb3948"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3948-1" data-line-number="1">v &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb3948-2" data-line-number="2">w &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb3948-3" data-line-number="3"><span class="kw">count_diff</span>(v, w)</a></code></pre></div>
<pre><code>## [1] 2</code></pre>
<p>Three of the values are the same and two are different, so this is right.</p>
<p>What happens if my two vectors are of different lengths?</p>
<div class="sourceCode" id="cb3950"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3950-1" data-line-number="1">v1 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb3950-2" data-line-number="2">w &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb3950-3" data-line-number="3"><span class="kw">count_diff</span>(v1, w)</a></code></pre></div>
<pre><code>## Error in count_diff(v1, w): length(v) == length(w) is not TRUE</code></pre>
<p>Error, as produced by <code>stopifnot</code>. See how it’s perfectly clear
what went wrong?</p>
<p>R, though, is a “vectorized” language: it’s possible to work with
whole vectors at once, rather than pulling things out of them one at a
time. Check out this (which is like what I did with the fruits):</p>
<div class="sourceCode" id="cb3952"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3952-1" data-line-number="1">v <span class="op">!=</span><span class="st"> </span>w</a></code></pre></div>
<pre><code>## [1] FALSE  TRUE FALSE  TRUE FALSE</code></pre>
<p>The second and fourth values are different, and the others are the
same. But we can go one step further:</p>
<div class="sourceCode" id="cb3954"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3954-1" data-line-number="1"><span class="kw">sum</span>(v <span class="op">!=</span><span class="st"> </span>w)</a></code></pre></div>
<pre><code>## [1] 2</code></pre>
<p>The true values count as 1 and the false ones as zero, so the sum is
counting up how many values are different, exactly what we want. So
the function can be as simple as:</p>
<div class="sourceCode" id="cb3956"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3956-1" data-line-number="1">count_diff &lt;-<span class="st"> </span><span class="cf">function</span>(v, w) {</a>
<a class="sourceLine" id="cb3956-2" data-line-number="2">  <span class="kw">sum</span>(v <span class="op">!=</span><span class="st"> </span>w)</a>
<a class="sourceLine" id="cb3956-3" data-line-number="3">}</a></code></pre></div>
<p>I still think it’s worth writing a function do this, though, since
<code>count_diff</code> tells you what it does and <code>sum(v!=w)</code>
doesn’t, unless you happen to know.</p>
<ol start="5" style="list-style-type: lower-alpha">
<li>Write a function that has as input two row numbers and a data
frame to take those rows from. The function needs to select all the
columns except for <code>id</code> and <code>location</code>, select the
rows required one at a time, and turn them into vectors. (There may
be some repetitiousness here. That’s OK.) Then those two vectors
are passed into the function you wrote in the previous part, and the
count of the number of differences is returned. This is like the
code in the Bray-Curtis problem. Test your function on rows 3 and 4
of your bridges data set (with the missings removed). There should
be six variables that are different.</li>
</ol>
<p>Solution</p>
<p>This is just like my function <code>braycurtis.spec</code>, except that
instead of calling <code>braycurtis</code> at the end, I call
<code>count_diff</code>:</p>
<div class="sourceCode" id="cb3957"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3957-1" data-line-number="1">row_diff &lt;-<span class="st"> </span><span class="cf">function</span>(i, j, d) {</a>
<a class="sourceLine" id="cb3957-2" data-line-number="2">  d1 &lt;-<span class="st"> </span>d <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(<span class="op">-</span>id, <span class="op">-</span>location)</a>
<a class="sourceLine" id="cb3957-3" data-line-number="3">  x &lt;-<span class="st"> </span>d1 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">slice</span>(i) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">unlist</span>()</a>
<a class="sourceLine" id="cb3957-4" data-line-number="4">  y &lt;-<span class="st"> </span>d1 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">slice</span>(j) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">unlist</span>()</a>
<a class="sourceLine" id="cb3957-5" data-line-number="5">  <span class="kw">count_diff</span>(x, y)</a>
<a class="sourceLine" id="cb3957-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb3957-7" data-line-number="7"><span class="kw">row_diff</span>(<span class="dv">3</span>, <span class="dv">4</span>, bridges)</a></code></pre></div>
<pre><code>## [1] 6</code></pre>
<p>That’s what I said.</p>
<p>Extra: is that right, though? Let’s print out those rows and count:</p>
<div class="sourceCode" id="cb3959"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3959-1" data-line-number="1">bridges <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">slice</span>(<span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">4</span>)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">print</span>(<span class="dt">width =</span> <span class="ot">Inf</span>)</a></code></pre></div>
<pre><code>## # A tibble: 2 x 13
##   id    river location erected purpose  length lanes clear_g t_d    
##   &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;    &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;  
## 1 E7    A           27 CRAFTS  HIGHWAY  SHORT      2 N       THROUGH
## 2 E8    A           28 CRAFTS  AQUEDUCT MEDIUM     1 N       THROUGH
##   material span   rel_l type  
##   &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt; 
## 1 WOOD     MEDIUM S     WOOD  
## 2 IRON     SHORT  S     SUSPEN</code></pre>
<p>Out of the ones we’re counting, I see differences in purpose, length,
lanes, material, span and type. Six.</p>
<p>I actually think the <code>unlist</code> is not needed:</p>
<div class="sourceCode" id="cb3961"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3961-1" data-line-number="1">row_diff2 &lt;-<span class="st"> </span><span class="cf">function</span>(i, j, d) {</a>
<a class="sourceLine" id="cb3961-2" data-line-number="2">  d1 &lt;-<span class="st"> </span>d <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(<span class="op">-</span>id, <span class="op">-</span>location)</a>
<a class="sourceLine" id="cb3961-3" data-line-number="3">  x &lt;-<span class="st"> </span>d1 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">slice</span>(i)</a>
<a class="sourceLine" id="cb3961-4" data-line-number="4">  y &lt;-<span class="st"> </span>d1 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">slice</span>(j)</a>
<a class="sourceLine" id="cb3961-5" data-line-number="5">  <span class="kw">count_diff</span>(x, y)</a>
<a class="sourceLine" id="cb3961-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb3961-7" data-line-number="7"><span class="kw">row_diff2</span>(<span class="dv">3</span>, <span class="dv">4</span>, bridges)</a></code></pre></div>
<pre><code>## [1] 6</code></pre>
<p>Here, <code>x</code> and <code>y</code> are one-row data frames, but R (via
<code>count_diff</code>) is sufficiently flexible to be able to cope with
these rather than vectors (it checks “corresponding elements” of
<code>x</code> and <code>y</code> for differentness). To my mind, though,
having the <code>unlist</code> in is clearer, since it makes it
unambiguous that <code>x</code> and <code>y</code> are vectors, and we know
that <code>count_diff</code> works for vectors since that’s what we
tested it with.</p>
<ol start="6" style="list-style-type: lower-alpha">
<li>Create a matrix or data frame of pairwise dissimilarities
between each pair of bridges (using only the ones with no missing
values). Use loops, or <code>crossing</code> and <code>map2_int</code>, as
you prefer. Display the first six rows of
your matrix (using <code>head</code>) or the first few rows of your data
frame. (The whole thing is big, so don’t display it all.)</li>
</ol>
<p>Solution</p>
<p>First thing, either way, is to find out how many bridges we have left:</p>
<div class="sourceCode" id="cb3963"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3963-1" data-line-number="1">bridges</a></code></pre></div>
<pre><code>## # A tibble: 70 x 13
##    id    river location erected purpose length lanes clear_g t_d  
##    &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;
##  1 E2    A           25 CRAFTS  HIGHWAY MEDIUM     2 N       THRO…
##  2 E5    A           29 CRAFTS  HIGHWAY MEDIUM     2 N       THRO…
##  3 E7    A           27 CRAFTS  HIGHWAY SHORT      2 N       THRO…
##  4 E8    A           28 CRAFTS  AQUEDU… MEDIUM     1 N       THRO…
##  5 E9    M            3 CRAFTS  HIGHWAY MEDIUM     2 N       THRO…
##  6 E11   A           29 CRAFTS  HIGHWAY MEDIUM     2 N       THRO…
##  7 E14   M            6 CRAFTS  HIGHWAY MEDIUM     2 N       THRO…
##  8 E16   A           25 CRAFTS  HIGHWAY MEDIUM     2 N       THRO…
##  9 E18   A           28 CRAFTS  RR      MEDIUM     2 N       THRO…
## 10 E19   A           29 CRAFTS  HIGHWAY MEDIUM     2 N       THRO…
## # … with 60 more rows, and 4 more variables: material &lt;chr&gt;,
## #   span &lt;chr&gt;, rel_l &lt;chr&gt;, type &lt;chr&gt;</code></pre>
<ol start="70" style="list-style-type: decimal">
<li>So the loops (and the <code>crossing</code>) will go up to 70. Loops first:</li>
</ol>
<div class="sourceCode" id="cb3965"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3965-1" data-line-number="1">m &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">70</span>, <span class="dv">70</span>)</a>
<a class="sourceLine" id="cb3965-2" data-line-number="2"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">70</span>) {</a>
<a class="sourceLine" id="cb3965-3" data-line-number="3">  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">70</span>) {</a>
<a class="sourceLine" id="cb3965-4" data-line-number="4">    m[i, j] &lt;-<span class="st"> </span><span class="kw">row_diff</span>(i, j, bridges)</a>
<a class="sourceLine" id="cb3965-5" data-line-number="5">  }</a>
<a class="sourceLine" id="cb3965-6" data-line-number="6">}</a></code></pre></div>
<p>Even just the top six rows (of all 70 columns) takes up a lot of
space. The grader will only check that it looks about right:</p>
<div class="sourceCode" id="cb3966"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3966-1" data-line-number="1"><span class="kw">head</span>(m)</a></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
## [1,]    0    0    2    4    3    1    2    4    3     1     2     3
## [2,]    0    0    2    4    3    1    2    4    3     1     2     3
## [3,]    2    2    0    6    5    1    2    4    5     1     2     5
## [4,]    4    4    6    0    3    5    6    4    3     5     6     6
## [5,]    3    3    5    3    0    4    3    3    3     4     5     6
## [6,]    1    1    1    5    4    0    1    3    4     0     1     4
##      [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22]
## [1,]     7     6     7     9     6     7     3     8     7     9
## [2,]     7     6     7     9     6     7     3     8     7     9
## [3,]     7     6     7     9     6     7     5     8     8     9
## [4,]     8     8     8    10     8     8     3    10     9    10
## [5,]     6     5     6     9     7     6     6     7     6    10
## [6,]     6     5     6     9     5     6     4     8     7     9
##      [,23] [,24] [,25] [,26] [,27] [,28] [,29] [,30] [,31] [,32]
## [1,]     8     6     7     6     7     7     8     8     9     6
## [2,]     8     6     7     6     7     7     8     8     9     6
## [3,]     7     6     6     6     7     6     8     8     7     7
## [4,]     9     8     9     8     8     8     9     9     9     8
## [5,]     7     7     8     7     6     8     7     7    10     7
## [6,]     7     5     6     5     6     6     7     7     8     6
##      [,33] [,34] [,35] [,36] [,37] [,38] [,39] [,40] [,41] [,42]
## [1,]     8     7     9     7     8     8     8     7     8     8
## [2,]     8     7     9     7     8     8     8     7     8     8
## [3,]     9     8     9     8     8     7     6     6     6     6
## [4,]     9     9    10     8     9     9     9     8     8     8
## [5,]     8     7     9     8     9     9     9     8     8     8
## [6,]     8     7     9     7     8     7     7     6     7     7
##      [,43] [,44] [,45] [,46] [,47] [,48] [,49] [,50] [,51] [,52]
## [1,]     7     9     8     9     9     8     7     8     7     8
## [2,]     7     9     8     9     9     8     7     8     7     8
## [3,]     8     8     9     8     8     6     6     9     8     9
## [4,]     9    10     9    10    11     8     9     9     8     8
## [5,]     7     8     7    10     8     8     6     8     7     6
## [6,]     7     8     8     8     8     7     6     8     7     8
##      [,53] [,54] [,55] [,56] [,57] [,58] [,59] [,60] [,61] [,62]
## [1,]     8     8     8     8     6     8     7     9    10     8
## [2,]     8     8     8     8     6     8     7     9    10     8
## [3,]     9     8     8     6     6     8     7     7    10     9
## [4,]     9     9     9     9     8    10     9    10    11     9
## [5,]     7     9     9     9     7     8     6     8     9     7
## [6,]     8     7     7     7     5     8     6     8    10     8
##      [,63] [,64] [,65] [,66] [,67] [,68] [,69] [,70]
## [1,]     8     7     8     9    10     8     9     9
## [2,]     8     7     8     9    10     8     9     9
## [3,]     8     8     9     7    10     6     9     8
## [4,]     9     9     9    10    11     9    10    10
## [5,]     9     7     7    10     9     9     9     8
## [6,]     8     7     8     8    10     7     9     9</code></pre>
<p>A cursory glance at this shows that the bridges in the small-numbered
rows of the data frame are similar to each other and different from
the others. This suggests that these small-numbered bridges will end
up in the same cluster (later).</p>
<p>The <code>tidyverse</code> way is really similar in conception. First use
<code>crossing</code> to create all combinations of <code>i</code> and <code>j</code>:</p>
<div class="sourceCode" id="cb3968"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3968-1" data-line-number="1">mm &lt;-<span class="st"> </span><span class="kw">crossing</span>(<span class="dt">i =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">70</span>, <span class="dt">j =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">70</span>)</a></code></pre></div>
<p>and then use <code>map2_int</code> (since our dissimilarity function
returns a whole number):</p>
<div class="sourceCode" id="cb3969"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3969-1" data-line-number="1">mm &lt;-<span class="st"> </span>mm <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(<span class="dt">diff =</span> <span class="kw">map2_int</span>(i, j, row_diff, bridges))</a>
<a class="sourceLine" id="cb3969-2" data-line-number="2">mm</a></code></pre></div>
<pre><code>## # A tibble: 4,900 x 3
##        i     j  diff
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;
##  1     1     1     0
##  2     1     2     0
##  3     1     3     2
##  4     1     4     4
##  5     1     5     3
##  6     1     6     1
##  7     1     7     2
##  8     1     8     4
##  9     1     9     3
## 10     1    10     1
## # … with 4,890 more rows</code></pre>
<p>This is long format, though, so we need to <code>pivot_wider</code> the
<code>j</code> column to get a square array of dissimilarities:</p>
<div class="sourceCode" id="cb3971"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3971-1" data-line-number="1">mm &lt;-<span class="st"> </span>mm <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pivot_wider</span>(<span class="dt">names_from=</span>j, <span class="dt">values_from=</span>diff)</a>
<a class="sourceLine" id="cb3971-2" data-line-number="2">mm</a></code></pre></div>
<pre><code>## # A tibble: 70 x 71
##        i   `1`   `2`   `3`   `4`   `5`   `6`   `7`   `8`   `9`  `10`
##    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
##  1     1     0     0     2     4     3     1     2     4     3     1
##  2     2     0     0     2     4     3     1     2     4     3     1
##  3     3     2     2     0     6     5     1     2     4     5     1
##  4     4     4     4     6     0     3     5     6     4     3     5
##  5     5     3     3     5     3     0     4     3     3     3     4
##  6     6     1     1     1     5     4     0     1     3     4     0
##  7     7     2     2     2     6     3     1     0     4     5     1
##  8     8     4     4     4     4     3     3     4     0     4     3
##  9     9     3     3     5     3     3     4     5     4     0     4
## 10    10     1     1     1     5     4     0     1     3     4     0
## # … with 60 more rows, and 60 more variables: `11` &lt;int&gt;, `12` &lt;int&gt;,
## #   `13` &lt;int&gt;, `14` &lt;int&gt;, `15` &lt;int&gt;, `16` &lt;int&gt;, `17` &lt;int&gt;,
## #   `18` &lt;int&gt;, `19` &lt;int&gt;, `20` &lt;int&gt;, `21` &lt;int&gt;, `22` &lt;int&gt;,
## #   `23` &lt;int&gt;, `24` &lt;int&gt;, `25` &lt;int&gt;, `26` &lt;int&gt;, `27` &lt;int&gt;,
## #   `28` &lt;int&gt;, `29` &lt;int&gt;, `30` &lt;int&gt;, `31` &lt;int&gt;, `32` &lt;int&gt;,
## #   `33` &lt;int&gt;, `34` &lt;int&gt;, `35` &lt;int&gt;, `36` &lt;int&gt;, `37` &lt;int&gt;,
## #   `38` &lt;int&gt;, `39` &lt;int&gt;, `40` &lt;int&gt;, `41` &lt;int&gt;, `42` &lt;int&gt;,
## #   `43` &lt;int&gt;, `44` &lt;int&gt;, `45` &lt;int&gt;, `46` &lt;int&gt;, `47` &lt;int&gt;,
## #   `48` &lt;int&gt;, `49` &lt;int&gt;, `50` &lt;int&gt;, `51` &lt;int&gt;, `52` &lt;int&gt;,
## #   `53` &lt;int&gt;, `54` &lt;int&gt;, `55` &lt;int&gt;, `56` &lt;int&gt;, `57` &lt;int&gt;,
## #   `58` &lt;int&gt;, `59` &lt;int&gt;, `60` &lt;int&gt;, `61` &lt;int&gt;, `62` &lt;int&gt;,
## #   `63` &lt;int&gt;, `64` &lt;int&gt;, `65` &lt;int&gt;, `66` &lt;int&gt;, `67` &lt;int&gt;,
## #   `68` &lt;int&gt;, `69` &lt;int&gt;, `70` &lt;int&gt;</code></pre>
<p>This shows what we found before, that bridges 3 and 4 differ on 6
variables.</p>
<ol start="7" style="list-style-type: lower-alpha">
<li>Turn your matrix or data frame into a <code>dist</code>
object. (If you couldn’t create a matrix or data frame of
dissimilarities, read them in from
<a href="http://www.utsc.utoronto.ca/~butler/d29/mm.csv">link</a>.) Do not
display your distance object.</li>
</ol>
<p>Solution</p>
<p>The only tricky thing is that the data frame that I called
<code>mm</code> has an extra column called <code>i</code> that needs to be
removed first. This also applies if you need to read it in from
the file. Thus:</p>
<div class="sourceCode" id="cb3973"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3973-1" data-line-number="1">d1 &lt;-<span class="st"> </span><span class="kw">as.dist</span>(m)</a></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb3974"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3974-1" data-line-number="1">d2 &lt;-<span class="st"> </span>mm <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(<span class="op">-</span>i) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">as.dist</span>()</a></code></pre></div>
<p>or, if you got stuck,</p>
<div class="sourceCode" id="cb3975"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3975-1" data-line-number="1">my_url &lt;-<span class="st"> &quot;http://www.utsc.utoronto.ca/~butler/d29/mm.csv&quot;</span></a>
<a class="sourceLine" id="cb3975-2" data-line-number="2">mmm &lt;-<span class="st"> </span><span class="kw">read_csv</span>(my_url)</a></code></pre></div>
<pre><code>## Parsed with column specification:
## cols(
##   .default = col_double()
## )</code></pre>
<pre><code>## See spec(...) for full column specifications.</code></pre>
<div class="sourceCode" id="cb3978"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3978-1" data-line-number="1">mmm</a></code></pre></div>
<pre><code>## # A tibble: 70 x 71
##        i   `1`   `2`   `3`   `4`   `5`   `6`   `7`   `8`   `9`  `10`
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1     1     0     0     2     4     3     1     2     4     3     1
##  2     2     0     0     2     4     3     1     2     4     3     1
##  3     3     2     2     0     6     5     1     2     4     5     1
##  4     4     4     4     6     0     3     5     6     4     3     5
##  5     5     3     3     5     3     0     4     3     3     3     4
##  6     6     1     1     1     5     4     0     1     3     4     0
##  7     7     2     2     2     6     3     1     0     4     5     1
##  8     8     4     4     4     4     3     3     4     0     4     3
##  9     9     3     3     5     3     3     4     5     4     0     4
## 10    10     1     1     1     5     4     0     1     3     4     0
## # … with 60 more rows, and 60 more variables: `11` &lt;dbl&gt;, `12` &lt;dbl&gt;,
## #   `13` &lt;dbl&gt;, `14` &lt;dbl&gt;, `15` &lt;dbl&gt;, `16` &lt;dbl&gt;, `17` &lt;dbl&gt;,
## #   `18` &lt;dbl&gt;, `19` &lt;dbl&gt;, `20` &lt;dbl&gt;, `21` &lt;dbl&gt;, `22` &lt;dbl&gt;,
## #   `23` &lt;dbl&gt;, `24` &lt;dbl&gt;, `25` &lt;dbl&gt;, `26` &lt;dbl&gt;, `27` &lt;dbl&gt;,
## #   `28` &lt;dbl&gt;, `29` &lt;dbl&gt;, `30` &lt;dbl&gt;, `31` &lt;dbl&gt;, `32` &lt;dbl&gt;,
## #   `33` &lt;dbl&gt;, `34` &lt;dbl&gt;, `35` &lt;dbl&gt;, `36` &lt;dbl&gt;, `37` &lt;dbl&gt;,
## #   `38` &lt;dbl&gt;, `39` &lt;dbl&gt;, `40` &lt;dbl&gt;, `41` &lt;dbl&gt;, `42` &lt;dbl&gt;,
## #   `43` &lt;dbl&gt;, `44` &lt;dbl&gt;, `45` &lt;dbl&gt;, `46` &lt;dbl&gt;, `47` &lt;dbl&gt;,
## #   `48` &lt;dbl&gt;, `49` &lt;dbl&gt;, `50` &lt;dbl&gt;, `51` &lt;dbl&gt;, `52` &lt;dbl&gt;,
## #   `53` &lt;dbl&gt;, `54` &lt;dbl&gt;, `55` &lt;dbl&gt;, `56` &lt;dbl&gt;, `57` &lt;dbl&gt;,
## #   `58` &lt;dbl&gt;, `59` &lt;dbl&gt;, `60` &lt;dbl&gt;, `61` &lt;dbl&gt;, `62` &lt;dbl&gt;,
## #   `63` &lt;dbl&gt;, `64` &lt;dbl&gt;, `65` &lt;dbl&gt;, `66` &lt;dbl&gt;, `67` &lt;dbl&gt;,
## #   `68` &lt;dbl&gt;, `69` &lt;dbl&gt;, `70` &lt;dbl&gt;</code></pre>
<div class="sourceCode" id="cb3980"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3980-1" data-line-number="1">d3 &lt;-<span class="st"> </span>mmm <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(<span class="op">-</span>i) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">as.dist</span>()</a></code></pre></div>
<ol start="8" style="list-style-type: lower-alpha">
<li>Run a cluster analysis using Ward’s method, and display a
dendrogram. The labels for the bridges (rows of the data frame) may
come out too big; experiment with a <code>cex</code> less than 1 on the
plot so that you can see them.</li>
</ol>
<p>Solution</p>
<p>Home stretch now. I found that <code>cex=0.3</code> was good for me, though I had to enlarge the graph to see the bridge numbers:</p>
<div class="sourceCode" id="cb3981"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3981-1" data-line-number="1">bridges<span class="fl">.1</span> &lt;-<span class="st"> </span><span class="kw">hclust</span>(d1, <span class="dt">method =</span> <span class="st">&quot;ward.D&quot;</span>)</a>
<a class="sourceLine" id="cb3981-2" data-line-number="2"><span class="kw">plot</span>(bridges<span class="fl">.1</span>, <span class="dt">cex =</span> <span class="fl">0.3</span>)</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/unnamed-chunk-173-1.png" width="672"  /></p>
<p><code>cex</code> stands for “character expansion”. This is one of the
myriad of things you could adjust on the old base graphics (of which
this is an example). If you wanted to make text <em>bigger</em>, you’d
set <code>cex</code> to a value bigger than 1.</p>
<ol style="list-style-type: lower-roman">
<li>How many clusters do you think is reasonable for these
data? Draw them on your plot.</li>
</ol>
<p>Solution</p>
<p>I think you could go with any number from about 3 to something
like 15, but my choice is 5. What you want is for the bridges
within a cluster to be similar and bridges in different clusters
to be different, however you judge that.</p>
<div class="sourceCode" id="cb3982"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3982-1" data-line-number="1"><span class="kw">plot</span>(bridges<span class="fl">.1</span>, <span class="dt">cex =</span> <span class="fl">0.3</span>)</a>
<a class="sourceLine" id="cb3982-2" data-line-number="2"><span class="kw">rect.hclust</span>(bridges<span class="fl">.1</span>, <span class="dv">5</span>)</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/unnamed-chunk-174-1.png" width="672"  /></p>
<p>Whatever number of clusters you go with, draw a corresponding number
of red rectangles.</p>
<p>Note that the low-numbered bridges are all in my first cluster, as I
suspected they would be.</p>
<ol start="10" style="list-style-type: lower-alpha">
<li>Pick three bridges in the same one of your clusters (it
doesn’t matter which three bridges or which cluster). Display the
data for these bridges. Does it make sense that these three bridges
ended up in the same cluster? Explain briefly.</li>
</ol>
<p>Solution</p>
<p>What I want you to do is to display the data for your chosen three
bridges and make the case that they are “similar”. I’m picking
41, 42 and 48 from my third cluster. On yours, scroll right to see the other variables.</p>
<div class="sourceCode" id="cb3983"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3983-1" data-line-number="1">bridges <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">slice</span>(<span class="kw">c</span>(<span class="dv">41</span>, <span class="dv">42</span>, <span class="dv">48</span>))</a></code></pre></div>
<pre><code>## # A tibble: 3 x 13
##   id    river location erected purpose length lanes clear_g t_d  
##   &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;
## 1 E70   A           27 MATURE  HIGHWAY SHORT      4 G       THRO…
## 2 E69   A           26 MATURE  HIGHWAY SHORT      4 G       THRO…
## 3 E71   A           25 MATURE  HIGHWAY SHORT      4 G       THRO…
## # … with 4 more variables: material &lt;chr&gt;, span &lt;chr&gt;, rel_l &lt;chr&gt;,
## #   type &lt;chr&gt;</code></pre>
<p>These bridges are identical on everything except location (which we
weren’t considering anyway). So it makes perfect sense that they would
be in the same cluster.</p>
<p>You might not have been so lucky, for example, 10, 12 and 19, which
got joined together further up:</p>
<div class="sourceCode" id="cb3985"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3985-1" data-line-number="1">bridges <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">slice</span>(<span class="kw">c</span>(<span class="dv">10</span>, <span class="dv">12</span>, <span class="dv">19</span>))</a></code></pre></div>
<pre><code>## # A tibble: 3 x 13
##   id    river location erected purpose length lanes clear_g t_d  
##   &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;
## 1 E19   A           29 CRAFTS  HIGHWAY MEDIUM     2 N       THRO…
## 2 E22   A           24 EMERGI… HIGHWAY MEDIUM     4 G       THRO…
## 3 E4    A           27 MATURE  AQUEDU… MEDIUM     1 N       THRO…
## # … with 4 more variables: material &lt;chr&gt;, span &lt;chr&gt;, rel_l &lt;chr&gt;,
## #   type &lt;chr&gt;</code></pre>
<p>These differ on 3 or 4 variables and are the same on all the others,
so you can certainly say that they are more alike than different.</p>
<p>Extra: to get a feel for how different they might be, let’s compare
three bridges in different clusters:</p>
<div class="sourceCode" id="cb3987"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3987-1" data-line-number="1">bridges <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">slice</span>(<span class="kw">c</span>(<span class="dv">8</span>, <span class="dv">24</span>, <span class="dv">52</span>))</a></code></pre></div>
<pre><code>## # A tibble: 3 x 13
##   id    river location erected purpose length lanes clear_g t_d  
##   &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;
## 1 E16   A           25 CRAFTS  HIGHWAY MEDIUM     2 N       THRO…
## 2 E58   A           33 MATURE  HIGHWAY MEDIUM     2 G       THRO…
## 3 E76   M            6 MATURE  HIGHWAY MEDIUM     4 G       THRO…
## # … with 4 more variables: material &lt;chr&gt;, span &lt;chr&gt;, rel_l &lt;chr&gt;,
## #   type &lt;chr&gt;</code></pre>
<p>These are not as different as I was expecting, but they are indeed
different on more of the variables.</p>
<p>It would be interesting to plot these bridges on a map of Pittsburgh,
colour-coded by which cluster they are in. This might give us some
insight about how bridges are alike or different.</p>
<p>I also remark that the discriminant analysis idea, using the clusters
as known groups, would not work here because we don’t have any
quantitative variables to use for the discriminant analysis.</p>
<p>The most interesting way I can think of is to cross-classify the
bridges by cluster and values of the other variables. These would be
complicated multi-way tables, though, which makes me wonder whether a
“classification tree” like <code>rpart</code> would be worth thinking
about.</p>
<p>I am curious enough to have a crack at this. First we need a data set
with the clusters in it. I’m going with my 5 clusters:</p>
<div class="sourceCode" id="cb3989"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3989-1" data-line-number="1">bridges.rpart &lt;-<span class="st"> </span>bridges <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(<span class="dt">cluster =</span> <span class="kw">cutree</span>(bridges<span class="fl">.1</span>, <span class="dv">5</span>))</a></code></pre></div>
<p>and then</p>
<div class="sourceCode" id="cb3990"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3990-1" data-line-number="1"><span class="kw">library</span>(rpart)</a></code></pre></div>
<pre><code>## Warning: `quo_expr()` is deprecated as of rlang 0.2.0.
## Please use `quo_squash()` instead.
## This warning is displayed once per session.</code></pre>
<div class="sourceCode" id="cb3992"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3992-1" data-line-number="1">bridges.tree &lt;-<span class="st"> </span><span class="kw">rpart</span>(<span class="kw">factor</span>(cluster) <span class="op">~</span><span class="st"> </span>river <span class="op">+</span><span class="st"> </span>erected <span class="op">+</span><span class="st"> </span>purpose <span class="op">+</span><span class="st"> </span>length <span class="op">+</span><span class="st"> </span>lanes <span class="op">+</span><span class="st"> </span>clear_g <span class="op">+</span></a>
<a class="sourceLine" id="cb3992-2" data-line-number="2"><span class="st">  </span>t_d <span class="op">+</span><span class="st"> </span>material <span class="op">+</span><span class="st"> </span>span <span class="op">+</span><span class="st"> </span>rel_l <span class="op">+</span><span class="st"> </span>type, <span class="dt">data =</span> bridges.rpart, <span class="dt">method =</span> <span class="st">&quot;class&quot;</span>)</a>
<a class="sourceLine" id="cb3992-3" data-line-number="3"><span class="kw">print</span>(bridges.tree)</a></code></pre></div>
<pre><code>## n= 70 
## 
## node), split, n, loss, yval, (yprob)
##       * denotes terminal node
## 
##  1) root 70 47 3 (0.19 0.16 0.33 0.2 0.13)  
##    2) span=MEDIUM,SHORT 45 31 4 (0.29 0.24 0.044 0.31 0.11)  
##      4) material=IRON,WOOD 13  0 1 (1 0 0 0 0) *
##      5) material=STEEL 32 18 4 (0 0.34 0.062 0.44 0.16)  
##       10) river=M 13  3 2 (0 0.77 0.077 0 0.15) *
##       11) river=A 19  5 4 (0 0.053 0.053 0.74 0.16) *
##    3) span=LONG 25  4 3 (0 0 0.84 0 0.16)  
##      6) type=ARCH,CANTILEV,SIMPLE-T 18  0 3 (0 0 1 0 0) *
##      7) type=CONT-T,SUSPEN 7  3 5 (0 0 0.43 0 0.57) *</code></pre>
<p>This takes some making sense of, so let’s grab a couple of bridges to
predict the cluster of:</p>
<div class="sourceCode" id="cb3994"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3994-1" data-line-number="1">bridges.rpart <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">slice</span>(<span class="kw">c</span>(<span class="dv">20</span>, <span class="dv">29</span>)) </a></code></pre></div>
<pre><code>## # A tibble: 2 x 14
##   id    river location erected purpose length lanes clear_g t_d  
##   &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;
## 1 E42   M            9 MATURE  HIGHWAY LONG       2 G       THRO…
## 2 E51   M            6 MATURE  RR      MEDIUM     2 G       THRO…
## # … with 5 more variables: material &lt;chr&gt;, span &lt;chr&gt;, rel_l &lt;chr&gt;,
## #   type &lt;chr&gt;, cluster &lt;int&gt;</code></pre>
<p>Let’s start with bridge 20 (with ID E42). The line in the printed
output marked 1 and “root” says that there are 70 bridges
altogether, and the best guess (if you know nothing) is to guess
cluster 3, which would guess 47 of the bridges wrong. The five numbers
in the brackets are the proportions of bridges in each cluster at this
point. But we <em>do</em> know more about bridge E42. We go to number 2,
which says to look at the <code>span</code>. For this bridge it is
<code>LONG</code>, so we go down to number 3. Under 3 are 6 and 7, which
say to look at <code>type</code>. Bridge E42 is of type <code>SIMPLE-T</code>,
so we go to 6. There is nothing under this (lower down in the tree),
and the line ends with a <code>*</code>, so we are ready to guess the
cluster. There are 18 bridges with this <code>span</code> and one of these
<code>type</code>s, and they are <em>all</em> in cluster 3, no
errors. Cluster 3 contains long-span bridges of one of those types.</p>
<p>Bridge 29, with ID E51, now. The first thing to look at is
<code>span</code> again; this one is <code>medium</code>, so we are at
2. Under 2 is 4 and 5; we are invited to look at <code>material</code>,
which is <code>STEEL</code>, number 5. We have another thing to look at,
10 and 11, which is <code>river</code>; in this case, <code>river</code> is
<code>M</code>, number 10. We are now at the end, guessing cluster 2
(which is also correct); there are 13 bridges of this <code>span</code>,
<code>material</code> and <code>river</code> and only 3 of them were in some
cluster other than 2.</p>
<p>By looking at the tree output, we can describe what makes a bridge be
predicted to land up in each cluster:</p>
<ul>
<li><p>Span is medium or short, material is iron or wood. (This
suggests old bridges.)</p></li>
<li><p>Span is medium or short, material is steel, river is M.</p></li>
<li><p>Span is long, type is arch, cantilever or simple-truss</p></li>
<li><p>Span is medium or short, material is steel, river is A.</p></li>
<li><p>Span is long, type is continuous-truss or suspension.</p></li>
</ul>
<p>This story is telling us that the clusters are determined by only a
few of our variables. <code>span</code> seems to be the most important,
then either type (if the span is long) or material and maybe river
(otherwise).</p>
<p>This is an example of a “classification tree” which is a nice
easy-to-follow version of logistic regression.</p>
</div>
<div id="clustering-the-australian-athletes" class="section level2">
<h2><span class="header-section-number">26.9</span> Clustering the Australian athletes</h2>
<p>Recall the Australian athlete data (that we’ve seen so many
times before). This time, we’ll do some K-means clustering, and then
see whether athletes of certain genders and certain sports tend to end
up in the same cluster.</p>
<ol style="list-style-type: lower-alpha">
<li>Read in the data from
<a href="http://www.utsc.utoronto.ca/~butler/c32/ais.txt">link</a>, recalling
that the data values are separated by tabs. Display (some of) the
data set.</li>
</ol>
<p>Solution</p>
<p>So, <code>read_tsv</code>.</p>
<div class="sourceCode" id="cb3996"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3996-1" data-line-number="1">my_url &lt;-<span class="st"> &quot;http://www.utsc.utoronto.ca/~butler/c32/ais.txt&quot;</span></a>
<a class="sourceLine" id="cb3996-2" data-line-number="2">athletes &lt;-<span class="st"> </span><span class="kw">read_tsv</span>(my_url)</a></code></pre></div>
<pre><code>## Parsed with column specification:
## cols(
##   Sex = col_character(),
##   Sport = col_character(),
##   RCC = col_double(),
##   WCC = col_double(),
##   Hc = col_double(),
##   Hg = col_double(),
##   Ferr = col_double(),
##   BMI = col_double(),
##   SSF = col_double(),
##   `%Bfat` = col_double(),
##   LBM = col_double(),
##   Ht = col_double(),
##   Wt = col_double()
## )</code></pre>
<div class="sourceCode" id="cb3998"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3998-1" data-line-number="1">athletes</a></code></pre></div>
<pre><code>## # A tibble: 202 x 13
##    Sex   Sport   RCC   WCC    Hc    Hg  Ferr   BMI   SSF `%Bfat`   LBM
##    &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;
##  1 fema… Netb…  4.56  13.3  42.2  13.6    20  19.2  49      11.3  53.1
##  2 fema… Netb…  4.15   6    38    12.7    59  21.2 110.     25.3  47.1
##  3 fema… Netb…  4.16   7.6  37.5  12.3    22  21.4  89      19.4  53.4
##  4 fema… Netb…  4.32   6.4  37.7  12.3    30  21.0  98.3    19.6  48.8
##  5 fema… Netb…  4.06   5.8  38.7  12.8    78  21.8 122.     23.1  56.0
##  6 fema… Netb…  4.12   6.1  36.6  11.8    21  21.4  90.4    16.9  56.4
##  7 fema… Netb…  4.17   5    37.4  12.7   109  21.5 107.     21.3  53.1
##  8 fema… Netb…  3.8    6.6  36.5  12.4   102  24.4 157.     26.6  54.4
##  9 fema… Netb…  3.96   5.5  36.3  12.4    71  22.6 101.     17.9  56.0
## 10 fema… Netb…  4.44   9.7  41.4  14.1    64  22.8 126.     25.0  51.6
## # … with 192 more rows, and 2 more variables: Ht &lt;dbl&gt;, Wt &lt;dbl&gt;</code></pre>
<ol start="2" style="list-style-type: lower-alpha">
<li>From your data frame, select only the columns that are numbers
(or get rid of the ones that are text), and standardize all of the
columns you have left. This is, done the best way, a slick piece of
code. Display what you get.</li>
</ol>
<p>Solution</p>
<p>This, in fact:</p>
<div class="sourceCode" id="cb4000"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4000-1" data-line-number="1">athletes <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select_if</span>(is.numeric) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate_all</span>(<span class="op">~</span><span class="st"> </span><span class="kw">scale</span>(.)) -&gt;<span class="st"> </span>athletes.s</a>
<a class="sourceLine" id="cb4000-2" data-line-number="2">athletes.s</a></code></pre></div>
<pre><code>## # A tibble: 202 x 11
##    RCC[,1] WCC[,1] Hc[,1] Hg[,1] Ferr[,1] BMI[,1] SSF[,1] `%Bfat`[,1]
##      &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;
##  1  -0.346   3.44  -0.243 -0.709  -1.20   -1.33    -0.615      -0.358
##  2  -1.24   -0.616 -1.39  -1.37   -0.376  -0.631    1.26        1.90 
##  3  -1.22    0.273 -1.53  -1.66   -1.16   -0.543    0.613       0.950
##  4  -0.870  -0.394 -1.47  -1.66   -0.987  -0.672    0.899       0.989
##  5  -1.44   -0.727 -1.20  -1.30    0.0237 -0.414    1.63        1.55 
##  6  -1.31   -0.560 -1.77  -2.03   -1.18   -0.550    0.656       0.542
##  7  -1.20   -1.17  -1.55  -1.37    0.676  -0.519    1.16        1.26 
##  8  -2.01   -0.283 -1.80  -1.59    0.529   0.522    2.69        2.11 
##  9  -1.66   -0.893 -1.85  -1.59   -0.124  -0.114    0.985       0.714
## 10  -0.608   1.44  -0.462 -0.342  -0.271  -0.0544   1.76        1.85 
## # … with 192 more rows, and 3 more variables: LBM[,1] &lt;dbl&gt;,
## #   Ht[,1] &lt;dbl&gt;, Wt[,1] &lt;dbl&gt;</code></pre>
<p>The columns have weird names, possibly because <code>scale</code> expects
a matrix or data frame (to standardize each column), and here it’s
getting the columns one at a time.</p>
<p>Elsewhere, I stuck <code>scale()</code> on the end, which produces a
<em>matrix</em>, which I should then display the top of (it has 200-plus rows):</p>
<div class="sourceCode" id="cb4002"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4002-1" data-line-number="1">athletes <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select_if</span>(is.numeric) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">scale</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">head</span>()</a></code></pre></div>
<pre><code>##             RCC        WCC         Hc         Hg        Ferr
## [1,] -0.3463363  3.4385826 -0.2434034 -0.7092631 -1.19736325
## [2,] -1.2415791 -0.6157363 -1.3900079 -1.3698371 -0.37633203
## [3,] -1.2197439  0.2728816 -1.5265084 -1.6634256 -1.15525908
## [4,] -0.8703809 -0.3935818 -1.4719082 -1.6634256 -0.98684242
## [5,] -1.4380958 -0.7268135 -1.1989072 -1.2964400  0.02365754
## [6,] -1.3070846 -0.5601977 -1.7722094 -2.0304111 -1.17631117
##             BMI        SSF      %Bfat        LBM         Ht
## [1,] -1.3254121 -0.6148189 -0.3582372 -0.8977457 -0.3394075
## [2,] -0.6305634  1.2644802  1.8986922 -1.3606308 -0.7708629
## [3,] -0.5432708  0.6134811  0.9503618 -0.8747927 -0.4215895
## [4,] -0.6724638  0.8990609  0.9891351 -1.2313290 -1.0482270
## [5,] -0.4140778  1.6298994  1.5513480 -0.6751017  0.2975028
## [6,] -0.5502542  0.6564716  0.5416266 -0.6444978 -0.1955890
##              Wt
## [1,] -1.0849225
## [2,] -0.8623105
## [3,] -0.6253364
## [4,] -1.0274742
## [5,] -0.1513883
## [6,] -0.5104399</code></pre>
<p>I (at this moment) like the first one better, but these preferences
tend to change over time (as will yours).</p>
<p>The first athlete has a <code>WCC</code> value that is very large compared
to the others.</p>
<ol start="3" style="list-style-type: lower-alpha">
<li>Make a data frame that contains the total within-cluster sum
of squares from a K-means clustering for each number of clusters
from 2 to 20.</li>
</ol>
<p>Solution</p>
<p>I’m going to attempt a slick way of doing this, and then I’ll talk
about how I’d expect <em>you</em> to tackle this. First, though, I
set the random number seed so that everything comes out the same
every time I run it:</p>
<div class="sourceCode" id="cb4004"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4004-1" data-line-number="1"><span class="kw">set.seed</span>(<span class="dv">457299</span>)</a></code></pre></div>
<p>Here we go:</p>
<div class="sourceCode" id="cb4005"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4005-1" data-line-number="1">withinss &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">2</span><span class="op">:</span><span class="dv">20</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb4005-2" data-line-number="2"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">wss =</span> <span class="kw">map_dbl</span>(clusters, <span class="op">~</span><span class="st"> </span><span class="kw">kmeans</span>(athletes.s, ., <span class="dt">nstart =</span> <span class="dv">20</span>)<span class="op">$</span>tot.withinss))</a>
<a class="sourceLine" id="cb4005-3" data-line-number="3">withinss</a></code></pre></div>
<pre><code>## # A tibble: 19 x 2
##    clusters   wss
##       &lt;int&gt; &lt;dbl&gt;
##  1        2 1426.
##  2        3 1201.
##  3        4 1043.
##  4        5  970.
##  5        6  901.
##  6        7  836.
##  7        8  778.
##  8        9  731.
##  9       10  688.
## 10       11  654.
## 11       12  626.
## 12       13  610.
## 13       14  581.
## 14       15  566.
## 15       16  550.
## 16       17  532.
## 17       18  514.
## 18       19  502.
## 19       20  483.</code></pre>
<p>A one-liner, kinda. The thing after the squiggle is called an
“anonymous function”; it is what is done for each of the first
thing, and where you want the thing you’re varying to go, you put a
dot (the notation is like the dot meaning
“whatever came out of the previous step”).
The advantage to this is that it looks exactly like
the <code>kmeans</code> that you would write, except for the number of
clusters that is replaced by a dot.
All right then, how would I expect <em>you</em> to do this? First write
a function to take a number of clusters and a data frame and return
the total within-cluster sum of squares:</p>
<div class="sourceCode" id="cb4007"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4007-1" data-line-number="1">twss &lt;-<span class="st"> </span><span class="cf">function</span>(i, x) {</a>
<a class="sourceLine" id="cb4007-2" data-line-number="2">  ans &lt;-<span class="st"> </span><span class="kw">kmeans</span>(x, i, <span class="dt">nstart =</span> <span class="dv">20</span>)</a>
<a class="sourceLine" id="cb4007-3" data-line-number="3">  ans<span class="op">$</span>tot.withinss</a>
<a class="sourceLine" id="cb4007-4" data-line-number="4">}</a></code></pre></div>
<p>and test it (against my answer above):</p>
<div class="sourceCode" id="cb4008"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4008-1" data-line-number="1"><span class="kw">twss</span>(<span class="dv">3</span>, athletes.s)</a></code></pre></div>
<pre><code>## [1] 1201.346</code></pre>
<p>Check (with a few extra decimals).</p>
<p>Now, recognize that your function returns a decimal number, so that
you will be using <code>map_dbl</code> in a moment, and then calculate
all the total within-cluster sum of squares values by making a little
data frame with all your numbers of clusters:</p>
<div class="sourceCode" id="cb4010"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4010-1" data-line-number="1"><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">2</span><span class="op">:</span><span class="dv">20</span>)</a></code></pre></div>
<pre><code>## # A tibble: 19 x 1
##    clusters
##       &lt;int&gt;
##  1        2
##  2        3
##  3        4
##  4        5
##  5        6
##  6        7
##  7        8
##  8        9
##  9       10
## 10       11
## 11       12
## 12       13
## 13       14
## 14       15
## 15       16
## 16       17
## 17       18
## 18       19
## 19       20</code></pre>
<p>and then make a pipeline and save it:</p>
<div class="sourceCode" id="cb4012"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4012-1" data-line-number="1"><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">2</span><span class="op">:</span><span class="dv">20</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb4012-2" data-line-number="2"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">wss =</span> <span class="kw">map_dbl</span>(clusters, <span class="op">~</span><span class="st"> </span><span class="kw">twss</span>(., athletes.s))) -&gt;<span class="st"> </span>withinss</a>
<a class="sourceLine" id="cb4012-3" data-line-number="3">withinss</a></code></pre></div>
<pre><code>## # A tibble: 19 x 2
##    clusters   wss
##       &lt;int&gt; &lt;dbl&gt;
##  1        2 1426.
##  2        3 1201.
##  3        4 1043.
##  4        5  968.
##  5        6  900.
##  6        7  836.
##  7        8  785.
##  8        9  731.
##  9       10  696.
## 10       11  665.
## 11       12  631.
## 12       13  609.
## 13       14  584.
## 14       15  569.
## 15       16  543.
## 16       17  530.
## 17       18  519.
## 18       19  498.
## 19       20  494.</code></pre>
<ol start="4" style="list-style-type: lower-alpha">
<li>Use the data frame you just created to make a scree plot. What
does the scree plot tell you?</li>
</ol>
<p>Solution</p>
<p><code>ggscreeplot</code> is for principal components; this one you can
plot directly, with the points joined by lines:</p>
<div class="sourceCode" id="cb4014"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4014-1" data-line-number="1"><span class="kw">ggplot</span>(withinss, <span class="kw">aes</span>(<span class="dt">x =</span> clusters, <span class="dt">y =</span> wss)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>()</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/unnamed-chunk-190-1.png" width="672"  /></p>
<p>On this plot, you are looking for “elbows”, but ones sufficiently
far down the mountain. For example, that’s an elbow at 4 clusters, but
it’s still up the mountain, which means that the total within-cluster
sum of squares is quite large and that the athletes within those 4
clusters might be quite dissimilar from each other. I see an elbow at
12 clusters and possibly others at 14, 16 and 19; these are nearer the bottom
of the mountain, so that the athletes within a cluster will be quite
similar to each other. With over 200 athletes, there’s no problem
having as many as 19 clusters, because that will still offer you some
insight.</p>
<p>So I’m thinking 12 clusters (because I want to have a fairly small
number of clusters to interpret later).</p>
<p>The other thing I’m thinking is I could have put a bigger number of
clusters on the scree plot. The <code>wss</code> axis should go all the
way down to 0 for 202 clusters, with each athlete in one cluster. So
you could make the point that even 20 clusters is still a fair way up
the mountain.</p>
<ol start="5" style="list-style-type: lower-alpha">
<li>Using a sensible number of clusters as deduced from your scree
plot, run a K-means cluster analysis. Don’t forget the
<code>nstart</code>!</li>
</ol>
<p>Solution</p>
<p>This:</p>
<div class="sourceCode" id="cb4015"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4015-1" data-line-number="1">athletes.km &lt;-<span class="st"> </span><span class="kw">kmeans</span>(athletes.s, <span class="dv">12</span>, <span class="dt">nstart =</span> <span class="dv">20</span>)</a></code></pre></div>
<p>or for your chosen number of clusters.</p>
<p>I don’t think there’s any great need to display the output, since the
most interesting thing is which athletes are in which cluster, which
we’ll get to next.</p>
<ol start="6" style="list-style-type: lower-alpha">
<li>Make a data frame consisting of the athletes’ sport and
gender, and which of your clusters they belong to, taking the
appropriate things from the appropriate one of your data frames.</li>
</ol>
<p>Solution</p>
<div class="sourceCode" id="cb4016"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4016-1" data-line-number="1">athletes2 &lt;-<span class="st"> </span><span class="kw">tibble</span>(</a>
<a class="sourceLine" id="cb4016-2" data-line-number="2">  <span class="dt">gender =</span> athletes<span class="op">$</span>Sex,</a>
<a class="sourceLine" id="cb4016-3" data-line-number="3">  <span class="dt">sport =</span> athletes<span class="op">$</span>Sport,</a>
<a class="sourceLine" id="cb4016-4" data-line-number="4">  <span class="dt">cluster =</span> athletes.km<span class="op">$</span>cluster</a>
<a class="sourceLine" id="cb4016-5" data-line-number="5">)</a>
<a class="sourceLine" id="cb4016-6" data-line-number="6">athletes2</a></code></pre></div>
<pre><code>## # A tibble: 202 x 3
##    gender sport   cluster
##    &lt;chr&gt;  &lt;chr&gt;     &lt;int&gt;
##  1 female Netball       3
##  2 female Netball       9
##  3 female Netball       9
##  4 female Netball       9
##  5 female Netball       9
##  6 female Netball       9
##  7 female Netball       9
##  8 female Netball      10
##  9 female Netball       9
## 10 female Netball      10
## # … with 192 more rows</code></pre>
<ol start="7" style="list-style-type: lower-alpha">
<li>Using the data frame you created in the previous part, display
all the athletes in some of your clusters. Do the athletes within a
cluster appear to have anything in common? (If a cluster has more
than 10 athletes in it, make sure to look at them all.)</li>
</ol>
<p>Solution</p>
<p>Let’s start with my cluster 1. I’m putting a <code>print(n=Inf)</code>
on the end of each of these, to make sure all the cluster members
get shown, at least in the Console:</p>
<div class="sourceCode" id="cb4018"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4018-1" data-line-number="1">athletes2 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(cluster <span class="op">==</span><span class="st"> </span><span class="dv">1</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">print</span>(<span class="dt">n =</span> <span class="ot">Inf</span>)</a></code></pre></div>
<pre><code>## # A tibble: 25 x 3
##    gender sport   cluster
##    &lt;chr&gt;  &lt;chr&gt;     &lt;int&gt;
##  1 female Netball       1
##  2 female Row           1
##  3 female Swim          1
##  4 female Swim          1
##  5 female Swim          1
##  6 female Swim          1
##  7 female Swim          1
##  8 female Field         1
##  9 female T400m         1
## 10 female T400m         1
## 11 female T400m         1
## 12 female T400m         1
## 13 female T400m         1
## 14 female T400m         1
## 15 female T400m         1
## 16 female Tennis        1
## 17 female Tennis        1
## 18 female Tennis        1
## 19 female Gym           1
## 20 female Gym           1
## 21 female Gym           1
## 22 female Gym           1
## 23 male   T400m         1
## 24 male   T400m         1
## 25 male   T400m         1</code></pre>
<p>These are almost all female, and if you remember back to our study of
height and weight for these data, these are the kinds of sport that
are played by shorter, lighter people.
Cluster 2:</p>
<div class="sourceCode" id="cb4020"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4020-1" data-line-number="1">athletes2 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(cluster <span class="op">==</span><span class="st"> </span><span class="dv">2</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">print</span>(<span class="dt">n =</span> <span class="ot">Inf</span>)</a></code></pre></div>
<pre><code>## # A tibble: 27 x 3
##    gender sport  cluster
##    &lt;chr&gt;  &lt;chr&gt;    &lt;int&gt;
##  1 male   Swim         2
##  2 male   Swim         2
##  3 male   Swim         2
##  4 male   Swim         2
##  5 male   Swim         2
##  6 male   Swim         2
##  7 male   Row          2
##  8 male   Row          2
##  9 male   Row          2
## 10 male   Row          2
## 11 male   Row          2
## 12 male   Row          2
## 13 male   Row          2
## 14 male   Row          2
## 15 male   Row          2
## 16 male   Row          2
## 17 male   BBall        2
## 18 male   BBall        2
## 19 male   BBall        2
## 20 male   BBall        2
## 21 male   BBall        2
## 22 male   BBall        2
## 23 male   Field        2
## 24 male   TSprnt       2
## 25 male   WPolo        2
## 26 male   WPolo        2
## 27 male   WPolo        2</code></pre>
<p>Males, apparently some of the more muscular ones, but not the field
athletes.</p>
<div class="sourceCode" id="cb4022"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4022-1" data-line-number="1">athletes2 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(cluster <span class="op">==</span><span class="st"> </span><span class="dv">3</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">print</span>(<span class="dt">n =</span> <span class="ot">Inf</span>)</a></code></pre></div>
<pre><code>## # A tibble: 10 x 3
##    gender sport   cluster
##    &lt;chr&gt;  &lt;chr&gt;     &lt;int&gt;
##  1 female Netball       3
##  2 female T400m         3
##  3 female TSprnt        3
##  4 female TSprnt        3
##  5 female T400m         3
##  6 female TSprnt        3
##  7 female TSprnt        3
##  8 female Tennis        3
##  9 female Tennis        3
## 10 male   Row           3</code></pre>
<p>This is an odd one, since there is one male rower (rowers tend to be
fairly big) along with a bunch of females mostly from sports involving
running. I have a feeling this rower is a “cox”, whose job is
<em>not</em> to row, but to sit in the boat and keep everybody in time
by yelling out “stroke” in rhythm. Since the cox is not rowing, they
need to be light in weight.</p>
<p>Let’s investigate:</p>
<div class="sourceCode" id="cb4024"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4024-1" data-line-number="1">athletes <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb4024-2" data-line-number="2"><span class="st">  </span><span class="kw">select</span>(<span class="dt">gender =</span> Sex, <span class="dt">sport =</span> Sport, <span class="dt">ht =</span> Ht, <span class="dt">wt =</span> Wt) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb4024-3" data-line-number="3"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">cluster =</span> athletes.km<span class="op">$</span>cluster) -&gt;<span class="st"> </span>athletes2a</a>
<a class="sourceLine" id="cb4024-4" data-line-number="4">athletes2a <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(sport <span class="op">==</span><span class="st"> &quot;Row&quot;</span>, cluster <span class="op">==</span><span class="st"> </span><span class="dv">3</span>)</a></code></pre></div>
<pre><code>## # A tibble: 1 x 5
##   gender sport    ht    wt cluster
##   &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;int&gt;
## 1 male   Row    165.  53.8       3</code></pre>
<p>How does this athlete compare to the other rowers?</p>
<div class="sourceCode" id="cb4026"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4026-1" data-line-number="1">athletes2a <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb4026-2" data-line-number="2"><span class="st">  </span><span class="kw">filter</span>(sport <span class="op">==</span><span class="st"> &quot;Row&quot;</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb4026-3" data-line-number="3"><span class="st">  </span><span class="kw">select</span>(ht, wt) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb4026-4" data-line-number="4"><span class="st">  </span><span class="kw">summary</span>()</a></code></pre></div>
<pre><code>##        ht              wt       
##  Min.   :156.0   Min.   :49.80  
##  1st Qu.:179.3   1st Qu.:72.90  
##  Median :181.8   Median :78.70  
##  Mean   :182.4   Mean   :78.54  
##  3rd Qu.:186.3   3rd Qu.:87.20  
##  Max.   :198.0   Max.   :97.00</code></pre>
<p>The rower that is in cluster 3 is almost the lightest, and also almost
the shortest, of all the rowers.
Cluster 4:</p>
<div class="sourceCode" id="cb4028"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4028-1" data-line-number="1">athletes2 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(cluster <span class="op">==</span><span class="st"> </span><span class="dv">4</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">print</span>(<span class="dt">n =</span> <span class="ot">Inf</span>)</a></code></pre></div>
<pre><code>## # A tibble: 13 x 3
##    gender sport  cluster
##    &lt;chr&gt;  &lt;chr&gt;    &lt;int&gt;
##  1 male   Swim         4
##  2 male   Row          4
##  3 male   Row          4
##  4 male   Row          4
##  5 male   BBall        4
##  6 male   BBall        4
##  7 male   TSprnt       4
##  8 male   Field        4
##  9 male   WPolo        4
## 10 male   WPolo        4
## 11 male   WPolo        4
## 12 male   WPolo        4
## 13 male   WPolo        4</code></pre>
<p>Males, but possibly more muscular ones.</p>
<div class="sourceCode" id="cb4030"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4030-1" data-line-number="1">athletes2 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(cluster <span class="op">==</span><span class="st"> </span><span class="dv">5</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">print</span>(<span class="dt">n =</span> <span class="ot">Inf</span>)</a></code></pre></div>
<pre><code>## # A tibble: 10 x 3
##    gender sport  cluster
##    &lt;chr&gt;  &lt;chr&gt;    &lt;int&gt;
##  1 male   Swim         5
##  2 male   Swim         5
##  3 male   Row          5
##  4 male   TSprnt       5
##  5 male   TSprnt       5
##  6 male   TSprnt       5
##  7 male   T400m        5
##  8 male   WPolo        5
##  9 male   WPolo        5
## 10 male   Tennis       5</code></pre>
<p>More males, from similar sports. I wonder what makes these last two
clusters different?</p>
<p>One more:</p>
<div class="sourceCode" id="cb4032"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4032-1" data-line-number="1">athletes2 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(cluster <span class="op">==</span><span class="st"> </span><span class="dv">6</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">print</span>(<span class="dt">n =</span> <span class="ot">Inf</span>)</a></code></pre></div>
<pre><code>## # A tibble: 3 x 3
##   gender sport cluster
##   &lt;chr&gt;  &lt;chr&gt;   &lt;int&gt;
## 1 male   BBall       6
## 2 male   Field       6
## 3 male   Field       6</code></pre>
<p>These are three of our “big guys”, by the looks of it.</p>
<ol start="8" style="list-style-type: lower-alpha">
<li>Add the cluster membership to the data frame you read in from
the file, and do a discriminant analysis treating the clusters as
known groups. You can display the output.</li>
</ol>
<p>Solution</p>
<p><code>MASS</code> is already loaded (for me), so:</p>
<div class="sourceCode" id="cb4034"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4034-1" data-line-number="1">athletes<span class="fl">.3</span> &lt;-<span class="st"> </span>athletes <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb4034-2" data-line-number="2"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">cluster =</span> athletes.km<span class="op">$</span>cluster) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb4034-3" data-line-number="3"><span class="st">  </span><span class="kw">lda</span>(cluster <span class="op">~</span><span class="st"> </span>RCC <span class="op">+</span><span class="st"> </span>WCC <span class="op">+</span><span class="st"> </span>Hc <span class="op">+</span><span class="st"> </span>Hg <span class="op">+</span><span class="st"> </span>Ferr <span class="op">+</span><span class="st"> </span>BMI <span class="op">+</span><span class="st"> </span>SSF <span class="op">+</span><span class="st"> `</span><span class="dt">%Bfat</span><span class="st">`</span> <span class="op">+</span><span class="st"> </span>LBM <span class="op">+</span><span class="st"> </span>Ht <span class="op">+</span><span class="st"> </span>Wt, <span class="dt">data =</span> .)</a></code></pre></div>
<p>We can display all the output now. The
problem here, with 12 groups and 11 variables, is that there is rather
a lot of it:</p>
<div class="sourceCode" id="cb4035"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4035-1" data-line-number="1">athletes<span class="fl">.3</span></a></code></pre></div>
<pre><code>## Call:
## lda(cluster ~ RCC + WCC + Hc + Hg + Ferr + BMI + SSF + `%Bfat` + 
##     LBM + Ht + Wt, data = .)
## 
## Prior probabilities of groups:
##          1          2          3          4          5          6 
## 0.12376238 0.13366337 0.04950495 0.06435644 0.04950495 0.01485149 
##          7          8          9         10         11         12 
## 0.15841584 0.05445545 0.14356436 0.05445545 0.01980198 0.13366337 
## 
## Group means:
##         RCC       WCC       Hc       Hg      Ferr      BMI       SSF
## 1  4.292800  6.390000 39.96000 13.52400  70.08000 19.71680  52.53600
## 2  4.989259  6.466667 45.27407 15.35556  82.62963 24.08185  52.92222
## 3  4.967000  8.130000 44.32000 14.52000  52.20000 19.69700  49.86000
## 4  4.814615 10.107692 44.26923 14.96923 121.30769 24.56846  57.79231
## 5  5.182000  7.210000 46.44000 15.93000 200.30000 22.96800  47.22000
## 6  5.376667  6.266667 48.50000 16.90000  87.33333 30.95667  75.76667
## 7  4.974687  6.484375 45.22812 15.40000  62.43750 22.19406  39.20625
## 8  5.015455  8.200000 46.01818 15.86364 128.18182 29.08909  92.78182
## 9  4.167241  5.993103 38.24828 12.68966  53.48276 22.05897  96.97241
## 10 4.336364  8.818182 39.13636 13.21818  70.00000 25.03727 150.16364
## 11 6.000000  8.150000 52.37500 17.87500  52.50000 23.91750  45.27500
## 12 4.592963  7.292593 42.65926 14.35926  46.03704 22.74333  86.31111
##      `%Bfat`       LBM       Ht        Wt
## 1  11.629600  47.89800 165.5560  54.21200
## 2   9.353333  80.51852 192.1407  88.82593
## 3  11.127000  51.58500 171.6800  58.04000
## 4  10.161538  80.00000 190.3923  89.06154
## 5   8.737000  68.60000 180.8200  75.27000
## 6  12.316667 101.66667 194.5333 116.06667
## 7   7.244687  67.84375 181.5750  73.12969
## 8  16.624545  80.07636 182.0273  96.21364
## 9  19.652069  56.45069 178.5828  70.30862
## 10 26.948182  57.36364 177.1273  78.66364
## 11  8.655000  71.00000 180.5250  77.85000
## 12 18.587778  58.60296 178.0926  72.02963
## 
## Coefficients of linear discriminants:
##                 LD1           LD2         LD3         LD4
## RCC      0.97065695 -0.6603068763  1.33756370  1.09562690
## WCC      0.14419412  0.0976964684 -0.18593544  0.20949626
## Hc       0.03993365 -0.0167282552  0.02944517  0.03757250
## Hg       0.37674322 -0.0804231815  0.23604530  0.25585971
## Ferr     0.01034932  0.0004759457 -0.01890123  0.01000745
## BMI     -0.80345854 -0.1154590209  2.36621577  1.09372321
## SSF      0.03104854  0.0201862368 -0.04266384 -0.01010683
## `%Bfat` -0.26070019  0.3084472414  0.38633638 -0.56728329
## LBM      0.13127761  0.2535714776  0.15237852 -0.95583785
## Ht      -0.18753716 -0.0383066459  0.62101446  0.21807165
## Wt       0.24096298 -0.0758565305 -0.86525933  0.47345760
##                  LD5          LD6         LD7          LD8
## RCC      0.823150984 -1.043582865 -0.07505452  3.349225162
## WCC      0.040948618 -0.253978139  0.51122383 -0.208802305
## Hc      -0.091527860  0.076362064  0.22579774 -0.064326188
## Hg      -0.411820765  0.324683430 -0.49946561 -0.333561523
## Ferr     0.016374918  0.014745757 -0.00126626  0.004707277
## BMI      2.093393957 -0.074129274 -0.73341244 -1.414080937
## SSF      0.042455393 -0.123300713 -0.04694265  0.039099433
## `%Bfat`  0.001281886  0.805369458  0.62262118  0.321154264
## LBM      0.326510350  0.150544819  0.47745059  0.502240317
## Ht       0.617572863 -0.007326729 -0.13542176 -0.307307666
## Wt      -1.003298275 -0.085364884 -0.21648376 -0.068463691
##                  LD9         LD10        LD11
## RCC      2.409712056 -2.458531332  3.02712544
## WCC     -0.055087889 -0.096574434  0.08365257
## Hc       0.323729320  0.495620032 -0.87338911
## Hg      -2.113984890 -0.353250579  1.25812670
## Ferr     0.001033493  0.001997618 -0.00132641
## BMI      0.395756559 -0.745699734 -0.24072424
## SSF     -0.046138514  0.008604107 -0.05862077
## `%Bfat` -0.312212279 -0.634599730 -0.23032505
## LBM     -0.603622986 -0.884218147 -0.69461824
## Ht       0.039454667 -0.059206652  0.01561849
## Wt       0.486302236  0.926849133  0.66518616
## 
## Proportion of trace:
##    LD1    LD2    LD3    LD4    LD5    LD6    LD7    LD8    LD9   LD10 
## 0.5386 0.2062 0.0805 0.0684 0.0435 0.0246 0.0216 0.0114 0.0044 0.0008 
##   LD11 
## 0.0000</code></pre>
<ol style="list-style-type: lower-roman">
<li>How many linear discriminants do you have? How many do you
think are important?</li>
</ol>
<p>Solution</p>
<p>Proportion of trace, at the bottom of the output.</p>
<p>It’s hard to draw the line here. The first two, or maybe the first
seven, or something like that. Your call.</p>
<ol start="10" style="list-style-type: lower-alpha">
<li>Which variables seem to be important in distinguishing the
clusters? Look only at the linear discriminants that you judged to
be important.</li>
</ol>
<p>Solution</p>
<p>Look at the coefficients of linear discriminants.
This is rather large, since I had 12 clusters, and thus there are
11 <code>LD</code>s.</p>
<p>If we go back to my thought of only using two linear discriminants:
LD1 is mostly <code>RCC</code> positively and <code>BMI</code> negatively, in
that an athlete with large <code>RCC</code> and small <code>BMI</code> will
tend to score high (positive) on LD1. <code>BMI</code> is the familiar
body fat index. LD2 depends on <code>RCC</code> again, but this time
negatively, and maybe percent body fat and <code>LBM</code>. And so on, if
you went on.</p>
<p>It may be that <code>RCC</code> is just very variable anyway, since it
seems to appear just about everywhere.</p>
<p>Extra: we can also look at the means on each variable by cluster,
which is part of the output, in “Group Means”.
Perhaps the easiest thing to eyeball here is the cluster in which a
variable is noticeably biggest (or possibly smallest). For example,
<code>WCC</code> is highest in cluster 4, and while Ferritin is high
there, it is higher still in cluster 5. <code>BMI</code> is highest in
cluster 6 and lowest in clusters 1 and 3. Height is smallest in
cluster 1, with weight being smallest there as well, and weight is
much the biggest in cluster 6.</p>
<ol start="11" style="list-style-type: lower-alpha">
<li>Draw a biplot (which shows the first two LDs), drawing the
clusters in different colours. Comment briefly on anything
especially consistent or inconsistent with what you’ve seen so far.</li>
</ol>
<p>Solution</p>
<p>The thing to get the colours is to feed a <code>groups</code> into
<code>ggbiplot</code>. I suspect I need the <code>factor</code> in there
because the clusters are numbers and I want them treated as
categorical (the numbers are labels). Also, note that we will have
a lot of colours here, so I am trying to make them more
distinguishable using <code>scale_colour_brewer</code> from the
<code>RColorBrewer</code> package (loaded at the beginning):</p>
<div class="sourceCode" id="cb4037"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4037-1" data-line-number="1"><span class="kw">ggbiplot</span>(athletes<span class="fl">.3</span>, <span class="dt">groups =</span> <span class="kw">factor</span>(athletes2<span class="op">$</span>cluster)) <span class="op">+</span></a>
<a class="sourceLine" id="cb4037-2" data-line-number="2"><span class="st">  </span><span class="kw">scale_colour_brewer</span>(<span class="dt">palette =</span> <span class="st">&quot;Paired&quot;</span>)</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/unnamed-chunk-203-1.png" width="672"  /></p>
<p>What the biplot shows, that we haven’t seen any hint of so far, is
that the clusters are pretty well separated on LD1 and LD2: there is
not a great deal of overlap.</p>
<p>Anyway, low LD1 means high on BMI and low on RCC, as we saw
before. The arrow for RCC points down as well as right, so it’s part
of LD2 as well. There isn’t much else that points up or down, but
percent body fat and LBM do as much as anything. This is all pretty
much what we saw before.</p>
<p>As to where the clusters fall on the picture:</p>
<ul>
<li><p>Cluster 1 in light blue was “small and light”: small BMI, so
ought to be on the right. This cluster’s RCC was also small, which
on balance puts them on the left, but then they should be <em>top</em>
left because RCC points down. I dunno.</p></li>
<li><p>Cluster 2 in dark blue was “more muscular males”, mid-right,
so above average on LD1 but about average on LD2.</p></li>
<li><p>Cluster 3, light green, was “running females” (mostly), lower
left, so below average on both LD1 and LD2.</p></li>
<li><p>Cluster 4, dark green, “more muscular males” again. There is a
lot of overlap with cluster 2.</p></li>
<li><p>Cluster 5, pink, was “yet more males”. Mostly above average on
LD1 and below average on LD2. The latter was what distinguished
these from clusters 4 and 2.</p></li>
<li><p>Cluster 6, red, was “big guys”. The biggest on LD1 and almost
the biggest on LD2.</p></li>
</ul>
<p>There is something a bit confusing in LD1, which contrasts RCC and
BMI. You would expect, therefore, RCC and BMI to be negatively
correlated, but if you look at the cluster means, that isn’t really
the story: for example, cluster 1 has almost the lowest mean on both
variables, and the highest RCC, in cluster 11, goes with a middling
BMI.</p>
<p>I like these colours much better than the default ones. Much easier to
tell apart.
In any case, RCC and BMI seem to be important, so let’s plot them
against each other, coloured by cluster:</p>
<div class="sourceCode" id="cb4038"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4038-1" data-line-number="1">athletes <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb4038-2" data-line-number="2"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">cluster =</span> <span class="kw">factor</span>(athletes2<span class="op">$</span>cluster)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb4038-3" data-line-number="3"><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> RCC, <span class="dt">y =</span> BMI, <span class="dt">colour =</span> cluster)) <span class="op">+</span></a>
<a class="sourceLine" id="cb4038-4" data-line-number="4"><span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">scale_colour_brewer</span>(<span class="dt">palette =</span> <span class="st">&quot;Paired&quot;</span>)</a></code></pre></div>
<p><img src="22-thingy_files/figure-html/unnamed-chunk-204-1.png" width="672"  /></p>
<p>I decided to create a column called <code>cluster</code> in the data
frame, so that the legend would have a nice clear title. (If you do
the <code>factor(athletes2$cluster)</code> in the <code>ggplot</code>, that
is what will appear as the legend title.)</p>
<p>There seems to be very little relationship here, in terms of an
overall trend on the plot. But at least these two variables do
<em>something</em> to distinguish the clusters. It’s not as clear as
using LD1 and LD2 (as it won’t be, since they’re designed to be the
best at separating the groups), but you can see that the clusters are
at least somewhat distinct.</p>
<p>The “paired” part of the colour palette indicates that successive
colours come in pairs: light and dark of blue, green, red, orange,
purple and brown (if you think of yellow as being “light brown” or
brown as being “dark yellow”, like bananas).</p>
<p>A good resource for RColorBrewer is
<a href="https://moderndata.plot.ly/create-colorful-graphs-in-r-with-rcolorbrewer-and-plotly/">link</a>. The
“qualitative palettes” shown there are for distinguishing groups
(what we want here); the sequential palettes are for distinguishing
values on a continuous scale, and the diverging palettes are for
drawing attention to high and low.</p>

</div>
</div>
<p style="text-align: center;">
<a href="discriminant-analysis.html"><button class="btn btn-default">Previous</button></a>
<a href="multidimensional-scaling.html"><button class="btn btn-default">Next</button></a>
</p>
</div>
</div>



</body>
</html>
