<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 36 K-means cluster analysis | Problems and Solutions in Applied Statistics</title>
  <meta name="description" content="A set of problems and solutions, in R, on various parts of applied statistics" />
  <meta name="generator" content="bookdown 0.21 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 36 K-means cluster analysis | Problems and Solutions in Applied Statistics" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="http://ritsokiguess.site/pasias" />
  
  <meta property="og:description" content="A set of problems and solutions, in R, on various parts of applied statistics" />
  <meta name="github-repo" content="nxskok/pasias" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 36 K-means cluster analysis | Problems and Solutions in Applied Statistics" />
  
  <meta name="twitter:description" content="A set of problems and solutions, in R, on various parts of applied statistics" />
  

<meta name="author" content="Ken Butler" />


<meta name="date" content="2021-05-17" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="hierarchical-cluster-analysis.html"/>
<link rel="next" href="drawing-maps-with-leaflet.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />











<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Problems and Solutions in Applied Statistics</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Introduction</a><ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#packages-used-somewhere-in-this-book"><i class="fa fa-check"></i>Packages used somewhere in this book</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="getting-used-to-r-and-r-studio.html"><a href="getting-used-to-r-and-r-studio.html"><i class="fa fa-check"></i><b>1</b> Getting used to R and R Studio</a></li>
<li class="chapter" data-level="2" data-path="reading-in-data.html"><a href="reading-in-data.html"><i class="fa fa-check"></i><b>2</b> Reading in data</a></li>
<li class="chapter" data-level="3" data-path="drawing-graphs.html"><a href="drawing-graphs.html"><i class="fa fa-check"></i><b>3</b> Drawing graphs</a></li>
<li class="chapter" data-level="4" data-path="data-exploration.html"><a href="data-exploration.html"><i class="fa fa-check"></i><b>4</b> Data exploration</a></li>
<li class="chapter" data-level="5" data-path="working-with-dataframes.html"><a href="working-with-dataframes.html"><i class="fa fa-check"></i><b>5</b> Working with dataframes</a></li>
<li class="chapter" data-level="6" data-path="one-sample-inference.html"><a href="one-sample-inference.html"><i class="fa fa-check"></i><b>6</b> One-sample inference</a></li>
<li class="chapter" data-level="7" data-path="two-sample-inference.html"><a href="two-sample-inference.html"><i class="fa fa-check"></i><b>7</b> Two-sample inference</a></li>
<li class="chapter" data-level="8" data-path="power-and-sample-size.html"><a href="power-and-sample-size.html"><i class="fa fa-check"></i><b>8</b> Power and sample size</a></li>
<li class="chapter" data-level="9" data-path="the-sign-test.html"><a href="the-sign-test.html"><i class="fa fa-check"></i><b>9</b> The sign test</a></li>
<li class="chapter" data-level="10" data-path="mood-median-test.html"><a href="mood-median-test.html"><i class="fa fa-check"></i><b>10</b> Mood median test</a></li>
<li class="chapter" data-level="11" data-path="matched-pairs-t-and-sign-test.html"><a href="matched-pairs-t-and-sign-test.html"><i class="fa fa-check"></i><b>11</b> Matched pairs t and sign test</a></li>
<li class="chapter" data-level="12" data-path="normal-quantile-plots.html"><a href="normal-quantile-plots.html"><i class="fa fa-check"></i><b>12</b> Normal quantile plots</a><ul>
<li class="chapter" data-level="12.1" data-path="normal-quantile-plots.html"><a href="normal-quantile-plots.html#lengths-of-heliconia-flowers"><i class="fa fa-check"></i><b>12.1</b> Lengths of heliconia flowers</a></li>
<li class="chapter" data-level="12.2" data-path="normal-quantile-plots.html"><a href="normal-quantile-plots.html#ferritin-and-normality"><i class="fa fa-check"></i><b>12.2</b> Ferritin and normality</a></li>
<li class="chapter" data-level="12.3" data-path="normal-quantile-plots.html"><a href="normal-quantile-plots.html#lengths-of-heliconia-flowers-1"><i class="fa fa-check"></i><b>12.3</b> Lengths of heliconia flowers</a></li>
<li class="chapter" data-level="12.4" data-path="normal-quantile-plots.html"><a href="normal-quantile-plots.html#ferritin-and-normality-1"><i class="fa fa-check"></i><b>12.4</b> Ferritin and normality</a></li>
</ul></li>
<li class="chapter" data-level="13" data-path="analysis-of-variance.html"><a href="analysis-of-variance.html"><i class="fa fa-check"></i><b>13</b> Analysis of variance</a></li>
<li class="chapter" data-level="14" data-path="writing-reports.html"><a href="writing-reports.html"><i class="fa fa-check"></i><b>14</b> Writing reports</a></li>
<li class="chapter" data-level="15" data-path="learning-to-code.html"><a href="learning-to-code.html"><i class="fa fa-check"></i><b>15</b> Learning to code</a><ul>
<li class="chapter" data-level="15.1" data-path="learning-to-code.html"><a href="learning-to-code.html#introduction-1"><i class="fa fa-check"></i><b>15.1</b> Introduction</a></li>
<li class="chapter" data-level="15.2" data-path="learning-to-code.html"><a href="learning-to-code.html#data-and-pre-processing"><i class="fa fa-check"></i><b>15.2</b> Data and pre-processing</a></li>
<li class="chapter" data-level="15.3" data-path="learning-to-code.html"><a href="learning-to-code.html#analysis"><i class="fa fa-check"></i><b>15.3</b> Analysis</a></li>
<li class="chapter" data-level="15.4" data-path="learning-to-code.html"><a href="learning-to-code.html#conclusions-see-note-9"><i class="fa fa-check"></i><b>15.4</b> Conclusions (see note 9)</a></li>
</ul></li>
<li class="chapter" data-level="16" data-path="a-comparison-of-four-shampoos-in-treating-dandruff.html"><a href="a-comparison-of-four-shampoos-in-treating-dandruff.html"><i class="fa fa-check"></i><b>16</b> A comparison of four shampoos in treating dandruff</a><ul>
<li class="chapter" data-level="16.1" data-path="a-comparison-of-four-shampoos-in-treating-dandruff.html"><a href="a-comparison-of-four-shampoos-in-treating-dandruff.html#introduction-2"><i class="fa fa-check"></i><b>16.1</b> Introduction</a></li>
<li class="chapter" data-level="16.2" data-path="a-comparison-of-four-shampoos-in-treating-dandruff.html"><a href="a-comparison-of-four-shampoos-in-treating-dandruff.html#exploratory-analysis"><i class="fa fa-check"></i><b>16.2</b> Exploratory analysis</a></li>
<li class="chapter" data-level="16.3" data-path="a-comparison-of-four-shampoos-in-treating-dandruff.html"><a href="a-comparison-of-four-shampoos-in-treating-dandruff.html#analysis-of-variance-1"><i class="fa fa-check"></i><b>16.3</b> Analysis of Variance</a></li>
<li class="chapter" data-level="16.4" data-path="a-comparison-of-four-shampoos-in-treating-dandruff.html"><a href="a-comparison-of-four-shampoos-in-treating-dandruff.html#assessment-of-assumptions"><i class="fa fa-check"></i><b>16.4</b> Assessment of Assumptions</a></li>
<li class="chapter" data-level="16.5" data-path="a-comparison-of-four-shampoos-in-treating-dandruff.html"><a href="a-comparison-of-four-shampoos-in-treating-dandruff.html#conclusions"><i class="fa fa-check"></i><b>16.5</b> Conclusions</a></li>
<li class="chapter" data-level="16.6" data-path="a-comparison-of-four-shampoos-in-treating-dandruff.html"><a href="a-comparison-of-four-shampoos-in-treating-dandruff.html#end"><i class="fa fa-check"></i><b>16.6</b> End</a></li>
</ul></li>
<li class="chapter" data-level="17" data-path="tidying-data.html"><a href="tidying-data.html"><i class="fa fa-check"></i><b>17</b> Tidying data</a></li>
<li class="chapter" data-level="18" data-path="simple-regression.html"><a href="simple-regression.html"><i class="fa fa-check"></i><b>18</b> Simple regression</a></li>
<li class="chapter" data-level="19" data-path="multiple-regression.html"><a href="multiple-regression.html"><i class="fa fa-check"></i><b>19</b> Multiple regression</a></li>
<li class="chapter" data-level="20" data-path="regression-with-categorical-variables.html"><a href="regression-with-categorical-variables.html"><i class="fa fa-check"></i><b>20</b> Regression with categorical variables</a><ul>
<li class="chapter" data-level="20.1" data-path="regression-with-categorical-variables.html"><a href="regression-with-categorical-variables.html#crickets-revisited"><i class="fa fa-check"></i><b>20.1</b> Crickets revisited</a></li>
<li class="chapter" data-level="20.2" data-path="regression-with-categorical-variables.html"><a href="regression-with-categorical-variables.html#pulse-rates-and-marching"><i class="fa fa-check"></i><b>20.2</b> Pulse rates and marching</a></li>
<li class="chapter" data-level="20.3" data-path="regression-with-categorical-variables.html"><a href="regression-with-categorical-variables.html#crickets-revisited-1"><i class="fa fa-check"></i><b>20.3</b> Crickets revisited</a></li>
<li class="chapter" data-level="20.4" data-path="regression-with-categorical-variables.html"><a href="regression-with-categorical-variables.html#pulse-rates-and-marching-1"><i class="fa fa-check"></i><b>20.4</b> Pulse rates and marching</a></li>
</ul></li>
<li class="chapter" data-level="21" data-path="dates-and-times.html"><a href="dates-and-times.html"><i class="fa fa-check"></i><b>21</b> Dates and times</a></li>
<li class="chapter" data-level="22" data-path="functions.html"><a href="functions.html"><i class="fa fa-check"></i><b>22</b> Functions</a></li>
<li class="chapter" data-level="23" data-path="vector-and-matrix-algebra.html"><a href="vector-and-matrix-algebra.html"><i class="fa fa-check"></i><b>23</b> Vector and matrix algebra</a><ul>
<li class="chapter" data-level="23.1" data-path="vector-and-matrix-algebra.html"><a href="vector-and-matrix-algebra.html#heights-and-foot-lengths-again"><i class="fa fa-check"></i><b>23.1</b> Heights and foot lengths again</a></li>
<li class="chapter" data-level="23.2" data-path="vector-and-matrix-algebra.html"><a href="vector-and-matrix-algebra.html#heights-and-foot-lengths-again-1"><i class="fa fa-check"></i><b>23.2</b> Heights and foot lengths again</a></li>
</ul></li>
<li class="chapter" data-level="24" data-path="the-bootstrap.html"><a href="the-bootstrap.html"><i class="fa fa-check"></i><b>24</b> The Bootstrap</a></li>
<li class="chapter" data-level="25" data-path="bayesian-statistics-with-stan.html"><a href="bayesian-statistics-with-stan.html"><i class="fa fa-check"></i><b>25</b> Bayesian Statistics with Stan</a></li>
<li class="chapter" data-level="26" data-path="logistic-regression.html"><a href="logistic-regression.html"><i class="fa fa-check"></i><b>26</b> Logistic regression</a></li>
<li class="chapter" data-level="27" data-path="logistic-regression-with-ordinal-response.html"><a href="logistic-regression-with-ordinal-response.html"><i class="fa fa-check"></i><b>27</b> Logistic regression with ordinal response</a></li>
<li class="chapter" data-level="28" data-path="logistic-regression-with-nominal-response.html"><a href="logistic-regression-with-nominal-response.html"><i class="fa fa-check"></i><b>28</b> Logistic regression with nominal response</a></li>
<li class="chapter" data-level="29" data-path="survival-analysis.html"><a href="survival-analysis.html"><i class="fa fa-check"></i><b>29</b> Survival analysis</a></li>
<li class="chapter" data-level="30" data-path="analysis-of-variance-revisited.html"><a href="analysis-of-variance-revisited.html"><i class="fa fa-check"></i><b>30</b> Analysis of variance revisited</a></li>
<li class="chapter" data-level="31" data-path="analysis-of-covariance.html"><a href="analysis-of-covariance.html"><i class="fa fa-check"></i><b>31</b> Analysis of covariance</a></li>
<li class="chapter" data-level="32" data-path="multivariate-analysis-of-variance.html"><a href="multivariate-analysis-of-variance.html"><i class="fa fa-check"></i><b>32</b> Multivariate analysis of variance</a></li>
<li class="chapter" data-level="33" data-path="repeated-measures.html"><a href="repeated-measures.html"><i class="fa fa-check"></i><b>33</b> Repeated measures</a></li>
<li class="chapter" data-level="34" data-path="discriminant-analysis.html"><a href="discriminant-analysis.html"><i class="fa fa-check"></i><b>34</b> Discriminant analysis</a></li>
<li class="chapter" data-level="35" data-path="hierarchical-cluster-analysis.html"><a href="hierarchical-cluster-analysis.html"><i class="fa fa-check"></i><b>35</b> Hierarchical cluster analysis</a></li>
<li class="chapter" data-level="36" data-path="k-means-cluster-analysis.html"><a href="k-means-cluster-analysis.html"><i class="fa fa-check"></i><b>36</b> K-means cluster analysis</a><ul>
<li class="chapter" data-level="36.1" data-path="k-means-cluster-analysis.html"><a href="k-means-cluster-analysis.html#clustering-the-australian-athletes"><i class="fa fa-check"></i><b>36.1</b> Clustering the Australian athletes</a></li>
<li class="chapter" data-level="36.2" data-path="k-means-cluster-analysis.html"><a href="k-means-cluster-analysis.html#running-jumping-and-throwing"><i class="fa fa-check"></i><b>36.2</b> Running, jumping, and throwing</a></li>
<li class="chapter" data-level="36.3" data-path="k-means-cluster-analysis.html"><a href="k-means-cluster-analysis.html#clustering-the-swiss-bills"><i class="fa fa-check"></i><b>36.3</b> Clustering the Swiss bills</a></li>
<li class="chapter" data-level="36.4" data-path="k-means-cluster-analysis.html"><a href="k-means-cluster-analysis.html#grouping-similar-cars"><i class="fa fa-check"></i><b>36.4</b> Grouping similar cars</a></li>
<li class="chapter" data-level="36.5" data-path="k-means-cluster-analysis.html"><a href="k-means-cluster-analysis.html#rating-beer"><i class="fa fa-check"></i><b>36.5</b> Rating beer</a></li>
<li class="chapter" data-level="36.6" data-path="k-means-cluster-analysis.html"><a href="k-means-cluster-analysis.html#clustering-the-australian-athletes-1"><i class="fa fa-check"></i><b>36.6</b> Clustering the Australian athletes</a></li>
<li class="chapter" data-level="36.7" data-path="k-means-cluster-analysis.html"><a href="k-means-cluster-analysis.html#running-jumping-and-throwing-1"><i class="fa fa-check"></i><b>36.7</b> Running, jumping, and throwing</a></li>
<li class="chapter" data-level="36.8" data-path="k-means-cluster-analysis.html"><a href="k-means-cluster-analysis.html#clustering-the-swiss-bills-1"><i class="fa fa-check"></i><b>36.8</b> Clustering the Swiss bills</a></li>
<li class="chapter" data-level="36.9" data-path="k-means-cluster-analysis.html"><a href="k-means-cluster-analysis.html#grouping-similar-cars-1"><i class="fa fa-check"></i><b>36.9</b> Grouping similar cars</a></li>
<li class="chapter" data-level="36.10" data-path="k-means-cluster-analysis.html"><a href="k-means-cluster-analysis.html#rating-beer-1"><i class="fa fa-check"></i><b>36.10</b> Rating beer</a></li>
</ul></li>
<li class="chapter" data-level="37" data-path="drawing-maps-with-leaflet.html"><a href="drawing-maps-with-leaflet.html"><i class="fa fa-check"></i><b>37</b> Drawing maps with Leaflet</a></li>
<li class="chapter" data-level="38" data-path="multidimensional-scaling.html"><a href="multidimensional-scaling.html"><i class="fa fa-check"></i><b>38</b> Multidimensional Scaling</a></li>
<li class="chapter" data-level="39" data-path="principal-components.html"><a href="principal-components.html"><i class="fa fa-check"></i><b>39</b> Principal Components</a><ul>
<li class="chapter" data-level="39.1" data-path="principal-components.html"><a href="principal-components.html#the-weather-somewhere"><i class="fa fa-check"></i><b>39.1</b> The weather, somewhere</a></li>
<li class="chapter" data-level="39.2" data-path="principal-components.html"><a href="principal-components.html#the-weather-somewhere-1"><i class="fa fa-check"></i><b>39.2</b> The weather, somewhere</a></li>
</ul></li>
<li class="chapter" data-level="40" data-path="factor-analysis.html"><a href="factor-analysis.html"><i class="fa fa-check"></i><b>40</b> Factor Analysis</a></li>
<li class="chapter" data-level="41" data-path="frequency-table-analysis.html"><a href="frequency-table-analysis.html"><i class="fa fa-check"></i><b>41</b> Frequency table analysis</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Problems and Solutions in Applied Statistics</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="k-means-cluster-analysis" class="section level1">
<h1><span class="header-section-number">Chapter 36</span> K-means cluster analysis</h1>
<p>Packages for this chapter:</p>
<div class="sourceCode" id="cb209"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb209-1" title="1"><span class="kw">library</span>(MASS)</a>
<a class="sourceLine" id="cb209-2" title="2"><span class="kw">library</span>(ggbiplot)</a>
<a class="sourceLine" id="cb209-3" title="3"><span class="kw">library</span>(tidyverse)</a></code></pre></div>
<div id="clustering-the-australian-athletes" class="section level2">
<h2><span class="header-section-number">36.1</span> Clustering the Australian athletes</h2>
<p>Recall the Australian athlete data (that we’ve seen so many
times before). This time, we’ll do some K-means clustering, and then
see whether athletes of certain genders and certain sports tend to end
up in the same cluster.</p>
<ol style="list-style-type: lower-alpha">
<li><p>Read in the data from
<a href="https://raw.githubusercontent.com/nxskok/datafiles/master/ais.txt">link</a>, recalling
that the data values are separated by tabs. Display (some of) the
data set.</p></li>
<li><p>From your data frame, select only the columns that are numbers
(or get rid of the ones that are text), and standardize all of the
columns you have left. This is, done the best way, a slick piece of
code. Display what you get.</p></li>
<li><p>Make a data frame that contains the total within-cluster sum
of squares from a K-means clustering for each number of clusters
from 2 to 20.</p></li>
<li><p>Use the data frame you just created to make a scree plot. What
does the scree plot tell you?</p></li>
<li><p>Using a sensible number of clusters as deduced from your scree
plot, run a K-means cluster analysis. Don’t forget the
<code>nstart</code>!</p></li>
<li><p>Make a data frame consisting of the athletes’ sport and
gender, and which of your clusters they belong to, taking the
appropriate things from the appropriate one of your data frames.</p></li>
<li><p>Using the data frame you created in the previous part, display
all the athletes in some of your clusters. Do the athletes within a
cluster appear to have anything in common? (If a cluster has more
than 10 athletes in it, make sure to look at them all.)</p></li>
<li><p>Add the cluster membership to the data frame you read in from
the file, and do a discriminant analysis treating the clusters as
known groups. You can display the output.</p></li>
<li><p>How many linear discriminants do you have? How many do you
think are important?</p></li>
<li><p>Which variables seem to be important in distinguishing the
clusters? Look only at the linear discriminants that you judged to
be important.</p></li>
<li><p>Draw a biplot (which shows the first two LDs), drawing the
clusters in different colours. Comment briefly on anything
especially consistent or inconsistent with what you’ve seen so far.</p></li>
</ol>
</div>
<div id="running-jumping-and-throwing" class="section level2">
<h2><span class="header-section-number">36.2</span> Running, jumping, and throwing</h2>
<p>The <a href="https://en.wikipedia.org/wiki/Decathlon">decathlon</a> is a men’s<a href="#fn36" class="footnote-ref" id="fnref36"><sup>36</sup></a> track-and-field competition in which competitors complete 10
events over two days as follows, requiring the skills shown:</p>
<table>
<thead>
<tr class="header">
<th align="left">Event</th>
<th align="left">Skills</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">100m</td>
<td align="left">Running, speed</td>
</tr>
<tr class="even">
<td align="left">Long jump</td>
<td align="left">Jumping, speed</td>
</tr>
<tr class="odd">
<td align="left">Shot put</td>
<td align="left">Throwing, strength</td>
</tr>
<tr class="even">
<td align="left">High jump</td>
<td align="left">Jumping, agility</td>
</tr>
<tr class="odd">
<td align="left">400m</td>
<td align="left">Running, speed</td>
</tr>
<tr class="even">
<td align="left">110m hurdles</td>
<td align="left">Running, jumping, speed</td>
</tr>
<tr class="odd">
<td align="left">Discus</td>
<td align="left">Throwing, agility (and maybe strength)</td>
</tr>
<tr class="even">
<td align="left">Pole vault</td>
<td align="left">Jumping, agility</td>
</tr>
<tr class="odd">
<td align="left">Javelin</td>
<td align="left">Throwing, agility</td>
</tr>
<tr class="even">
<td align="left">1500m</td>
<td align="left">Running, endurance</td>
</tr>
</tbody>
</table>

<p>(note: in the pdf version, this table might appear twice.)</p>
<p>These are a mixture of running, jumping and throwing disciplines. The
performance (time, distance or height) achieved in each event is
converted to a number of points using <a href="https://en.wikipedia.org/wiki/Decathlon#Points_system">standard tables</a>.
and the winner of the entire decathlon is the
competitor with the largest total of points. The basic idea is that a “good” performance in an event is worth 1000 points, and the score decreases if the athlete takes more seconds (running) or achieves fewer metres (jumping/throwing).
A good decathlete has to
be at least reasonably good at all the disciplines.</p>
<p>For the decathlon competition at the 2013 Track and Field World
Championship, a record was kept of each competitor’s performance in
each event (for the competitors that competed in all ten
events). These values are in
<a href="http://ritsokiguess.site/datafiles/dec2013.txt">link</a>.</p>
<ol style="list-style-type: lower-alpha">
<li><p>Read in the data and verify that you have the right number
of variables.</p></li>
<li><p>Some of the performances are times in seconds, and some of
them are distances (or heights) in metres. Also, some of the columns
are more variable than others. Produce a matrix of standardized
performances in each event, making sure not to try to standardize
the names!</p></li>
<li><p>We are going to make a scree plot to decide on the number
of clusters our K-means clustering should use. Using a loop, or
otherwise,<a href="#fn37" class="footnote-ref" id="fnref37"><sup>37</sup></a> obtain the total within-cluster sum of squares for these
data for each number of clusters for 2 up to 20.</p></li>
<li><p>Using what you calculated in the previous part, draw a scree
plot. How does your
scree plot tell you that 5 is a possible number of clusters? Explain
briefly.</p></li>
<li><p>Run K-means with 5 clusters. Produce an output that shows
which competitors are in which cluster.</p></li>
<li><p>Display the cluster means for all of the events. (This has
already been calculated; you just have to display it.) Find the
cluster mean, looking at all of the events, that is farthest from
zero, and see if you can describe the strengths and weaknesses of the
athletes in that cluster (look at all the events for the cluster that
has that extreme mean). Bear in mind (i) that these are the original
performances standardized, and (ii) for a running event, a
<em>smaller</em> value is better.</p></li>
</ol>
</div>
<div id="clustering-the-swiss-bills" class="section level2">
<h2><span class="header-section-number">36.3</span> Clustering the Swiss bills</h2>
<p>This question is about the Swiss bank counterfeit bills
again. This time we’re going to ignore whether each bill is
counterfeit or not, and see what groups they break into. Then, at
the end, we’ll see whether cluster analysis was able to pick out the
counterfeit ones or not.</p>
<ol style="list-style-type: lower-alpha">
<li><p>Read the data in again (just like last time), and look at
the first few rows. This is just the same as before.</p></li>
<li><p>The variables in this data frame are on different
scales. Standardize them so that they all have mean 0 and standard
deviation 1. (Don’t try to standardize the <code>status</code> column!)</p></li>
<li><p>We are going to make a scree plot. First, calculate the total
within-cluster SS for each number of clusters from 2 to 10.</p></li>
<li><p><a name="part:howmany">*</a> Make a scree plot (creating a data frame
first if you need). How many clusters do you think you
should use?</p></li>
<li><p>Run K-means with the number of clusters that you found in
(<a href="#part:howmany">here</a>). How many bills are in each cluster?</p></li>
<li><p>Make a table showing cluster membership against actual
status (counterfeit or genuine). Are the counterfeit bills mostly
in certain clusters?</p></li>
</ol>
</div>
<div id="grouping-similar-cars" class="section level2">
<h2><span class="header-section-number">36.4</span> Grouping similar cars</h2>
<p>The file
<a href="https://raw.githubusercontent.com/nxskok/datafiles/master/car-cluster.csv">link</a> contains
information on seven variables
for 32 different cars. The variables are:</p>
<ul>
<li><p><code>Carname</code>: name of the car (duh!)</p></li>
<li><p><code>mpg</code>: gas consumption in miles per US gallon (higher means the car uses less gas)</p></li>
<li><p><code>disp</code>: engine displacement (total volume of cylinders in engine): higher is more powerful</p></li>
<li><p><code>hp</code>: engine horsepower (higher means a more powerful engine)</p></li>
<li><p><code>drat</code>: rear axle ratio (higher means more powerful but worse gas mileage)</p></li>
<li><p><code>wt</code>: car weight in US tons</p></li>
<li><p><code>qsec</code>: time needed for the car to cover a quarter mile (lower means faster)</p></li>
</ul>
<ol style="list-style-type: lower-alpha">
<li><p>Read in the data and display its structure. Do you have the
right number of cars and variables?</p></li>
<li><p>The variables are all measured on different scales. Use
<code>scale</code> to produce a matrix of standardized (<span class="math inline">\(z\)</span>-score) values
for the columns of your data that are numbers.</p></li>
<li><p>Run a K-means cluster analysis for these data, obtaining 3
clusters, and display the results. Take whatever action you need to
obtain the best (random) result from a number of runs.</p></li>
<li><p>Display the car names together with which cluster they are
in. If you display them all at once, sort by cluster so that it’s
easier to see which clusters contain which cars. (You may have to make
a data frame first.)</p></li>
<li><p>I have no idea whether 3 is a sensible number of clusters. To
find out, we will draw a scree plot (in a moment). Write a function
that accepts the number of clusters and the (scaled) data,
and returns the total within-cluster sum of squares.</p></li>
<li><p>Calculate the total within-group sum of squares for each
number of clusters from 2 to 10, using the function you just wrote.</p></li>
<li><p>Make a scree plot, using the total within-cluster sums of
squares values that you calculated in the previous part.</p></li>
<li><p>What is a suitable number of clusters for K-means, based on
your scree plot?</p></li>
<li><p>Run a K-means analysis using the number of clusters suggested
by your scree plot, and list the car names together with the clusters
they belong to, <em>sorted by cluster</em>.</p></li>
</ol>
</div>
<div id="rating-beer" class="section level2">
<h2><span class="header-section-number">36.5</span> Rating beer</h2>
<p>Thirty-two students each rated 10 brands of beer:</p>
<ul>
<li><p>Anchor Steam</p></li>
<li><p>Bass</p></li>
<li><p>Beck’s</p></li>
<li><p>Corona</p></li>
<li><p>Gordon Biersch</p></li>
<li><p>Guinness</p></li>
<li><p>Heineken</p></li>
<li><p>Pete’s Wicked Ale</p></li>
<li><p>Sam Adams</p></li>
<li><p>Sierra Nevada</p></li>
</ul>
<p>The ratings are on a scale of 1 to 9, with a higher
rating being better.
The data are in
<a href="http://ritsokiguess.site/datafiles/beer.txt">link</a>. I
abbreviated the beer names for the data file. I hope you can figure
out which is which.</p>
<ol style="list-style-type: lower-alpha">
<li><p>Read in the data, and look at the first few rows.</p></li>
<li><p>The researcher who collected the data wants to see which
beers are rated similarly to which other beers. Try to create a
distance matrix from these data and explain why it didn’t do what
you wanted. (Remember to get rid of the <code>student</code> column
first.)</p></li>
<li><p>The R function <code>t()</code> <em>transposes</em> a matrix: that
is, it interchanges rows and columns. Feed the transpose of your
read-in beer ratings into <code>dist</code>. Does this now give
distances between beers?</p></li>
<li><p>Try to explain briefly why I used <code>as.dist</code> in the
class example (the languages one) but <code>dist</code> here. (Think
about the form of the input to each function.)</p></li>
<li><p><a name="part:beer-dendro">*</a> Obtain a clustering of the beers, using Ward’s method. Show
the dendrogram.</p></li>
<li><p>What seems to be a sensible number of clusters? Which
beers are in which cluster?</p></li>
<li><p>Re-draw your dendrogram with your clusters indicated.</p></li>
<li><p>Obtain a K-means
clustering with 2 clusters.<a href="#fn38" class="footnote-ref" id="fnref38"><sup>38</sup></a>
Note that you will need to use the (transposed)
<em>original data</em>, not the distances. Use a suitably large value of
<code>nstart</code>. (The data are ratings all on the same scale, so
there is no need for <code>scale</code> here. In case you were
wondering.)</p></li>
<li><p>How many beers are in each cluster?</p></li>
<li><p><em>Which</em> beers are in each cluster? You can do this
simply by obtaining the cluster memberships and using
<code>sort</code> as in the last question, or you can do it as I did
in class by obtaining the
names of the things to be clustered and picking out the ones of
them that are in cluster 1, 2, 3, .)</p></li>
</ol>
<p>My solutions follow:</p>
</div>
<div id="clustering-the-australian-athletes-1" class="section level2">
<h2><span class="header-section-number">36.6</span> Clustering the Australian athletes</h2>
<p>Recall the Australian athlete data (that we’ve seen so many
times before). This time, we’ll do some K-means clustering, and then
see whether athletes of certain genders and certain sports tend to end
up in the same cluster.</p>
<ol style="list-style-type: lower-alpha">
<li>Read in the data from
<a href="https://raw.githubusercontent.com/nxskok/datafiles/master/ais.txt">link</a>, recalling
that the data values are separated by tabs. Display (some of) the
data set.</li>
</ol>
<p>Solution</p>
<p>So, <code>read_tsv</code>.</p>
<div class="sourceCode" id="cb210"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb210-1" title="1">my_url &lt;-<span class="st"> &quot;https://raw.githubusercontent.com/nxskok/datafiles/master/ais.txt&quot;</span></a>
<a class="sourceLine" id="cb210-2" title="2">athletes &lt;-<span class="st"> </span><span class="kw">read_tsv</span>(my_url)</a></code></pre></div>
<pre><code>## 
## ── Column specification ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## cols(
##   Sex = col_character(),
##   Sport = col_character(),
##   RCC = col_double(),
##   WCC = col_double(),
##   Hc = col_double(),
##   Hg = col_double(),
##   Ferr = col_double(),
##   BMI = col_double(),
##   SSF = col_double(),
##   `%Bfat` = col_double(),
##   LBM = col_double(),
##   Ht = col_double(),
##   Wt = col_double()
## )</code></pre>
<div class="sourceCode" id="cb212"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb212-1" title="1">athletes</a></code></pre></div>
<pre><code>## # A tibble: 202 x 13
##    Sex    Sport     RCC   WCC    Hc    Hg  Ferr   BMI   SSF `%Bfat`   LBM    Ht    Wt
##    &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 female Netball  4.56  13.3  42.2  13.6    20  19.2  49      11.3  53.1  177.  59.9
##  2 female Netball  4.15   6    38    12.7    59  21.2 110.     25.3  47.1  173.  63  
##  3 female Netball  4.16   7.6  37.5  12.3    22  21.4  89      19.4  53.4  176   66.3
##  4 female Netball  4.32   6.4  37.7  12.3    30  21.0  98.3    19.6  48.8  170.  60.7
##  5 female Netball  4.06   5.8  38.7  12.8    78  21.8 122.     23.1  56.0  183   72.9
##  6 female Netball  4.12   6.1  36.6  11.8    21  21.4  90.4    16.9  56.4  178.  67.9
##  7 female Netball  4.17   5    37.4  12.7   109  21.5 107.     21.3  53.1  177.  67.5
##  8 female Netball  3.8    6.6  36.5  12.4   102  24.4 157.     26.6  54.4  174.  74.1
##  9 female Netball  3.96   5.5  36.3  12.4    71  22.6 101.     17.9  56.0  174.  68.2
## 10 female Netball  4.44   9.7  41.4  14.1    64  22.8 126.     25.0  51.6  174.  68.8
## # … with 192 more rows</code></pre>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="2" style="list-style-type: lower-alpha">
<li>From your data frame, select only the columns that are numbers
(or get rid of the ones that are text), and standardize all of the
columns you have left. This is, done the best way, a slick piece of
code. Display what you get.</li>
</ol>
<p>Solution</p>
<p>This first one is a bit <em>too</em> slick:</p>
<div class="sourceCode" id="cb214"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb214-1" title="1">athletes <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(<span class="kw">across</span>(<span class="kw">where</span>(is.numeric), <span class="op">~</span><span class="kw">scale</span>(.)))</a></code></pre></div>
<pre><code>## # A tibble: 202 x 13
##    Sex    Sport   RCC[,1] WCC[,1] Hc[,1] Hg[,1] Ferr[,1] BMI[,1] SSF[,1] `%Bfat`[,1] LBM[,1] Ht[,1]  Wt[,1]
##    &lt;chr&gt;  &lt;chr&gt;     &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;
##  1 female Netball  -0.346   3.44  -0.243 -0.709  -1.20   -1.33    -0.615      -0.358  -0.898 -0.339 -1.08  
##  2 female Netball  -1.24   -0.616 -1.39  -1.37   -0.376  -0.631    1.26        1.90   -1.36  -0.771 -0.862 
##  3 female Netball  -1.22    0.273 -1.53  -1.66   -1.16   -0.543    0.613       0.950  -0.875 -0.422 -0.625 
##  4 female Netball  -0.870  -0.394 -1.47  -1.66   -0.987  -0.672    0.899       0.989  -1.23  -1.05  -1.03  
##  5 female Netball  -1.44   -0.727 -1.20  -1.30    0.0237 -0.414    1.63        1.55   -0.675  0.298 -0.151 
##  6 female Netball  -1.31   -0.560 -1.77  -2.03   -1.18   -0.550    0.656       0.542  -0.644 -0.196 -0.510 
##  7 female Netball  -1.20   -1.17  -1.55  -1.37    0.676  -0.519    1.16        1.26   -0.900 -0.288 -0.539 
##  8 female Netball  -2.01   -0.283 -1.80  -1.59    0.529   0.522    2.69        2.11   -0.801 -0.617 -0.0652
##  9 female Netball  -1.66   -0.893 -1.85  -1.59   -0.124  -0.114    0.985       0.714  -0.681 -0.668 -0.489 
## 10 female Netball  -0.608   1.44  -0.462 -0.342  -0.271  -0.0544   1.76        1.85   -1.01  -0.658 -0.446 
## # … with 192 more rows</code></pre>
<p>It standardizes all the columns that are numeric all right, but any other columns it finds it leaves as they are, while we want to get rid of them first. So do it in two steps: get the numeric columns, and standardize <em>all</em> of those:</p>
<div class="sourceCode" id="cb216"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb216-1" title="1">athletes <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(<span class="kw">where</span>(is.numeric)) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb216-2" title="2"><span class="st">  </span><span class="kw">mutate</span>(<span class="kw">across</span>(<span class="kw">everything</span>(), <span class="op">~</span><span class="kw">scale</span>(.))) -&gt;<span class="st"> </span>athletes.s</a></code></pre></div>
<p>This, in fact:</p>
<div class="sourceCode" id="cb217"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb217-1" title="1">athletes.s</a></code></pre></div>
<pre><code>## # A tibble: 202 x 11
##    RCC[,1] WCC[,1] Hc[,1] Hg[,1] Ferr[,1] BMI[,1] SSF[,1] `%Bfat`[,1] LBM[,1] Ht[,1]  Wt[,1]
##      &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;
##  1  -0.346   3.44  -0.243 -0.709  -1.20   -1.33    -0.615      -0.358  -0.898 -0.339 -1.08  
##  2  -1.24   -0.616 -1.39  -1.37   -0.376  -0.631    1.26        1.90   -1.36  -0.771 -0.862 
##  3  -1.22    0.273 -1.53  -1.66   -1.16   -0.543    0.613       0.950  -0.875 -0.422 -0.625 
##  4  -0.870  -0.394 -1.47  -1.66   -0.987  -0.672    0.899       0.989  -1.23  -1.05  -1.03  
##  5  -1.44   -0.727 -1.20  -1.30    0.0237 -0.414    1.63        1.55   -0.675  0.298 -0.151 
##  6  -1.31   -0.560 -1.77  -2.03   -1.18   -0.550    0.656       0.542  -0.644 -0.196 -0.510 
##  7  -1.20   -1.17  -1.55  -1.37    0.676  -0.519    1.16        1.26   -0.900 -0.288 -0.539 
##  8  -2.01   -0.283 -1.80  -1.59    0.529   0.522    2.69        2.11   -0.801 -0.617 -0.0652
##  9  -1.66   -0.893 -1.85  -1.59   -0.124  -0.114    0.985       0.714  -0.681 -0.668 -0.489 
## 10  -0.608   1.44  -0.462 -0.342  -0.271  -0.0544   1.76        1.85   -1.01  -0.658 -0.446 
## # … with 192 more rows</code></pre>
<p>The columns might have weird names, possibly because <code>scale</code> expects
a matrix or data frame (to standardize each column), and here it’s
getting the columns one at a time.</p>
<p>Elsewhere, I stuck <code>scale()</code> on the end, which produces a
<em>matrix</em>, which I should then display the top of (it has 200-plus rows):</p>
<div class="sourceCode" id="cb219"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb219-1" title="1">athletes <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(<span class="kw">where</span>(is.numeric)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">scale</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">head</span>()</a></code></pre></div>
<pre><code>##             RCC        WCC         Hc         Hg        Ferr        BMI        SSF      %Bfat        LBM         Ht         Wt
## [1,] -0.3463363  3.4385826 -0.2434034 -0.7092631 -1.19736325 -1.3254121 -0.6148189 -0.3582372 -0.8977457 -0.3394075 -1.0849225
## [2,] -1.2415791 -0.6157363 -1.3900079 -1.3698371 -0.37633203 -0.6305634  1.2644802  1.8986922 -1.3606308 -0.7708629 -0.8623105
## [3,] -1.2197439  0.2728816 -1.5265084 -1.6634256 -1.15525908 -0.5432708  0.6134811  0.9503618 -0.8747927 -0.4215895 -0.6253364
## [4,] -0.8703809 -0.3935818 -1.4719082 -1.6634256 -0.98684242 -0.6724638  0.8990609  0.9891351 -1.2313290 -1.0482270 -1.0274742
## [5,] -1.4380958 -0.7268135 -1.1989072 -1.2964400  0.02365754 -0.4140778  1.6298994  1.5513480 -0.6751017  0.2975028 -0.1513883
## [6,] -1.3070846 -0.5601977 -1.7722094 -2.0304111 -1.17631117 -0.5502542  0.6564716  0.5416266 -0.6444978 -0.1955890 -0.5104399</code></pre>
<p>The first athlete has a <code>WCC</code> value that is <em>very</em> large compared
to the others.</p>
<p>Extra: for those keeping track, sometimes you need an <code>across</code> and sometimes you don’t. The place where you need <code>across</code> is when you want to apply something to a bunch of columns all at once. <code>select</code> doesn’t need it, but something like <code>mutate</code> or <code>summarize</code> does, because you are changing the values in or summarizing several columns all at once.</p>
<p>One more: if the columns you are acting on in <code>across</code> are selected using a select helper (or by naming them or in some other way that depends on their <em>names</em>), you put that directly inside <code>across</code> (as in <code>across(everything())</code> above), but if you are choosing the columns to act on by a <em>property</em> of them (eg. that they are numbers), you have a <code>where</code> inside the <code>across</code>, as in <code>across(where(is.numeric))</code>. You typically will be closing several brackets at the end. In R Studio, when you type a close-bracket, it briefly shows you the matching open-bracket so that you can keep track.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="3" style="list-style-type: lower-alpha">
<li>Make a data frame that contains the total within-cluster sum
of squares from a K-means clustering for each number of clusters
from 2 to 20.</li>
</ol>
<p>Solution</p>
<p>I’m going to attempt a slick way of doing this, and then I’ll talk
about how I’d expect <em>you</em> to tackle this. First, though, I
set the random number seed so that everything comes out the same
every time I run it:</p>
<div class="sourceCode" id="cb221"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb221-1" title="1"><span class="kw">set.seed</span>(<span class="dv">457299</span>)</a></code></pre></div>
<p>Here we go:</p>
<div class="sourceCode" id="cb222"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb222-1" title="1">withinss &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">2</span><span class="op">:</span><span class="dv">20</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb222-2" title="2"><span class="st">  </span><span class="kw">rowwise</span>() <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb222-3" title="3"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">wss =</span> <span class="kw">kmeans</span>(athletes.s, clusters, <span class="dt">nstart =</span> <span class="dv">20</span>)<span class="op">$</span>tot.withinss)</a>
<a class="sourceLine" id="cb222-4" title="4">withinss</a></code></pre></div>
<pre><code>## # A tibble: 19 x 2
## # Rowwise: 
##    clusters   wss
##       &lt;int&gt; &lt;dbl&gt;
##  1        2 1426.
##  2        3 1201.
##  3        4 1043.
##  4        5  968.
##  5        6  901.
##  6        7  836.
##  7        8  782.
##  8        9  735.
##  9       10  688.
## 10       11  654.
## 11       12  631.
## 12       13  605.
## 13       14  583.
## 14       15  562.
## 15       16  551.
## 16       17  532.
## 17       18  513.
## 18       19  502.
## 19       20  487.</code></pre>
<p>A one-liner, kinda. Remember that <code>kmeans</code> expects a single number of clusters, a value like 5, rather than a collection of possible numbers of clusters in a vector, so to do each of them, we need to work rowwise (and do one row at a time).</p>
<p>The advantage to this is that it looks exactly like
the <code>kmeans</code> that you would write.</p>
<p>All right then, what is a better way to do this? First write
a function to take a number of clusters and a data frame and return
the total within-cluster sum of squares:</p>
<div class="sourceCode" id="cb224"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb224-1" title="1">twss &lt;-<span class="st"> </span><span class="cf">function</span>(i, x) {</a>
<a class="sourceLine" id="cb224-2" title="2">  ans &lt;-<span class="st"> </span><span class="kw">kmeans</span>(x, i, <span class="dt">nstart =</span> <span class="dv">20</span>)</a>
<a class="sourceLine" id="cb224-3" title="3">  ans<span class="op">$</span>tot.withinss</a>
<a class="sourceLine" id="cb224-4" title="4">}</a></code></pre></div>
<p>and test it (against my answer above):</p>
<div class="sourceCode" id="cb225"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb225-1" title="1"><span class="kw">twss</span>(<span class="dv">3</span>, athletes.s)</a></code></pre></div>
<pre><code>## [1] 1201.346</code></pre>
<p>Check (with a few extra decimals).</p>
<p>Then calculate
all the total within-cluster sum of squares values by making a little
data frame with all your numbers of clusters:</p>
<div class="sourceCode" id="cb227"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb227-1" title="1"><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">2</span><span class="op">:</span><span class="dv">20</span>)</a></code></pre></div>
<pre><code>## # A tibble: 19 x 1
##    clusters
##       &lt;int&gt;
##  1        2
##  2        3
##  3        4
##  4        5
##  5        6
##  6        7
##  7        8
##  8        9
##  9       10
## 10       11
## 11       12
## 12       13
## 13       14
## 14       15
## 15       16
## 16       17
## 17       18
## 18       19
## 19       20</code></pre>
<p>and then make a pipeline and save it, using <code>rowwise</code> and your function:</p>
<div class="sourceCode" id="cb229"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb229-1" title="1"><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">2</span><span class="op">:</span><span class="dv">20</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb229-2" title="2"><span class="st">  </span><span class="kw">rowwise</span>() <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb229-3" title="3"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">wss =</span> <span class="kw">twss</span>(clusters, athletes.s)) -&gt;<span class="st"> </span>withinss</a>
<a class="sourceLine" id="cb229-4" title="4">withinss</a></code></pre></div>
<pre><code>## # A tibble: 19 x 2
## # Rowwise: 
##    clusters   wss
##       &lt;int&gt; &lt;dbl&gt;
##  1        2 1426.
##  2        3 1201.
##  3        4 1043.
##  4        5  968.
##  5        6  901.
##  6        7  836.
##  7        8  777.
##  8        9  733.
##  9       10  696.
## 10       11  658.
## 11       12  626.
## 12       13  608.
## 13       14  585.
## 14       15  569.
## 15       16  551.
## 16       17  527.
## 17       18  511.
## 18       19  504.
## 19       20  489.</code></pre>
<p>This is better because the <code>mutate</code> line is simpler; you have off-loaded the details of the thinking to your function. Read this as “for each number of clusters, work out the total within-cluster sum of squares for that number of clusters.” The important thing here is what you are doing, not how you are doing it; if you care about the how-you-are-doing-it, go back and look at your function. Remember that business about how you can only keep track of seven things, plus or minus two, at once? When you write a function, you are saving some of the things you have to keep track of.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="4" style="list-style-type: lower-alpha">
<li>Use the data frame you just created to make a scree plot. What
does the scree plot tell you?</li>
</ol>
<p>Solution</p>
<p><code>ggscreeplot</code> is for principal components; this one you can
plot directly, with the points joined by lines:</p>
<div class="sourceCode" id="cb231"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb231-1" title="1"><span class="kw">ggplot</span>(withinss, <span class="kw">aes</span>(<span class="dt">x =</span> clusters, <span class="dt">y =</span> wss)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>()</a></code></pre></div>
<p><img src="pasias_files/figure-html/unnamed-chunk-144-1.png" width="672" /></p>
<p>On this plot, you are looking for “elbows”, but ones sufficiently
far down the mountain. For example, that’s an elbow at 4 clusters, but
it’s still up the mountain, which means that the total within-cluster
sum of squares is quite large and that the athletes within those 4
clusters might be quite dissimilar from each other. I see an elbow at
12 clusters and possibly others at 14, 16 and 19; these are nearer the bottom
of the mountain, so that the athletes within a cluster will be quite
similar to each other. With over 200 athletes, there’s no problem
having as many as 19 clusters, because that will still offer you some
insight.</p>
<p>So I’m thinking 12 clusters (because I want to have a fairly small
number of clusters to interpret later).</p>
<p>The other thing I’m thinking is I could have put a bigger number of
clusters on the scree plot. The <code>wss</code> axis should go all the
way down to 0 for 202 clusters, with each athlete in one cluster. So
you could make the point that even 20 clusters is still a fair way up
the mountain.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="5" style="list-style-type: lower-alpha">
<li>Using a sensible number of clusters as deduced from your scree
plot, run a K-means cluster analysis. Don’t forget the
<code>nstart</code>!</li>
</ol>
<p>Solution</p>
<p>This:</p>
<div class="sourceCode" id="cb232"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb232-1" title="1">athletes.km &lt;-<span class="st"> </span><span class="kw">kmeans</span>(athletes.s, <span class="dv">12</span>, <span class="dt">nstart =</span> <span class="dv">20</span>)</a></code></pre></div>
<p>or for your chosen number of clusters.</p>
<p>I don’t think there’s any great need to display the output, since the
most interesting thing is which athletes are in which cluster, which
we’ll get to next.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="6" style="list-style-type: lower-alpha">
<li>Make a data frame consisting of the athletes’ sport and
gender, and which of your clusters they belong to, taking the
appropriate things from the appropriate one of your data frames.</li>
</ol>
<p>Solution</p>
<div class="sourceCode" id="cb233"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb233-1" title="1">athletes2 &lt;-<span class="st"> </span><span class="kw">tibble</span>(</a>
<a class="sourceLine" id="cb233-2" title="2">  <span class="dt">gender =</span> athletes<span class="op">$</span>Sex,</a>
<a class="sourceLine" id="cb233-3" title="3">  <span class="dt">sport =</span> athletes<span class="op">$</span>Sport,</a>
<a class="sourceLine" id="cb233-4" title="4">  <span class="dt">cluster =</span> athletes.km<span class="op">$</span>cluster</a>
<a class="sourceLine" id="cb233-5" title="5">)</a>
<a class="sourceLine" id="cb233-6" title="6">athletes2</a></code></pre></div>
<pre><code>## # A tibble: 202 x 3
##    gender sport   cluster
##    &lt;chr&gt;  &lt;chr&gt;     &lt;int&gt;
##  1 female Netball      12
##  2 female Netball       9
##  3 female Netball       9
##  4 female Netball       9
##  5 female Netball       9
##  6 female Netball       9
##  7 female Netball       9
##  8 female Netball      11
##  9 female Netball       9
## 10 female Netball      11
## # … with 192 more rows</code></pre>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="7" style="list-style-type: lower-alpha">
<li>Using the data frame you created in the previous part, display
all the athletes in some of your clusters. Do the athletes within a
cluster appear to have anything in common? (If a cluster has more
than 10 athletes in it, make sure to look at them all.)</li>
</ol>
<p>Solution</p>
<p>Let’s start with my cluster 1:</p>
<div class="sourceCode" id="cb235"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb235-1" title="1">athletes2 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(cluster <span class="op">==</span><span class="st"> </span><span class="dv">1</span>)</a></code></pre></div>
<pre><code>## # A tibble: 17 x 3
##    gender sport  cluster
##    &lt;chr&gt;  &lt;chr&gt;    &lt;int&gt;
##  1 male   Swim         1
##  2 male   Row          1
##  3 male   Row          1
##  4 male   Row          1
##  5 male   Row          1
##  6 male   Row          1
##  7 male   Field        1
##  8 male   TSprnt       1
##  9 male   Field        1
## 10 male   WPolo        1
## 11 male   WPolo        1
## 12 male   WPolo        1
## 13 male   WPolo        1
## 14 male   WPolo        1
## 15 male   WPolo        1
## 16 male   WPolo        1
## 17 male   WPolo        1</code></pre>
<p>These are almost all female, and if you remember back to our study of
height and weight for these data, these are the kinds of sport that
are played by shorter, lighter people.
Cluster 2:</p>
<div class="sourceCode" id="cb237"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb237-1" title="1">athletes2 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(cluster <span class="op">==</span><span class="st"> </span><span class="dv">2</span>) </a></code></pre></div>
<pre><code>## # A tibble: 6 x 3
##   gender sport  cluster
##   &lt;chr&gt;  &lt;chr&gt;    &lt;int&gt;
## 1 male   BBall        2
## 2 male   Field        2
## 3 male   Field        2
## 4 male   Field        2
## 5 male   TSprnt       2
## 6 male   WPolo        2</code></pre>
<p>Males, apparently some of the more muscular ones, but not the field
athletes.</p>
<div class="sourceCode" id="cb239"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb239-1" title="1">athletes2 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(cluster <span class="op">==</span><span class="st"> </span><span class="dv">3</span>) </a></code></pre></div>
<pre><code>## # A tibble: 5 x 3
##   gender sport cluster
##   &lt;chr&gt;  &lt;chr&gt;   &lt;int&gt;
## 1 female Field       3
## 2 female Field       3
## 3 male   Field       3
## 4 male   Field       3
## 5 male   Field       3</code></pre>
<p>This is an odd one, since there is one male rower (rowers tend to be
fairly big) along with a bunch of females mostly from sports involving
running. I have a feeling this rower is a “cox”, whose job is
<em>not</em> to row, but to sit in the boat and keep everybody in time
by yelling out “stroke” in rhythm. Since the cox is not rowing, they
need to be light in weight.</p>
<p>Let’s investigate:</p>
<div class="sourceCode" id="cb241"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb241-1" title="1">athletes <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb241-2" title="2"><span class="st">  </span><span class="kw">select</span>(<span class="dt">gender =</span> Sex, <span class="dt">sport =</span> Sport, <span class="dt">ht =</span> Ht, <span class="dt">wt =</span> Wt) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb241-3" title="3"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">cluster =</span> athletes.km<span class="op">$</span>cluster) -&gt;<span class="st"> </span>athletes2a</a>
<a class="sourceLine" id="cb241-4" title="4">athletes2a <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(sport <span class="op">==</span><span class="st"> &quot;Row&quot;</span>, cluster <span class="op">==</span><span class="st"> </span><span class="dv">3</span>)</a></code></pre></div>
<pre><code>## # A tibble: 0 x 5
## # … with 5 variables: gender &lt;chr&gt;, sport &lt;chr&gt;, ht &lt;dbl&gt;, wt &lt;dbl&gt;, cluster &lt;int&gt;</code></pre>
<p>How does this athlete compare to the other rowers?</p>
<div class="sourceCode" id="cb243"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb243-1" title="1">athletes2a <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb243-2" title="2"><span class="st">  </span><span class="kw">filter</span>(sport <span class="op">==</span><span class="st"> &quot;Row&quot;</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb243-3" title="3"><span class="st">  </span><span class="kw">select</span>(ht, wt) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb243-4" title="4"><span class="st">  </span><span class="kw">summary</span>()</a></code></pre></div>
<pre><code>##        ht              wt       
##  Min.   :156.0   Min.   :49.80  
##  1st Qu.:179.3   1st Qu.:72.90  
##  Median :181.8   Median :78.70  
##  Mean   :182.4   Mean   :78.54  
##  3rd Qu.:186.3   3rd Qu.:87.20  
##  Max.   :198.0   Max.   :97.00</code></pre>
<p>The rower that is in cluster 3 is almost the lightest, and also almost
the shortest, of all the rowers.
Cluster 4:</p>
<div class="sourceCode" id="cb245"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb245-1" title="1">athletes2 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(cluster <span class="op">==</span><span class="st"> </span><span class="dv">4</span>) </a></code></pre></div>
<pre><code>## # A tibble: 23 x 3
##    gender sport   cluster
##    &lt;chr&gt;  &lt;chr&gt;     &lt;int&gt;
##  1 female Netball       4
##  2 female Row           4
##  3 female Swim          4
##  4 female Swim          4
##  5 female Swim          4
##  6 female Swim          4
##  7 female Swim          4
##  8 female Field         4
##  9 female T400m         4
## 10 female T400m         4
## # … with 13 more rows</code></pre>
<p>Males, but possibly more muscular ones.</p>
<div class="sourceCode" id="cb247"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb247-1" title="1">athletes2 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(cluster <span class="op">==</span><span class="st"> </span><span class="dv">5</span>) </a></code></pre></div>
<pre><code>## # A tibble: 4 x 3
##   gender sport  cluster
##   &lt;chr&gt;  &lt;chr&gt;    &lt;int&gt;
## 1 male   Field        5
## 2 male   TSprnt       5
## 3 male   TSprnt       5
## 4 male   Tennis       5</code></pre>
<p>More males, from similar sports. I wonder what makes these last two
clusters different?</p>
<p>One more:</p>
<div class="sourceCode" id="cb249"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb249-1" title="1">athletes2 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(cluster <span class="op">==</span><span class="st"> </span><span class="dv">6</span>) </a></code></pre></div>
<pre><code>## # A tibble: 10 x 3
##    gender sport  cluster
##    &lt;chr&gt;  &lt;chr&gt;    &lt;int&gt;
##  1 male   Swim         6
##  2 male   Swim         6
##  3 male   Row          6
##  4 male   TSprnt       6
##  5 male   TSprnt       6
##  6 male   TSprnt       6
##  7 male   T400m        6
##  8 male   WPolo        6
##  9 male   WPolo        6
## 10 male   Tennis       6</code></pre>
<p>These are three of our “big guys”, by the looks of it.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="8" style="list-style-type: lower-alpha">
<li>Add the cluster membership to the data frame you read in from
the file, and do a discriminant analysis treating the clusters as
known groups. You can display the output.</li>
</ol>
<p>Solution</p>
<p><code>MASS</code> is already loaded (for me), so:</p>
<div class="sourceCode" id="cb251"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb251-1" title="1">athletes<span class="fl">.3</span> &lt;-<span class="st"> </span>athletes <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb251-2" title="2"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">cluster =</span> athletes.km<span class="op">$</span>cluster) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb251-3" title="3"><span class="st">  </span><span class="kw">lda</span>(cluster <span class="op">~</span><span class="st"> </span>RCC <span class="op">+</span><span class="st"> </span>WCC <span class="op">+</span><span class="st"> </span>Hc <span class="op">+</span><span class="st"> </span>Hg <span class="op">+</span><span class="st"> </span>Ferr <span class="op">+</span><span class="st"> </span>BMI <span class="op">+</span><span class="st"> </span>SSF <span class="op">+</span><span class="st"> `</span><span class="dt">%Bfat</span><span class="st">`</span> <span class="op">+</span><span class="st"> </span>LBM <span class="op">+</span><span class="st"> </span>Ht <span class="op">+</span><span class="st"> </span>Wt, <span class="dt">data =</span> .)</a></code></pre></div>
<p>We can display all the output now. The
problem here, with 12 groups and 11 variables, is that there is rather
a lot of it:</p>
<div class="sourceCode" id="cb252"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb252-1" title="1">athletes<span class="fl">.3</span></a></code></pre></div>
<pre><code>## Call:
## lda(cluster ~ RCC + WCC + Hc + Hg + Ferr + BMI + SSF + `%Bfat` + 
##     LBM + Ht + Wt, data = .)
## 
## Prior probabilities of groups:
##          1          2          3          4          5          6          7          8          9         10         11         12 
## 0.08415842 0.02970297 0.02475248 0.11386139 0.01980198 0.04950495 0.13366337 0.12871287 0.14356436 0.15346535 0.05445545 0.06435644 
## 
## Group means:
##         RCC      WCC       Hc       Hg      Ferr      BMI       SSF   `%Bfat`      LBM       Ht        Wt
## 1  4.960000 9.729412 45.55294 15.51176 119.29412 25.20706  62.37059 11.151176 79.23529 188.2059  89.25588
## 2  5.343333 6.716667 48.28333 16.63333  81.50000 29.52333  71.15000 12.301667 93.50000 190.4000 106.73333
## 3  4.862000 7.880000 44.64000 15.48000 163.80000 30.91800 112.88000 19.948000 77.76800 177.3200  97.26000
## 4  4.272609 6.439130 39.74783 13.43478  65.52174 19.65652  54.27391 12.119565 47.23696 165.1652  53.79565
## 5  6.000000 8.150000 52.37500 17.87500  52.50000 23.91750  45.27500  8.655000 71.00000 180.5250  77.85000
## 6  5.182000 7.210000 46.44000 15.93000 200.30000 22.96800  47.22000  8.737000 68.60000 180.8200  75.27000
## 7  4.592963 7.292593 42.65926 14.35926  46.03704 22.74333  86.31111 18.587778 58.60296 178.0926  72.02963
## 8  4.919615 6.534615 44.70385 15.13462  82.46154 23.93077  52.94231  9.282308 80.88462 193.0885  89.17692
## 9  4.167241 5.993103 38.24828 12.68966  53.48276 22.05897  96.97241 19.652069 56.45069 178.5828  70.30862
## 10 4.976129 6.458065 45.22903 15.38710  62.06452 22.26258  39.41935  7.274194 68.16129 181.7484  73.47903
## 11 4.336364 8.818182 39.13636 13.21818  70.00000 25.03727 150.16364 26.948182 57.36364 177.1273  78.66364
## 12 4.896154 7.711538 44.09231 14.62308  64.69231 19.83538  45.86923  9.968462 52.68077 171.7769  58.51538
## 
## Coefficients of linear discriminants:
##                  LD1          LD2          LD3         LD4         LD5          LD6           LD7          LD8          LD9         LD10         LD11
## RCC     -1.266192600  0.256106446  0.808206001 -1.30196446 -0.68662990 -1.015303339 -0.2586150774  3.268658092  2.227417465  2.459320033 -3.223590160
## WCC     -0.153469467 -0.078994605  0.205088034  0.09363755  0.17439964 -0.045305705 -0.4887843649 -0.305944872  0.045035808  0.130954678 -0.104354274
## Hc      -0.093307975  0.021992675 -0.012087161 -0.01815509  0.12937102  0.113636476 -0.0404556230 -0.135696729  0.378862179 -0.244242634  0.960241443
## Hg      -0.309019785  0.084450036  0.152385480 -0.26948443  0.42377099  0.255088250 -0.0274859879 -0.065936163 -2.060308226 -0.418372348 -1.406148260
## Ferr    -0.008721007 -0.004551151  0.020550808  0.01356683 -0.01458943  0.014299265  0.0005406742  0.004488197  0.001074682 -0.001292279  0.001923835
## BMI      0.545370372 -0.625999624  1.090740309 -2.75390389 -1.83732490 -0.121556905  0.5594732320 -1.151700601 -0.099913184  0.854373979  0.112541184
## SSF     -0.024252589 -0.023301617  0.008850497  0.03559861 -0.05001738 -0.125402412 -0.0397575804  0.034224172 -0.049027821 -0.005826493  0.057489341
## `%Bfat`  0.242726866 -0.161393823 -0.870521195 -0.10045502  0.15729382  1.006527655 -0.3021704980  0.267305723 -0.317551405  0.611206234  0.110412501
## LBM     -0.158151567 -0.102776410 -1.156645388  0.17357076 -0.21293485  0.388650860 -0.5767730346  0.397152230 -0.688630708  0.895735977  0.511088448
## Ht       0.115146729 -0.138274596  0.210937402 -0.70318391 -0.54935153  0.008858563  0.0444158866 -0.259559694 -0.025683855  0.077943962 -0.024103789
## Wt      -0.116874717  0.168228574  0.637666201  0.71560429  0.81228509 -0.302254866  0.4257184332 -0.045388285  0.672740432 -0.963283281 -0.478482727
## 
## Proportion of trace:
##    LD1    LD2    LD3    LD4    LD5    LD6    LD7    LD8    LD9   LD10   LD11 
## 0.5493 0.1956 0.1011 0.0579 0.0404 0.0235 0.0191 0.0088 0.0033 0.0010 0.0000</code></pre>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol style="list-style-type: lower-roman">
<li>How many linear discriminants do you have? How many do you
think are important?</li>
</ol>
<p>Solution</p>
<p>Proportion of trace, at the bottom of the output.</p>
<p>It’s hard to draw the line here. The first two, or maybe the first
seven, or something like that. Your call.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="10" style="list-style-type: lower-alpha">
<li>Which variables seem to be important in distinguishing the
clusters? Look only at the linear discriminants that you judged to
be important.</li>
</ol>
<p>Solution</p>
<p>Look at the coefficients of linear discriminants.
This is rather large, since I had 12 clusters, and thus there are
11 <code>LD</code>s.</p>
<p>If we go back to my thought of only using two linear discriminants:
LD1 is mostly <code>RCC</code> positively and <code>BMI</code> negatively, in
that an athlete with large <code>RCC</code> and small <code>BMI</code> will
tend to score high (positive) on LD1. <code>BMI</code> is the familiar
body fat index. LD2 depends on <code>RCC</code> again, but this time
negatively, and maybe percent body fat and <code>LBM</code>. And so on, if
you went on.</p>
<p>It may be that <code>RCC</code> is just very variable anyway, since it
seems to appear just about everywhere.</p>
<p>Extra: we can also look at the means on each variable by cluster,
which is part of the output, in “Group Means”.
Perhaps the easiest thing to eyeball here is the cluster in which a
variable is noticeably biggest (or possibly smallest). For example,
<code>WCC</code> is highest in cluster 4, and while Ferritin is high
there, it is higher still in cluster 5. <code>BMI</code> is highest in
cluster 6 and lowest in clusters 1 and 3. Height is smallest in
cluster 1, with weight being smallest there as well, and weight is
much the biggest in cluster 6.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="11" style="list-style-type: lower-alpha">
<li>Draw a biplot (which shows the first two LDs), drawing the
clusters in different colours. Comment briefly on anything
especially consistent or inconsistent with what you’ve seen so far.</li>
</ol>
<p>Solution</p>
<p>The thing to get the colours is to feed a <code>groups</code> into
<code>ggbiplot</code>. I suspect I need the <code>factor</code> in there
because the clusters are numbers and I want them treated as
categorical (the numbers are labels). Also, note that we will have
a lot of colours here, so I am trying to make them more
distinguishable using <code>scale_colour_brewer</code> from the
<code>RColorBrewer</code> package (loaded at the beginning):</p>
<div class="sourceCode" id="cb254"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb254-1" title="1"><span class="kw">ggbiplot</span>(athletes<span class="fl">.3</span>, <span class="dt">groups =</span> <span class="kw">factor</span>(athletes2<span class="op">$</span>cluster)) <span class="op">+</span></a>
<a class="sourceLine" id="cb254-2" title="2"><span class="st">  </span><span class="kw">scale_colour_brewer</span>(<span class="dt">palette =</span> <span class="st">&quot;Set3&quot;</span>)</a></code></pre></div>
<p><img src="pasias_files/figure-html/unnamed-chunk-157-1.png" width="672" /></p>
<p>What the biplot shows, that we haven’t seen any hint of so far, is
that the clusters are pretty well separated on LD1 and LD2: there is
not a great deal of overlap.</p>
<p>Anyway, low LD1 means high on BMI and low on RCC, as we saw
before. The arrow for RCC points down as well as right, so it’s part
of LD2 as well. There isn’t much else that points up or down, but
percent body fat and LBM do as much as anything. This is all pretty
much what we saw before.</p>
<p>As to where the clusters fall on the picture:</p>
<ul>
<li><p>Cluster 1 in light blue was “small and light”: small BMI, so
ought to be on the right. This cluster’s RCC was also small, which
on balance puts them on the left, but then they should be <em>top</em>
left because RCC points down. I dunno.</p></li>
<li><p>Cluster 2 in dark blue was “more muscular males”, mid-right,
so above average on LD1 but about average on LD2.</p></li>
<li><p>Cluster 3, light green, was “running females” (mostly), lower
left, so below average on both LD1 and LD2.</p></li>
<li><p>Cluster 4, dark green, “more muscular males” again. There is a
lot of overlap with cluster 2.</p></li>
<li><p>Cluster 5, pink, was “yet more males”. Mostly above average on
LD1 and below average on LD2. The latter was what distinguished
these from clusters 4 and 2.</p></li>
<li><p>Cluster 6, red, was “big guys”. The biggest on LD1 and almost
the biggest on LD2.</p></li>
</ul>
<p>There is something a bit confusing in LD1, which contrasts RCC and
BMI. You would expect, therefore, RCC and BMI to be negatively
correlated, but if you look at the cluster means, that isn’t really
the story: for example, cluster 1 has almost the lowest mean on both
variables, and the highest RCC, in cluster 11, goes with a middling
BMI.</p>
<p>I like these colours much better than the default ones. Much easier to
tell apart.
In any case, RCC and BMI seem to be important, so let’s plot them
against each other, coloured by cluster:</p>
<div class="sourceCode" id="cb255"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb255-1" title="1">athletes <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb255-2" title="2"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">cluster =</span> <span class="kw">factor</span>(athletes2<span class="op">$</span>cluster)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb255-3" title="3"><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> RCC, <span class="dt">y =</span> BMI, <span class="dt">colour =</span> cluster)) <span class="op">+</span></a>
<a class="sourceLine" id="cb255-4" title="4"><span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">scale_colour_brewer</span>(<span class="dt">palette =</span> <span class="st">&quot;Paired&quot;</span>)</a></code></pre></div>
<p><img src="pasias_files/figure-html/unnamed-chunk-158-1.png" width="672" /></p>
<p>I decided to create a column called <code>cluster</code> in the data
frame, so that the legend would have a nice clear title. (If you do
the <code>factor(athletes2$cluster)</code> in the <code>ggplot</code>, that
is what will appear as the legend title.)</p>
<p>There seems to be very little relationship here, in terms of an
overall trend on the plot. But at least these two variables do
<em>something</em> to distinguish the clusters. It’s not as clear as
using LD1 and LD2 (as it won’t be, since they’re designed to be the
best at separating the groups), but you can see that the clusters are
at least somewhat distinct.</p>
<p>The “paired” part of the colour palette indicates that successive
colours come in pairs: light and dark of blue, green, red, orange,
purple and brown (if you think of yellow as being “light brown” or
brown as being “dark yellow”, like bananas).</p>
<p>A good resource for RColorBrewer is
<a href="https://moderndata.plot.ly/create-colorful-graphs-in-r-with-rcolorbrewer-and-plotly/">link</a>. The
“qualitative palettes” shown there are for distinguishing groups
(what we want here); the sequential palettes are for distinguishing
values on a continuous scale, and the diverging palettes are for
drawing attention to high and low.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
</div>
<div id="running-jumping-and-throwing-1" class="section level2">
<h2><span class="header-section-number">36.7</span> Running, jumping, and throwing</h2>
<p>The <a href="https://en.wikipedia.org/wiki/Decathlon">decathlon</a> is a men’s<a href="#fn39" class="footnote-ref" id="fnref39"><sup>39</sup></a> track-and-field competition in which competitors complete 10
events over two days as follows, requiring the skills shown:</p>
<table>
<thead>
<tr class="header">
<th align="left">Event</th>
<th align="left">Skills</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">100m</td>
<td align="left">Running, speed</td>
</tr>
<tr class="even">
<td align="left">Long jump</td>
<td align="left">Jumping, speed</td>
</tr>
<tr class="odd">
<td align="left">Shot put</td>
<td align="left">Throwing, strength</td>
</tr>
<tr class="even">
<td align="left">High jump</td>
<td align="left">Jumping, agility</td>
</tr>
<tr class="odd">
<td align="left">400m</td>
<td align="left">Running, speed</td>
</tr>
<tr class="even">
<td align="left">110m hurdles</td>
<td align="left">Running, jumping, speed</td>
</tr>
<tr class="odd">
<td align="left">Discus</td>
<td align="left">Throwing, agility (and maybe strength)</td>
</tr>
<tr class="even">
<td align="left">Pole vault</td>
<td align="left">Jumping, agility</td>
</tr>
<tr class="odd">
<td align="left">Javelin</td>
<td align="left">Throwing, agility</td>
</tr>
<tr class="even">
<td align="left">1500m</td>
<td align="left">Running, endurance</td>
</tr>
</tbody>
</table>

<p>(note: in the pdf version, this table might appear twice.)</p>
<p>These are a mixture of running, jumping and throwing disciplines. The
performance (time, distance or height) achieved in each event is
converted to a number of points using <a href="https://en.wikipedia.org/wiki/Decathlon#Points_system">standard tables</a>.
and the winner of the entire decathlon is the
competitor with the largest total of points. The basic idea is that a “good” performance in an event is worth 1000 points, and the score decreases if the athlete takes more seconds (running) or achieves fewer metres (jumping/throwing).
A good decathlete has to
be at least reasonably good at all the disciplines.</p>
<p>For the decathlon competition at the 2013 Track and Field World
Championship, a record was kept of each competitor’s performance in
each event (for the competitors that competed in all ten
events). These values are in
<a href="http://ritsokiguess.site/datafiles/dec2013.txt">link</a>.</p>
<ol style="list-style-type: lower-alpha">
<li>Read in the data and verify that you have the right number
of variables.</li>
</ol>
<p>Solution</p>
<p>Checking the file, this is delimited by single spaces. You might
be concerned by the quotes; we’ll read them in and see what
happens to them.</p>
<div class="sourceCode" id="cb256"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb256-1" title="1">my_url &lt;-<span class="st"> &quot;http://ritsokiguess.site/datafiles/dec2013.txt&quot;</span></a>
<a class="sourceLine" id="cb256-2" title="2">decathlon0 &lt;-<span class="st"> </span><span class="kw">read_delim</span>(my_url, <span class="st">&quot; &quot;</span>)</a></code></pre></div>
<pre><code>## 
## ── Column specification ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## cols(
##   name = col_character(),
##   x100m = col_double(),
##   long.jump = col_double(),
##   shot.put = col_double(),
##   high.jump = col_double(),
##   x400m = col_double(),
##   x110mh = col_double(),
##   discus = col_double(),
##   pole.vault = col_double(),
##   javelin = col_double(),
##   x1500m = col_double()
## )</code></pre>
<div class="sourceCode" id="cb258"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb258-1" title="1">decathlon0</a></code></pre></div>
<pre><code>## # A tibble: 24 x 11
##    name               x100m long.jump shot.put high.jump x400m x110mh discus pole.vault javelin x1500m
##    &lt;chr&gt;              &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;
##  1 Ashton Eaton        10.4      7.73     14.4      1.93  46.0   13.7   45          5.2    64.8   270.
##  2 Damian Warner       10.4      7.39     14.2      2.05  48.4   14.0   44.1        4.8    64.7   270.
##  3 Rico Freimuth       10.6      7.22     14.8      1.99  48.0   13.9   48.7        4.9    56.2   278.
##  4 Mihail Dudas        10.7      7.51     13.4      1.96  47.7   14.6   44.1        4.9    59.1   267.
##  5 Michael Schrader    10.7      7.85     14.6      1.99  47.7   14.3   46.4        5      65.7   265.
##  6 Carlos Chinin       10.8      7.54     14.5      1.96  48.8   14.0   45.8        5.1    60.0   276.
##  7 Gunnar Nixon        10.8      7.8      14.7      2.14  48.6   14.6   42.4        4.6    58.0   276.
##  8 Eelco Sintnicolaas  10.8      7.65     14.1      2.02  48.2   14.2   39.2        5.3    56.8   265.
##  9 Pascal Behrenbruch  11.0      7.19     15.9      1.99  48.4   14.5   45.7        4.7    67.1   277.
## 10 Willem Coertzen     11.0      7.44     13.9      2.05  48.3   14.3   43.2        4.5    69.4   265.
## # … with 14 more rows</code></pre>
<p>The names got shortened for display, but the quotes seem to have
properly disappeared.</p>
<p>Note that the columns that would otherwise start with digits have
<code>x</code> on the front of their names, so as to guarantee that the
column names are legal variable names (and thus won’t require any
special treatment later).</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="2" style="list-style-type: lower-alpha">
<li>Some of the performances are times in seconds, and some of
them are distances (or heights) in metres. Also, some of the columns
are more variable than others. Produce a matrix of standardized
performances in each event, making sure not to try to standardize
the names!</li>
</ol>
<p>Solution</p>
<p><code>scale</code> is what I am trying to hint towards. Leave off the
first column. I would rather specify this by name than by
number. (People have an annoying habit of changing the order of
columns, but the column <em>name</em> is more work to change and
thus it is less likely that it will change.)</p>
<div class="sourceCode" id="cb260"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb260-1" title="1">decathlon0 <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb260-2" title="2"><span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>name) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb260-3" title="3"><span class="st">  </span><span class="kw">scale</span>() -&gt;<span class="st"> </span>decathlon</a>
<a class="sourceLine" id="cb260-4" title="4"><span class="kw">round</span>(decathlon, <span class="dv">2</span>)</a></code></pre></div>
<pre><code>##       x100m long.jump shot.put high.jump x400m x110mh discus pole.vault javelin x1500m
##  [1,] -2.21      1.24     0.29     -0.95 -2.43  -1.77   0.27       1.10    0.55  -0.49
##  [2,] -1.92      0.16     0.03      0.74 -0.46  -1.23  -0.06      -0.39    0.52  -0.46
##  [3,] -1.33     -0.38     0.96     -0.11 -0.75  -1.37   1.71      -0.02   -1.17   0.63
##  [4,] -1.08      0.54    -1.24     -0.53 -1.02   0.17  -0.09      -0.02   -0.60  -0.93
##  [5,] -0.87      1.62     0.57     -0.11 -1.08  -0.50   0.82       0.36    0.72  -1.10
##  [6,] -0.69      0.64     0.46     -0.53 -0.13  -1.03   0.59       0.73   -0.42   0.37
##  [7,] -0.48      1.46     0.77      2.01 -0.33   0.13  -0.73      -1.14   -0.82   0.35
##  [8,] -0.45      0.99    -0.21      0.32 -0.59  -0.74  -1.95       1.48   -1.06  -1.20
##  [9,] -0.10     -0.47     2.68     -0.11 -0.46  -0.12   0.53      -0.76    1.00   0.54
## [10,] -0.10      0.32    -0.54      0.74 -0.53  -0.47  -0.40      -1.51    1.45  -1.21
## [11,] -0.02      0.03    -0.54      0.74 -0.47  -0.39  -0.09       1.85   -0.52   0.50
## [12,] -0.02      0.26    -0.10     -0.53 -0.13   0.69   1.42      -1.14   -2.26   0.06
## [13,]  0.01     -0.12    -0.02     -1.37  1.80   1.60   0.37      -1.51    1.46   1.82
## [14,]  0.33     -0.03    -0.02     -1.37 -0.62   0.24   0.81      -0.02    1.30  -1.31
## [15,]  0.40      0.95    -1.04      0.74  0.03   0.33  -1.20       0.73    0.65   0.64
## [16,]  0.47     -0.79     0.36     -0.11  0.04  -0.68  -0.09       0.36   -0.05  -0.05
## [17,]  0.57     -0.19    -0.60      0.32  1.07   1.51  -0.69      -1.51   -0.95   0.72
## [18,]  0.61     -2.09    -1.63     -1.37 -0.24  -0.32  -2.39       0.73    0.46   0.36
## [19,]  0.75      0.16     1.03      1.59  0.57  -0.16   0.70       0.73   -0.42   0.88
## [20,]  0.82     -0.25    -0.86      1.59  1.36   1.74  -0.94      -0.02   -0.49   2.07
## [21,]  0.89      0.51    -0.73      0.74  0.47  -0.68   0.41       1.10    0.80  -1.14
## [22,]  1.24     -0.69     1.07     -0.11  0.73   0.06   1.26       0.36    0.16  -0.02
## [23,]  1.56     -2.28     0.98     -1.80  1.32   1.18  -0.69      -1.51   -1.44  -1.83
## [24,]  1.63     -1.58    -1.69     -0.53  1.85   1.80   0.39      -0.02    1.11   0.78
## attr(,&quot;scaled:center&quot;)
##      x100m  long.jump   shot.put  high.jump      x400m     x110mh     discus pole.vault 
##  10.977083   7.339167  14.209583   1.997500  48.960000  14.512500  44.288333   4.904167 
##    javelin     x1500m 
##  62.069583 273.306667 
## attr(,&quot;scaled:scale&quot;)
##      x100m  long.jump   shot.put  high.jump      x400m     x110mh     discus pole.vault 
## 0.28433720 0.31549708 0.61480629 0.07091023 1.20878667 0.44795429 2.60828224 0.26780779 
##    javelin     x1500m 
## 5.01529875 7.22352899</code></pre>
<p>I think the matrix of standardized values is small enough to look at
all of, particularly if I round off the values to a small number of
decimals. (Note that the means and SDs
appear at the bottom as “attributes”.)</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="3" style="list-style-type: lower-alpha">
<li>We are going to make a scree plot to decide on the number
of clusters our K-means clustering should use. Using a loop, or
otherwise,<a href="#fn40" class="footnote-ref" id="fnref40"><sup>40</sup></a> obtain the total within-cluster sum of squares for these
data for each number of clusters for 2 up to 20.</li>
</ol>
<p>Solution</p>
<p>Having kind of given the game away in the footnote, I guess I now
have to keep up my end of the deal and show you the obvious way
and the clever way.
The obvious way is to do a Python-style loop, thus:</p>
<div class="sourceCode" id="cb262"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb262-1" title="1">maxclust</a></code></pre></div>
<pre><code>## [1] 20</code></pre>
<div class="sourceCode" id="cb264"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb264-1" title="1">w &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb264-2" title="2"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span>maxclust) {</a>
<a class="sourceLine" id="cb264-3" title="3">  sol &lt;-<span class="st"> </span><span class="kw">kmeans</span>(decathlon, i, <span class="dt">nstart =</span> <span class="dv">20</span>)</a>
<a class="sourceLine" id="cb264-4" title="4">  w[i] &lt;-<span class="st"> </span>sol<span class="op">$</span>tot.withinss</a>
<a class="sourceLine" id="cb264-5" title="5">}</a>
<a class="sourceLine" id="cb264-6" title="6">w</a></code></pre></div>
<pre><code>##  [1]        NA 175.03246 151.08750 131.30247 113.59681 102.61744  89.50800  78.89089
##  [9]  68.99662  60.77665  54.11902  47.64227  41.55046  35.39181  29.52008  25.05344
## [17]  21.30947  17.28444  13.80627  10.44197</code></pre>
<p>I defined <code>maxclust</code> earlier, surreptitiously. (Actually, what
happened was that I changed my mind about how many clusters I wanted
you to go up to, so that instead of hard-coding the maximum number of
clusters, I decided to put it in a variable so that I only had to
change it once if I changed my mind again.)</p>
<p>I decided to split the stuff within the loop into two lines, first
getting the <span class="math inline">\(i\)</span>-cluster solution, and then pulling out the total
within-cluster sum of squares from it and saving it in the right place
in <code>w</code>. You can do it in one step or two; I don’t mind.</p>
<p>The first value in <code>w</code> is missing, because we didn’t calculate
a value for 1 cluster (so that this <code>w</code> has 20 values, one of
which is missing).</p>
<p>Not that there’s anything wrong with this,<a href="#fn41" class="footnote-ref" id="fnref41"><sup>41</sup></a> and if it works, it’s good, but the
True R Way<a href="#fn42" class="footnote-ref" id="fnref42"><sup>42</sup></a> is not to use a
loop, but get the whole thing in one shot.
The first stage is to figure out what you want to do for some number of clusters. In this case, it’s something like this:</p>
<div class="sourceCode" id="cb266"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb266-1" title="1"><span class="kw">kmeans</span>(decathlon, <span class="dv">3</span>, <span class="dt">nstart =</span> <span class="dv">20</span>)<span class="op">$</span>tot.withinss</a></code></pre></div>
<pre><code>## [1] 151.0875</code></pre>
<p>There’s nothing special about 3; any number will do.</p>
<p>The second stage is to run this for each desired number of
clusters, without using a loop.
There are two parts to this, in my favoured way of doing it. First, write a function that will get the total within-group sum of squares for any K-means analysis for any number of clusters (input) for any dataframe (also input):</p>
<div class="sourceCode" id="cb268"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb268-1" title="1">twss &lt;-<span class="st"> </span><span class="cf">function</span>(i, d) {</a>
<a class="sourceLine" id="cb268-2" title="2">  ans &lt;-<span class="st"> </span><span class="kw">kmeans</span>(d, i, <span class="dt">nstart =</span> <span class="dv">20</span>)</a>
<a class="sourceLine" id="cb268-3" title="3">  ans<span class="op">$</span>tot.withinss</a>
<a class="sourceLine" id="cb268-4" title="4">}</a></code></pre></div>
<p>The value of doing it this way is that you only ever have to write this function once, and you can use it for any K-means analysis you ever do afterwards. Or, copy this one and use it yourself.</p>
<p>Let’s make sure it works:</p>
<div class="sourceCode" id="cb269"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb269-1" title="1"><span class="kw">twss</span>(<span class="dv">3</span>, decathlon)</a></code></pre></div>
<pre><code>## [1] 151.0875</code></pre>
<p>Check.</p>
<p>Second, use <code>rowwise</code> to work out the total within-group sum of squares for a variety of numbers of clusters. What you use depends on how much data you have, and therefore how many clusters you think it would be able to support (a smallish fraction of the total number of observations). I went from 2 to 20 before, so I’ll do that again:</p>
<div class="sourceCode" id="cb271"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb271-1" title="1"><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">2</span><span class="op">:</span><span class="dv">20</span>) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb271-2" title="2"><span class="st">  </span><span class="kw">rowwise</span>() <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb271-3" title="3"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">wss =</span> <span class="kw">twss</span>(clusters, decathlon)) -&gt;<span class="st"> </span>wsss</a>
<a class="sourceLine" id="cb271-4" title="4">wsss</a></code></pre></div>
<pre><code>## # A tibble: 19 x 2
## # Rowwise: 
##    clusters   wss
##       &lt;int&gt; &lt;dbl&gt;
##  1        2 175. 
##  2        3 151. 
##  3        4 131. 
##  4        5 114. 
##  5        6 100. 
##  6        7  89.5
##  7        8  78.9
##  8        9  69.5
##  9       10  60.8
## 10       11  54.1
## 11       12  47.6
## 12       13  41.4
## 13       14  35.4
## 14       15  30.9
## 15       16  25.1
## 16       17  21.0
## 17       18  17.3
## 18       19  13.8
## 19       20  10.8</code></pre>
<p>This got a name that was <code>wss</code> with an extra <code>s</code>. Sometimes my imagination runs out.</p>
<p>There was (still is) also a function <code>sapply</code> that does the
same thing.
I
learned <code>sapply</code> and friends a long time ago, and now, with the
arrival of <code>rowwise</code>, I think I need to unlearn them.<a href="#fn43" class="footnote-ref" id="fnref43"><sup>43</sup></a></p>
<p>Extra: I made a post on Twitter, <a href="https://twitter.com/KenButler12/status/1100133496637542401">link</a>.
To which Malcolm Barrett replied with this: <a href="https://twitter.com/malco_barrett/status/1100141130186780672">link</a>
and this: <a href="https://twitter.com/malco_barrett/status/1100140736945647616">link</a>.
So now you know all about the Four Noble R Truths.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="4" style="list-style-type: lower-alpha">
<li>Using what you calculated in the previous part, draw a scree
plot. How does your
scree plot tell you that 5 is a possible number of clusters? Explain
briefly.</li>
</ol>
<p>Solution</p>
<p>This requires a teeny bit of care. If you went the loop way, what I
called <code>w</code> has a missing value first (unless you were
especially careful), so you have to plot it against <em>1</em> through 20:</p>
<div class="sourceCode" id="cb273"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb273-1" title="1"><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">1</span><span class="op">:</span>maxclust, <span class="dt">wss =</span> w) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb273-2" title="2"><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> clusters, <span class="dt">y =</span> wss)) <span class="op">+</span></a>
<a class="sourceLine" id="cb273-3" title="3"><span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>()</a></code></pre></div>
<pre><code>## Warning: Removed 1 rows containing missing values (geom_point).</code></pre>
<pre><code>## Warning: Removed 1 row(s) containing missing values (geom_path).</code></pre>
<p><img src="pasias_files/figure-html/freddo-1.png" width="672" /></p>
<p>The warning message is to say that you don’t have a total
within-cluster sum of squares for 1 cluster, which you knew already.</p>
<p>Or you can save the data frame first and then feed it into
<code>ggplot</code>.</p>
<p>If you went the <code>rowwise</code> way, you will have the <code>wss</code>
values for 2 through 20 clusters already in a data
frame, so it is a fair bit simpler:</p>
<div class="sourceCode" id="cb276"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb276-1" title="1">wsss <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb276-2" title="2"><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> clusters, <span class="dt">y =</span> wss)) <span class="op">+</span></a>
<a class="sourceLine" id="cb276-3" title="3"><span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>()</a></code></pre></div>
<p><img src="pasias_files/figure-html/bilharzia-1.png" width="672" /></p>
<p>There is, I suppose, the tiniest elbow at 5 clusters. It’s not very
clear, though. I would have liked it to be clearer.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="5" style="list-style-type: lower-alpha">
<li>Run K-means with 5 clusters. Produce an output that shows
which competitors are in which cluster.</li>
</ol>
<p>Solution</p>
<p>If you’re using R Markdown, you might like to start with this:</p>
<div class="sourceCode" id="cb277"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb277-1" title="1"><span class="kw">set.seed</span>(<span class="dv">457299</span>)</a></code></pre></div>
<p>or some other random number seed of your choice. Using
<code>nstart=20</code> or similar will give you the same <em>clustering</em>,
but which cluster is cluster 1 might vary between runs. So if you talk
about cluster 1 (below), and re-knit the document, you might otherwise
find that cluster 1 has changed identity since the last time you
knitted it. (I just remembered that for these solutions.)</p>
<p>Running the <code>kmeans</code> itself is a piece of cake, since you have
done it a bunch of times already (in your loop or <code>rowwise</code>):</p>
<div class="sourceCode" id="cb278"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb278-1" title="1">decathlon<span class="fl">.1</span> &lt;-<span class="st"> </span><span class="kw">kmeans</span>(decathlon, <span class="dv">5</span>, <span class="dt">nstart =</span> <span class="dv">20</span>)</a>
<a class="sourceLine" id="cb278-2" title="2">decathlon<span class="fl">.1</span></a></code></pre></div>
<pre><code>## K-means clustering with 5 clusters of sizes 4, 8, 5, 6, 1
## 
## Cluster means:
##         x100m   long.jump   shot.put     high.jump      x400m     x110mh     discus
## 1  0.75760985 -0.53619092 -0.7922550 -1.554312e-15  1.5180512  1.6631161 -0.2159787
## 2 -0.02051555  0.02245134  0.9034011  2.644188e-01 -0.0589434 -0.3097414  0.6739749
## 3  0.28457995  0.07871177 -0.8288519  2.326886e-01 -0.1588370 -0.3582955 -1.0406594
## 4 -0.97448850  0.64184430 -0.1484207 -2.467909e-01 -1.0216857 -0.5934385  0.2274805
## 5  1.55771620 -2.27947172  0.9765949 -1.798048e+00  1.3236413  1.1775755 -0.6894704
##    pole.vault     javelin     x1500m
## 1 -0.76236268  0.28321676  1.3477946
## 2 -0.10890895 -0.49565010  0.3441300
## 3  1.17932839  0.06548297 -0.1670467
## 4 -0.07779211  0.65707285 -0.9136808
## 5 -1.50916693 -1.43751822 -1.8269002
## 
## Clustering vector:
##  [1] 4 4 2 4 4 2 2 3 2 4 3 2 1 4 3 2 1 3 2 1 3 2 5 1
## 
## Within cluster sum of squares by cluster:
## [1] 18.86978 41.40072 26.24500 27.08131  0.00000
##  (between_SS / total_SS =  50.6 %)
## 
## Available components:
## 
## [1] &quot;cluster&quot;      &quot;centers&quot;      &quot;totss&quot;        &quot;withinss&quot;     &quot;tot.withinss&quot;
## [6] &quot;betweenss&quot;    &quot;size&quot;         &quot;iter&quot;         &quot;ifault&quot;</code></pre>
<p>I displayed the result, so that I would know which of the things I
needed later. The <code>Available components</code> at the bottom is a big
hint with this.</p>
<p>To display who is in which cluster, it’s easiest to
make a data frame of names and clusters and sort it:</p>
<div class="sourceCode" id="cb280"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb280-1" title="1"><span class="kw">tibble</span>(<span class="dt">name =</span> decathlon0<span class="op">$</span>name, <span class="dt">cluster =</span> decathlon<span class="fl">.1</span><span class="op">$</span>cluster) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb280-2" title="2"><span class="st">  </span><span class="kw">arrange</span>(cluster) </a></code></pre></div>
<pre><code>## # A tibble: 24 x 2
##    name               cluster
##    &lt;chr&gt;                &lt;int&gt;
##  1 Sergey Sviridov          1
##  2 Brent Newdick            1
##  3 Maicel Uibo              1
##  4 Keisuke Ushiro           1
##  5 Rico Freimuth            2
##  6 Carlos Chinin            2
##  7 Gunnar Nixon             2
##  8 Pascal Behrenbruch       2
##  9 Eduard Mikhan            2
## 10 Artem Lukyanenko         2
## # … with 14 more rows</code></pre>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="6" style="list-style-type: lower-alpha">
<li>Display the cluster means for all of the events. (This has
already been calculated; you just have to display it.) Find the
cluster mean, looking at all of the events, that is farthest from
zero, and see if you can describe the strengths and weaknesses of the
athletes in that cluster (look at all the events for the cluster that
has that extreme mean). Bear in mind (i) that these are the original
performances standardized, and (ii) for a running event, a
<em>smaller</em> value is better.</li>
</ol>
<p>Solution</p>
<p>This is the thing called <code>centers</code>:<a href="#fn44" class="footnote-ref" id="fnref44"><sup>44</sup></a></p>
<div class="sourceCode" id="cb282"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb282-1" title="1">decathlon<span class="fl">.1</span><span class="op">$</span>centers</a></code></pre></div>
<pre><code>##         x100m   long.jump   shot.put     high.jump      x400m     x110mh     discus
## 1  0.75760985 -0.53619092 -0.7922550 -1.554312e-15  1.5180512  1.6631161 -0.2159787
## 2 -0.02051555  0.02245134  0.9034011  2.644188e-01 -0.0589434 -0.3097414  0.6739749
## 3  0.28457995  0.07871177 -0.8288519  2.326886e-01 -0.1588370 -0.3582955 -1.0406594
## 4 -0.97448850  0.64184430 -0.1484207 -2.467909e-01 -1.0216857 -0.5934385  0.2274805
## 5  1.55771620 -2.27947172  0.9765949 -1.798048e+00  1.3236413  1.1775755 -0.6894704
##    pole.vault     javelin     x1500m
## 1 -0.76236268  0.28321676  1.3477946
## 2 -0.10890895 -0.49565010  0.3441300
## 3  1.17932839  0.06548297 -0.1670467
## 4 -0.07779211  0.65707285 -0.9136808
## 5 -1.50916693 -1.43751822 -1.8269002</code></pre>
<p>My most extreme value is the <span class="math inline">\(-2.28\)</span> in the long jump column, cluster
4. Yours may well be different, since the formation of clusters is
random: it will probably not be the same number cluster, and it might
not even be the same value. Use whatever you have. (I asked you to
find the most extreme one so that the other events in the same cluster
are likely to be extreme as well and you have something to say.)</p>
<p>So I have to look along my cluster 4 row. I see:</p>
<ul>
<li><p>100m run high (bad)</p></li>
<li><p>long jump low (bad)</p></li>
<li><p>shot put high (good)</p></li>
<li><p>high jump low (bad)</p></li>
<li><p>400m run high (bad)</p></li>
<li><p>110m hurdles run high (bad)</p></li>
<li><p>discus lowish (bad)</p></li>
<li><p>pole vault low (bad)</p></li>
<li><p>javelin low (bad)</p></li>
<li><p>1500m low (good)</p></li>
</ul>
<p>The only two good events here are shot put (throwing a heavy ball) and
1500m (a long run). So what these athletes have in common is good strength
and endurance, and bad speed and agility. (You can use my
“skills required” in the table at the top of the question as a guide.)</p>
<p>I said “these athletes”. I actually meant “this athlete”, since
this is the cluster with just Marcus Nilsson in it. I ought to have
checked that we were looking at a cluster with several athletes in it,
and then this question would have made more sense, but the thought
process is the same, so it doesn’t matter so much.</p>
<p>Your cluster may well be different; I’m looking for some sensible
discussion based on the values you have. I’m hoping that the athletes
in your cluster will tend to be good at something and bad at something
else, and the things they are good at (or bad at) will have something
in common.</p>
<p>What would have made more sense would have been to take the
<em>biggest</em> cluster:</p>
<div class="sourceCode" id="cb284"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb284-1" title="1">decathlon<span class="fl">.1</span><span class="op">$</span>size</a></code></pre></div>
<pre><code>## [1] 4 8 5 6 1</code></pre>
<p>which in this case is cluster 3, and then</p>
<div class="sourceCode" id="cb286"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb286-1" title="1">decathlon<span class="fl">.1</span><span class="op">$</span>centers</a></code></pre></div>
<pre><code>##         x100m   long.jump   shot.put     high.jump      x400m     x110mh     discus
## 1  0.75760985 -0.53619092 -0.7922550 -1.554312e-15  1.5180512  1.6631161 -0.2159787
## 2 -0.02051555  0.02245134  0.9034011  2.644188e-01 -0.0589434 -0.3097414  0.6739749
## 3  0.28457995  0.07871177 -0.8288519  2.326886e-01 -0.1588370 -0.3582955 -1.0406594
## 4 -0.97448850  0.64184430 -0.1484207 -2.467909e-01 -1.0216857 -0.5934385  0.2274805
## 5  1.55771620 -2.27947172  0.9765949 -1.798048e+00  1.3236413  1.1775755 -0.6894704
##    pole.vault     javelin     x1500m
## 1 -0.76236268  0.28321676  1.3477946
## 2 -0.10890895 -0.49565010  0.3441300
## 3  1.17932839  0.06548297 -0.1670467
## 4 -0.07779211  0.65707285 -0.9136808
## 5 -1.50916693 -1.43751822 -1.8269002</code></pre>
<p>which says that the eight athletes in cluster 3 are a bit above
average for shot put and discus, and below average for javelin, and,
taking a decision, about average for everything else. This is kind of
odd, since these are all throwing events, but the javelin is propelled
a long way by running fast, and the other two are propelled mainly
using strength rather than speed, so it makes some kind of sense
(after the fact, at least).</p>
<p>My guess is that someone good at javelin is likely to be good at
sprint running and possibly also the long jump, since that depends
primarily on speed, once you have enough technique. Well, one way to
figure out whether I was right:</p>
<div class="sourceCode" id="cb288"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb288-1" title="1"><span class="kw">cor</span>(decathlon)</a></code></pre></div>
<pre><code>##                  x100m   long.jump    shot.put   high.jump        x400m      x110mh
## x100m       1.00000000 -0.61351932 -0.17373396 -0.03703619  0.789091241  0.67372152
## long.jump  -0.61351932  1.00000000  0.08369570  0.46379852 -0.548197160 -0.39484085
## shot.put   -0.17373396  0.08369570  1.00000000  0.02012049 -0.172516054 -0.28310469
## high.jump  -0.03703619  0.46379852  0.02012049  1.00000000  0.015217204 -0.08356323
## x400m       0.78909124 -0.54819716 -0.17251605  0.01521720  1.000000000  0.80285420
## x110mh      0.67372152 -0.39484085 -0.28310469 -0.08356323  0.802854203  1.00000000
## discus     -0.14989960  0.12891051  0.46449586 -0.11770266 -0.068778203 -0.13777771
## pole.vault -0.12087966  0.21976890 -0.19328449  0.13565269 -0.361823592 -0.51871733
## javelin     0.02363715  0.01969302 -0.11313467 -0.12454417 -0.005823468 -0.05246857
## x1500m      0.14913949 -0.11672283 -0.06156793  0.27779220  0.446949386  0.39800522
##                 discus  pole.vault      javelin       x1500m
## x100m      -0.14989960 -0.12087966  0.023637150  0.149139491
## long.jump   0.12891051  0.21976890  0.019693022 -0.116722829
## shot.put    0.46449586 -0.19328449 -0.113134672 -0.061567926
## high.jump  -0.11770266  0.13565269 -0.124544175  0.277792195
## x400m      -0.06877820 -0.36182359 -0.005823468  0.446949386
## x110mh     -0.13777771 -0.51871733 -0.052468568  0.398005215
## discus      1.00000000 -0.10045072  0.020977427  0.019890861
## pole.vault -0.10045072  1.00000000  0.052377148 -0.059888360
## javelin     0.02097743  0.05237715  1.000000000 -0.008858031
## x1500m      0.01989086 -0.05988836 -0.008858031  1.000000000</code></pre>
<p>or, for this, maybe better:</p>
<div class="sourceCode" id="cb290"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb290-1" title="1"><span class="kw">cor</span>(decathlon) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb290-2" title="2"><span class="st">  </span><span class="kw">as.data.frame</span>() <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb290-3" title="3"><span class="st">  </span><span class="kw">rownames_to_column</span>(<span class="st">&quot;event&quot;</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb290-4" title="4"><span class="st">  </span><span class="kw">pivot_longer</span>(<span class="op">-</span>event, <span class="dt">names_to=</span><span class="st">&quot;event2&quot;</span>, <span class="dt">values_to=</span><span class="st">&quot;corr&quot;</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb290-5" title="5"><span class="st">  </span><span class="kw">filter</span>(event <span class="op">&lt;</span><span class="st"> </span>event2) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb290-6" title="6"><span class="st">  </span><span class="kw">arrange</span>(<span class="kw">desc</span>(<span class="kw">abs</span>(corr)))</a></code></pre></div>
<pre><code>## # A tibble: 45 x 3
##    event      event2      corr
##    &lt;chr&gt;      &lt;chr&gt;      &lt;dbl&gt;
##  1 x110mh     x400m      0.803
##  2 x100m      x400m      0.789
##  3 x100m      x110mh     0.674
##  4 long.jump  x100m     -0.614
##  5 long.jump  x400m     -0.548
##  6 pole.vault x110mh    -0.519
##  7 discus     shot.put   0.464
##  8 high.jump  long.jump  0.464
##  9 x1500m     x400m      0.447
## 10 x110mh     x1500m     0.398
## # … with 35 more rows</code></pre>
<p>I should probably talk about the code:</p>
<ul>
<li><p>I want to grab the event names from the row names of the
matrix. This is a bit awkward, because I want to turn the matrix
into a data frame, but if I turn it into a <code>tibble</code>, the row
names will disappear.</p></li>
<li><p>Thus, I turn it into an old-fashioned <code>data.frame</code>, and
then it has row names, which I can grab and put into a column called
<code>event</code>.</p></li>
<li><p>Then I make the data frame longer, creating a column
<code>event2</code> which is the second thing that each correlation will
be between.</p></li>
<li><p>The correlations between an event and itself will be 1, and
between events B and A will be the same as between A and B. So I
take only the rows where the first event is alphabetically less than
the second one.</p></li>
<li><p>Then I arrange them in descending order of <em>absolute</em>
correlation, since a large negative correlation is also interesting.</p></li>
</ul>
<p>There are actually only a few high correlations:</p>
<ul>
<li><p>100m with long jump, 400m and 110m hurdles</p></li>
<li><p>long jump with 100m, high jump and 400m</p></li>
<li><p>shot put with discus</p></li>
<li><p>high jump with long jump</p></li>
<li><p>400m with all the other running events plus long jump</p></li>
<li><p>110m hurdles with the other running events plus pole vault</p></li>
<li><p>discus with shot put</p></li>
<li><p>pole vault with 110m hurdles and maybe 400m</p></li>
<li><p>javelin with <em>nothing</em></p></li>
<li><p>1500m with 400m</p></li>
</ul>
<p>Some of the correlations are negative as expected, since they are
between a running event and a jumping/throwing event (that is, a long distance goes with a small time, both of which are good).</p>
<p>I was wrong about javelin. It seems to be a unique skill in the
decathlon, which is presumably why it’s there: you want 10 events that
are as disparate as possible, rather than things that are highly
correlated.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
</div>
<div id="clustering-the-swiss-bills-1" class="section level2">
<h2><span class="header-section-number">36.8</span> Clustering the Swiss bills</h2>
<p>This question is about the Swiss bank counterfeit bills
again. This time we’re going to ignore whether each bill is
counterfeit or not, and see what groups they break into. Then, at
the end, we’ll see whether cluster analysis was able to pick out the
counterfeit ones or not.</p>
<ol style="list-style-type: lower-alpha">
<li>Read the data in again (just like last time), and look at
the first few rows. This is just the same as before.</li>
</ol>
<p>Solution</p>
<p>The data file was aligned in columns, so:</p>
<div class="sourceCode" id="cb292"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb292-1" title="1">my_url &lt;-<span class="st"> &quot;http://ritsokiguess.site/datafiles/swiss1.txt&quot;</span></a>
<a class="sourceLine" id="cb292-2" title="2">swiss &lt;-<span class="st"> </span><span class="kw">read_table</span>(my_url)</a></code></pre></div>
<pre><code>## 
## ── Column specification ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## cols(
##   length = col_double(),
##   left = col_double(),
##   right = col_double(),
##   bottom = col_double(),
##   top = col_double(),
##   diag = col_double(),
##   status = col_character()
## )</code></pre>
<div class="sourceCode" id="cb294"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb294-1" title="1">swiss</a></code></pre></div>
<pre><code>## # A tibble: 200 x 7
##    length  left right bottom   top  diag status 
##     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;  
##  1   215.  131   131.    9     9.7  141  genuine
##  2   215.  130.  130.    8.1   9.5  142. genuine
##  3   215.  130.  130.    8.7   9.6  142. genuine
##  4   215.  130.  130.    7.5  10.4  142  genuine
##  5   215   130.  130.   10.4   7.7  142. genuine
##  6   216.  131.  130.    9    10.1  141. genuine
##  7   216.  130.  130.    7.9   9.6  142. genuine
##  8   214.  130.  129.    7.2  10.7  142. genuine
##  9   215.  129.  130.    8.2  11    142. genuine
## 10   215.  130.  130.    9.2  10    141. genuine
## # … with 190 more rows</code></pre>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="2" style="list-style-type: lower-alpha">
<li>The variables in this data frame are on different
scales. Standardize them so that they all have mean 0 and standard
deviation 1. (Don’t try to standardize the <code>status</code> column!)</li>
</ol>
<p>Solution</p>
<div class="sourceCode" id="cb296"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb296-1" title="1">swiss.s &lt;-<span class="st"> </span>swiss <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb296-2" title="2"><span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>status) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb296-3" title="3"><span class="st">  </span><span class="kw">scale</span>()</a></code></pre></div>
<p>What kind of thing do we have?</p>
<div class="sourceCode" id="cb297"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb297-1" title="1"><span class="kw">class</span>(swiss.s)</a></code></pre></div>
<pre><code>## [1] &quot;matrix&quot; &quot;array&quot;</code></pre>
<p>so something like this is needed to display some of it (rather than
all of it):</p>
<div class="sourceCode" id="cb299"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb299-1" title="1"><span class="kw">head</span>(swiss.s)</a></code></pre></div>
<pre><code>##          length      left      right     bottom        top      diag
## [1,] -0.2549435  2.433346  2.8299417 -0.2890067 -1.1837648 0.4482473
## [2,] -0.7860757 -1.167507 -0.6347880 -0.9120152 -1.4328473 1.0557460
## [3,] -0.2549435 -1.167507 -0.6347880 -0.4966762 -1.3083061 1.4896737
## [4,] -0.2549435 -1.167507 -0.8822687 -1.3273542 -0.3119759 1.3161027
## [5,]  0.2761888 -1.444496 -0.6347880  0.6801176 -3.6745902 1.1425316
## [6,]  2.1351516  1.879368  1.3450576 -0.2890067 -0.6855997 0.7953894</code></pre>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="3" style="list-style-type: lower-alpha">
<li>We are going to make a scree plot. First, calculate the total
within-cluster SS for each number of clusters from 2 to 10.</li>
</ol>
<p>Solution</p>
<p>When I first made this problem (some years ago),
I thought the obvious answer was a loop, but now that I’ve been
steeped in the Tidyverse a while, I think <code>rowwise</code> is much
clearer, so I’ll do that first.
Start by making a <code>tibble</code> that has one column called <code>clusters</code> containing the numbers 2 through 10:</p>
<div class="sourceCode" id="cb301"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb301-1" title="1"><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">2</span><span class="op">:</span><span class="dv">10</span>)</a></code></pre></div>
<pre><code>## # A tibble: 9 x 1
##   clusters
##      &lt;int&gt;
## 1        2
## 2        3
## 3        4
## 4        5
## 5        6
## 6        7
## 7        8
## 8        9
## 9       10</code></pre>
<p>Now, for each of these numbers of clusters, calculate the total within-cluster sum of squares for <em>it</em> (that number of clusters). To do that, think about how you’d do it for something like three clusters:</p>
<div class="sourceCode" id="cb303"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb303-1" title="1"><span class="kw">kmeans</span>(swiss.s, <span class="dv">3</span>, <span class="dt">nstart =</span> <span class="dv">20</span>)<span class="op">$</span>tot.withinss</a></code></pre></div>
<pre><code>## [1] 576.1284</code></pre>
<p>and then use that within your <code>rowwise</code>:</p>
<div class="sourceCode" id="cb305"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb305-1" title="1"><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">2</span><span class="op">:</span><span class="dv">10</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb305-2" title="2"><span class="st">  </span><span class="kw">rowwise</span>() <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb305-3" title="3"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">wss =</span> <span class="kw">kmeans</span>(swiss.s, clusters, <span class="dt">nstart =</span> <span class="dv">20</span>)<span class="op">$</span>tot.withinss) -&gt;<span class="st"> </span>wssq</a>
<a class="sourceLine" id="cb305-4" title="4">wssq</a></code></pre></div>
<pre><code>## # A tibble: 9 x 2
## # Rowwise: 
##   clusters   wss
##      &lt;int&gt; &lt;dbl&gt;
## 1        2  701.
## 2        3  576.
## 3        4  492.
## 4        5  449.
## 5        6  413.
## 6        7  381.
## 7        8  355.
## 8        9  334.
## 9       10  313.</code></pre>
<p>Another way is to save <em>all</em> the output from the <code>kmeans</code>, in a list-column, and then <em>extract</em> the thing you want, thus:</p>
<div class="sourceCode" id="cb307"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb307-1" title="1"><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">2</span><span class="op">:</span><span class="dv">10</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb307-2" title="2"><span class="st">  </span><span class="kw">rowwise</span>() <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb307-3" title="3"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">km =</span> <span class="kw">list</span>(<span class="kw">kmeans</span>(swiss.s, clusters, <span class="dt">nstart =</span> <span class="dv">20</span>))) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb307-4" title="4"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">wss =</span> km<span class="op">$</span>tot.withinss) -&gt;<span class="st"> </span>wssq<span class="fl">.2</span></a>
<a class="sourceLine" id="cb307-5" title="5">wssq<span class="fl">.2</span></a></code></pre></div>
<pre><code>## # A tibble: 9 x 3
## # Rowwise: 
##   clusters km         wss
##      &lt;int&gt; &lt;list&gt;   &lt;dbl&gt;
## 1        2 &lt;kmeans&gt;  701.
## 2        3 &lt;kmeans&gt;  576.
## 3        4 &lt;kmeans&gt;  492.
## 4        5 &lt;kmeans&gt;  449.
## 5        6 &lt;kmeans&gt;  413.
## 6        7 &lt;kmeans&gt;  383.
## 7        8 &lt;kmeans&gt;  355.
## 8        9 &lt;kmeans&gt;  334.
## 9       10 &lt;kmeans&gt;  313.</code></pre>
<p>The output from <code>kmeans</code> is a collection of things, not just a single number, so when you create the column <code>km</code>, you need to put <code>list</code> around the <code>kmeans</code>, and then you’ll create a list-column. <code>wss</code>, on the other hand, is a single number each time, so no <code>list</code> is needed, and <code>wss</code> is an ordinary column of numbers, labelled <code>dbl</code> at the top.</p>
<p>The most important thing in both of these is to remember the <code>rowwise</code>. Without it, everything will go horribly wrong! This is because <code>kmeans</code> expects a <em>single number</em> for the number of clusters, and <code>rowwise</code> will provide that single number (for the row you are looking at). If you forget the <code>rowwise</code>, the whole column <code>clusters</code> will get fed into <code>kmeans</code> all at once, and <code>kmeans</code> will get horribly confused.</p>
<p>If you insist, do it Python-style as a loop, like this:</p>
<div class="sourceCode" id="cb309"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb309-1" title="1">clus &lt;-<span class="st"> </span><span class="dv">2</span><span class="op">:</span><span class="dv">10</span></a>
<a class="sourceLine" id="cb309-2" title="2">wss<span class="fl">.1</span> &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb309-3" title="3"><span class="cf">for</span> (i <span class="cf">in</span> clus)</a>
<a class="sourceLine" id="cb309-4" title="4">{</a>
<a class="sourceLine" id="cb309-5" title="5">  wss<span class="fl">.1</span>[i] &lt;-<span class="st"> </span><span class="kw">kmeans</span>(swiss.s, i, <span class="dt">nstart =</span> <span class="dv">20</span>)<span class="op">$</span>tot.withinss</a>
<a class="sourceLine" id="cb309-6" title="6">}</a>
<a class="sourceLine" id="cb309-7" title="7">wss<span class="fl">.1</span></a></code></pre></div>
<pre><code>##  [1]       NA 701.2054 576.4660 491.7085 449.3900 413.1265 381.3926 355.3338 333.9496
## [10] 312.8958</code></pre>
<p>Note that there are 10 <code>wss</code> values, but the first one is
missing, since we didn’t do one cluster.<a href="#fn45" class="footnote-ref" id="fnref45"><sup>45</sup></a></p>
<p>The <code>numeric(0)</code> says “<code>wss</code> has nothing in it, but if it had anything, it would be numbers”. Or, you can initialize
<code>wss</code> to however long it’s going to be (here 10), which is
actually more efficient (R doesn’t have to keep making it
“a bit longer”). If you initialize it to length 10, the 10 values will have
<code>NA</code>s in them when you start.
It doesn’t matter what <code>nstart</code> is: Ideally, big enough to have a decent
chance of finding the best clustering, but small enough that it
doesn’t take too long to run.
Whichever way you create your total within-cluster sums of squares, you can use it to make a scree plot (next part).</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="4" style="list-style-type: lower-alpha">
<li><a name="part:howmany">*</a> Make a scree plot (creating a data frame
first if you need). How many clusters do you think you
should use?</li>
</ol>
<p>Solution</p>
<p>The easiest is to use the output from the <code>rowwise</code>,
which I called <code>wssq</code>, this already being a dataframe:</p>
<div class="sourceCode" id="cb311"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb311-1" title="1"><span class="kw">ggplot</span>(wssq, <span class="kw">aes</span>(<span class="dt">x =</span> clusters, <span class="dt">y =</span> wss)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>()</a></code></pre></div>
<p><img src="pasias_files/figure-html/unnamed-chunk-186-1.png" width="672" /></p>
<p>If you did it the loop way, you’ll have to make a data frame
first, which you can then pipe into <code>ggplot</code>:</p>
<div class="sourceCode" id="cb312"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb312-1" title="1"><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">wss =</span> wss<span class="fl">.1</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb312-2" title="2"><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> clusters, <span class="dt">y =</span> wss)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>()</a></code></pre></div>
<pre><code>## Warning: Removed 1 rows containing missing values (geom_point).</code></pre>
<pre><code>## Warning: Removed 1 row(s) containing missing values (geom_path).</code></pre>
<p><img src="pasias_files/figure-html/sasjhgajs-1.png" width="576" /></p>
<p>If you started at 2 clusters, your <code>wss</code> will start at 2
clusters also, and you’ll need to be careful to have something like
<code>clusters=2:10</code> (not <code>1:10</code>) in the definition of your
data frame.</p>
<p>Interpretation: I see a small elbow at 4 clusters, so that’s how many I think we
should use. Any place you can reasonably see an elbow is good.</p>
<p>The warning is about the missing within-cluster total sum of squares
for one cluster, since the loop way didn’t supply a total
within-cluster sum of squares for one cluster.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="5" style="list-style-type: lower-alpha">
<li>Run K-means with the number of clusters that you found in
(<a href="#part:howmany">here</a>). How many bills are in each cluster?</li>
</ol>
<p>Solution</p>
<p>I’m going to start by setting the random number seed (so that
my results don’t change every time I run this). You don’t need
to do that, though you might want to in something like R
Markdown code (for example, in an R Notebook):</p>
<div class="sourceCode" id="cb315"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb315-1" title="1"><span class="kw">set.seed</span>(<span class="dv">457299</span>)</a></code></pre></div>
<p>Now, down to business:</p>
<div class="sourceCode" id="cb316"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb316-1" title="1">swiss<span class="fl">.7</span> &lt;-<span class="st"> </span><span class="kw">kmeans</span>(swiss.s, <span class="dv">4</span>, <span class="dt">nstart =</span> <span class="dv">20</span>)</a>
<a class="sourceLine" id="cb316-2" title="2">swiss<span class="fl">.7</span><span class="op">$</span>size</a></code></pre></div>
<pre><code>## [1] 50 32 68 50</code></pre>
<p>This many. Note that my clusters 1 and 4 (and also 2 and 3) add up to
100 bills. There were 100 genuine and 100 counterfeit bills in the
original data set.
I don’t know why “7”. I just felt like it.
Extra: you might remember that back before I actually <em>ran</em>
K-means on each of the numbers of clusters from 2 to 10. How can we
extract that output? Something like this. Here’s where the output was:</p>
<div class="sourceCode" id="cb318"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb318-1" title="1">wssq<span class="fl">.2</span></a></code></pre></div>
<pre><code>## # A tibble: 9 x 3
## # Rowwise: 
##   clusters km         wss
##      &lt;int&gt; &lt;list&gt;   &lt;dbl&gt;
## 1        2 &lt;kmeans&gt;  701.
## 2        3 &lt;kmeans&gt;  576.
## 3        4 &lt;kmeans&gt;  492.
## 4        5 &lt;kmeans&gt;  449.
## 5        6 &lt;kmeans&gt;  413.
## 6        7 &lt;kmeans&gt;  383.
## 7        8 &lt;kmeans&gt;  355.
## 8        9 &lt;kmeans&gt;  334.
## 9       10 &lt;kmeans&gt;  313.</code></pre>
<p>Now we need to pull out the 4th row and the <code>km</code> column. We need the output as an actual thing, not a data frame, so:</p>
<div class="sourceCode" id="cb320"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb320-1" title="1">wssq<span class="fl">.2</span> <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb320-2" title="2"><span class="st">  </span><span class="kw">filter</span>(clusters <span class="op">==</span><span class="st"> </span><span class="dv">4</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb320-3" title="3"><span class="st">  </span><span class="kw">pull</span>(km) -&gt;<span class="st"> </span>swiss<span class="fl">.7</span>a</a></code></pre></div>
<p>Is that the right thing?</p>
<div class="sourceCode" id="cb321"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb321-1" title="1">swiss<span class="fl">.7</span>a</a></code></pre></div>
<pre><code>## [[1]]
## K-means clustering with 4 clusters of sizes 32, 50, 50, 68
## 
## Cluster means:
##       length       left      right     bottom         top       diag
## 1  1.1475776  0.6848546  0.2855308 -0.5788787 -0.40538184  0.7764051
## 2 -0.5683115  0.2617543  0.3254371  1.3197396  0.04670298 -0.8483286
## 3  0.1062264  0.6993965  0.8352473  0.1927865  1.18251937 -0.9316427
## 4 -0.2002681 -1.0290130 -0.9878119 -0.8397381 -0.71307204  0.9434354
## 
## Clustering vector:
##   [1] 1 4 4 4 4 1 4 4 4 1 1 4 1 4 4 4 4 4 4 4 4 1 1 1 4 1 1 1 1 4 1 4 4 1 1 1 1 4 1 4 4 4
##  [43] 4 1 4 4 4 4 4 4 4 1 4 1 4 4 1 4 1 4 4 4 4 4 4 1 4 4 4 3 4 4 4 4 4 4 4 4 1 4 4 4 4 1
##  [85] 1 4 4 4 1 4 4 1 4 4 4 1 1 4 4 4 3 3 3 3 2 2 3 3 3 3 3 3 3 2 2 3 2 2 2 3 3 2 3 3 2 3
## [127] 3 3 3 3 2 2 3 3 2 2 2 3 2 2 3 2 2 3 2 2 2 3 2 3 2 2 2 2 2 2 2 2 2 3 3 2 2 2 2 3 1 3
## [169] 3 2 3 2 2 2 2 2 2 3 3 3 2 3 3 3 2 2 3 2 3 2 3 3 2 3 2 3 3 3 3 2
## 
## Within cluster sum of squares by cluster:
## [1]  92.37757  95.51948 137.68573 166.12573
##  (between_SS / total_SS =  58.8 %)
## 
## Available components:
## 
## [1] &quot;cluster&quot;      &quot;centers&quot;      &quot;totss&quot;        &quot;withinss&quot;     &quot;tot.withinss&quot;
## [6] &quot;betweenss&quot;    &quot;size&quot;         &quot;iter&quot;         &quot;ifault&quot;</code></pre>
<p>Looks like it. But I should check:</p>
<div class="sourceCode" id="cb323"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb323-1" title="1">swiss<span class="fl">.7</span>a<span class="op">$</span>centers</a></code></pre></div>
<pre><code>## NULL</code></pre>
<p>Ah. <code>swiss.7a</code> is actually a <code>list</code>, as evidenced by the <code>[[1]]</code> at the top of the output, so I get things from it thus:</p>
<div class="sourceCode" id="cb325"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb325-1" title="1">swiss<span class="fl">.7</span>a[[<span class="dv">1</span>]]<span class="op">$</span>centers</a></code></pre></div>
<pre><code>##       length       left      right     bottom         top       diag
## 1  1.1475776  0.6848546  0.2855308 -0.5788787 -0.40538184  0.7764051
## 2 -0.5683115  0.2617543  0.3254371  1.3197396  0.04670298 -0.8483286
## 3  0.1062264  0.6993965  0.8352473  0.1927865  1.18251937 -0.9316427
## 4 -0.2002681 -1.0290130 -0.9878119 -0.8397381 -0.71307204  0.9434354</code></pre>
<p>This would be because it came from a list-column; using <code>pull</code> removed the data-frameness from <code>swiss.7a</code>, but not its listness.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="6" style="list-style-type: lower-alpha">
<li>Make a table showing cluster membership against actual
status (counterfeit or genuine). Are the counterfeit bills mostly
in certain clusters?</li>
</ol>
<p>Solution</p>
<p><code>table</code>. <code>swiss.7$cluster</code> shows the actual
cluster numbers:</p>
<div class="sourceCode" id="cb327"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb327-1" title="1"><span class="kw">table</span>(swiss<span class="op">$</span>status, swiss<span class="fl">.7</span><span class="op">$</span>cluster)</a></code></pre></div>
<pre><code>##              
##                1  2  3  4
##   counterfeit 50  1  0 49
##   genuine      0 31 68  1</code></pre>
<p>Or, if you prefer,</p>
<div class="sourceCode" id="cb329"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb329-1" title="1"><span class="kw">tibble</span>(<span class="dt">obs =</span> swiss<span class="op">$</span>status, <span class="dt">pred =</span> swiss<span class="fl">.7</span><span class="op">$</span>cluster) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb329-2" title="2"><span class="st">  </span><span class="kw">count</span>(obs, pred)</a></code></pre></div>
<pre><code>## # A tibble: 6 x 3
##   obs          pred     n
##   &lt;chr&gt;       &lt;int&gt; &lt;int&gt;
## 1 counterfeit     1    50
## 2 counterfeit     2     1
## 3 counterfeit     4    49
## 4 genuine         2    31
## 5 genuine         3    68
## 6 genuine         4     1</code></pre>
<p>or even</p>
<div class="sourceCode" id="cb331"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb331-1" title="1"><span class="kw">tibble</span>(<span class="dt">obs =</span> swiss<span class="op">$</span>status, <span class="dt">pred =</span> swiss<span class="fl">.7</span><span class="op">$</span>cluster) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb331-2" title="2"><span class="st">  </span><span class="kw">count</span>(obs, pred) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb331-3" title="3"><span class="st">  </span><span class="kw">pivot_wider</span>(<span class="dt">names_from =</span> obs, <span class="dt">values_from =</span> n, <span class="dt">values_fill =</span> <span class="dv">0</span>)</a></code></pre></div>
<pre><code>## # A tibble: 4 x 3
##    pred counterfeit genuine
##   &lt;int&gt;       &lt;int&gt;   &lt;int&gt;
## 1     1          50       0
## 2     2           1      31
## 3     4          49       1
## 4     3           0      68</code></pre>
<p>In my case (yours might be different), 99 of the 100 counterfeit bills
are in clusters 1 and 4, and 99 of the 100 genuine bills are in
clusters 2 and 3.<a href="#fn46" class="footnote-ref" id="fnref46"><sup>46</sup></a> So the
clustering has done a very good job of distinguishing the genuine
bills from the counterfeit ones. (You could imagine, if you were an
employee at the bank, saying that a bill in cluster 1 or 4 is
counterfeit, and being right 99% of the time.) This is kind of a
by-product of the clustering, though: we weren’t <em>trying</em> to
distinguish counterfeit bills (that would have been the discriminant
analysis that we did before); we were just trying to divide them into
groups of different ones, and part of what made them different was
that some of them were genuine bills and some of them were
counterfeit.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
</div>
<div id="grouping-similar-cars-1" class="section level2">
<h2><span class="header-section-number">36.9</span> Grouping similar cars</h2>
<p>The file
<a href="https://raw.githubusercontent.com/nxskok/datafiles/master/car-cluster.csv">link</a> contains
information on seven variables
for 32 different cars. The variables are:</p>
<ul>
<li><p><code>Carname</code>: name of the car (duh!)</p></li>
<li><p><code>mpg</code>: gas consumption in miles per US gallon (higher means the car uses less gas)</p></li>
<li><p><code>disp</code>: engine displacement (total volume of cylinders in engine): higher is more powerful</p></li>
<li><p><code>hp</code>: engine horsepower (higher means a more powerful engine)</p></li>
<li><p><code>drat</code>: rear axle ratio (higher means more powerful but worse gas mileage)</p></li>
<li><p><code>wt</code>: car weight in US tons</p></li>
<li><p><code>qsec</code>: time needed for the car to cover a quarter mile (lower means faster)</p></li>
</ul>
<ol style="list-style-type: lower-alpha">
<li>Read in the data and display its structure. Do you have the
right number of cars and variables?</li>
</ol>
<p>Solution</p>
<div class="sourceCode" id="cb333"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb333-1" title="1">my_url &lt;-<span class="st"> &quot;https://raw.githubusercontent.com/nxskok/datafiles/master/car-cluster.csv&quot;</span></a>
<a class="sourceLine" id="cb333-2" title="2">cars &lt;-<span class="st"> </span><span class="kw">read_csv</span>(my_url)</a></code></pre></div>
<pre><code>## 
## ── Column specification ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## cols(
##   Carname = col_character(),
##   mpg = col_double(),
##   disp = col_double(),
##   hp = col_double(),
##   drat = col_double(),
##   wt = col_double(),
##   qsec = col_double()
## )</code></pre>
<div class="sourceCode" id="cb335"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb335-1" title="1">cars</a></code></pre></div>
<pre><code>## # A tibble: 32 x 7
##    Carname             mpg  disp    hp  drat    wt  qsec
##    &lt;chr&gt;             &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 Mazda RX4          21    160    110  3.9   2.62  16.5
##  2 Mazda RX4 Wag      21    160    110  3.9   2.88  17.0
##  3 Datsun 710         22.8  108     93  3.85  2.32  18.6
##  4 Hornet 4 Drive     21.4  258    110  3.08  3.22  19.4
##  5 Hornet Sportabout  18.7  360    175  3.15  3.44  17.0
##  6 Valiant            18.1  225    105  2.76  3.46  20.2
##  7 Duster 360         14.3  360    245  3.21  3.57  15.8
##  8 Merc 240D          24.4  147.    62  3.69  3.19  20  
##  9 Merc 230           22.8  141.    95  3.92  3.15  22.9
## 10 Merc 280           19.2  168.   123  3.92  3.44  18.3
## # … with 22 more rows</code></pre>
<p>Check, both on number of cars and number of variables.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="2" style="list-style-type: lower-alpha">
<li>The variables are all measured on different scales. Use
<code>scale</code> to produce a matrix of standardized (<span class="math inline">\(z\)</span>-score) values
for the columns of your data that are numbers.</li>
</ol>
<p>Solution</p>
<p>All but the first column needs to be scaled, so:</p>
<div class="sourceCode" id="cb337"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb337-1" title="1">cars <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(<span class="op">-</span>Carname) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">scale</span>() -&gt;<span class="st"> </span>cars.s</a></code></pre></div>
<p>This is a <code>matrix</code>, as we’ve seen before.</p>
<p>Another way is like this:</p>
<div class="sourceCode" id="cb338"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb338-1" title="1">cars <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(<span class="kw">where</span>(is.numeric)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">scale</span>() -&gt;<span class="st"> </span>h</a></code></pre></div>
<p>I would prefer to have a look at my result, so that I can see that it
has sane things in it:</p>
<div class="sourceCode" id="cb339"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb339-1" title="1"><span class="kw">head</span>(cars.s)</a></code></pre></div>
<pre><code>##             mpg        disp         hp       drat           wt       qsec
## [1,]  0.1508848 -0.57061982 -0.5350928  0.5675137 -0.610399567 -0.7771651
## [2,]  0.1508848 -0.57061982 -0.5350928  0.5675137 -0.349785269 -0.4637808
## [3,]  0.4495434 -0.99018209 -0.7830405  0.4739996 -0.917004624  0.4260068
## [4,]  0.2172534  0.22009369 -0.5350928 -0.9661175 -0.002299538  0.8904872
## [5,] -0.2307345  1.04308123  0.4129422 -0.8351978  0.227654255 -0.4637808
## [6,] -0.3302874 -0.04616698 -0.6080186 -1.5646078  0.248094592  1.3269868</code></pre>
<p>or,</p>
<div class="sourceCode" id="cb341"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb341-1" title="1"><span class="kw">head</span>(h)</a></code></pre></div>
<pre><code>##             mpg        disp         hp       drat           wt       qsec
## [1,]  0.1508848 -0.57061982 -0.5350928  0.5675137 -0.610399567 -0.7771651
## [2,]  0.1508848 -0.57061982 -0.5350928  0.5675137 -0.349785269 -0.4637808
## [3,]  0.4495434 -0.99018209 -0.7830405  0.4739996 -0.917004624  0.4260068
## [4,]  0.2172534  0.22009369 -0.5350928 -0.9661175 -0.002299538  0.8904872
## [5,] -0.2307345  1.04308123  0.4129422 -0.8351978  0.227654255 -0.4637808
## [6,] -0.3302874 -0.04616698 -0.6080186 -1.5646078  0.248094592  1.3269868</code></pre>
<p>These look right. Or, perhaps better, this:</p>
<div class="sourceCode" id="cb343"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb343-1" title="1"><span class="kw">summary</span>(cars.s)</a></code></pre></div>
<pre><code>##       mpg               disp               hp               drat        
##  Min.   :-1.6079   Min.   :-1.2879   Min.   :-1.3810   Min.   :-1.5646  
##  1st Qu.:-0.7741   1st Qu.:-0.8867   1st Qu.:-0.7320   1st Qu.:-0.9661  
##  Median :-0.1478   Median :-0.2777   Median :-0.3455   Median : 0.1841  
##  Mean   : 0.0000   Mean   : 0.0000   Mean   : 0.0000   Mean   : 0.0000  
##  3rd Qu.: 0.4495   3rd Qu.: 0.7688   3rd Qu.: 0.4859   3rd Qu.: 0.6049  
##  Max.   : 2.2913   Max.   : 1.9468   Max.   : 2.7466   Max.   : 2.4939  
##        wt               qsec         
##  Min.   :-1.7418   Min.   :-1.87401  
##  1st Qu.:-0.6500   1st Qu.:-0.53513  
##  Median : 0.1101   Median :-0.07765  
##  Mean   : 0.0000   Mean   : 0.00000  
##  3rd Qu.: 0.4014   3rd Qu.: 0.58830  
##  Max.   : 2.2553   Max.   : 2.82675</code></pre>
<p>The mean is exactly zero, for all variables, which is as it should
be. Also, the standardized values look about as they should; even the
extreme ones don’t go beyond <span class="math inline">\(\pm 3\)</span>.</p>
<p>This doesn’t show the standard deviation of each variable, though,
which should be exactly 1 (since that’s what “standardizing”
means). To get <em>that</em>, <em>this</em>:</p>
<div class="sourceCode" id="cb345"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb345-1" title="1"><span class="kw">as_tibble</span>(cars.s) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb345-2" title="2"><span class="st">  </span><span class="kw">summarize</span>(<span class="kw">across</span>(<span class="kw">everything</span>(), <span class="op">~</span><span class="st"> </span><span class="kw">sd</span>(.)))</a></code></pre></div>
<pre><code>## # A tibble: 1 x 6
##     mpg  disp    hp  drat    wt  qsec
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1     1     1     1  1.00     1</code></pre>
<p>The idea here is “take the matrix <code>cars.s</code>, turn it into a data frame, and for each <em>column</em>, calculate the SD of it.”<a href="#fn47" class="footnote-ref" id="fnref47"><sup>47</sup></a></p>
<p>As you realize now, the same idea will get the mean of each column too:</p>
<div class="sourceCode" id="cb347"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb347-1" title="1"><span class="kw">as_tibble</span>(cars.s) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb347-2" title="2"><span class="st">  </span><span class="kw">summarize</span>(<span class="kw">across</span>(<span class="kw">everything</span>(), <span class="op">~</span><span class="st"> </span><span class="kw">mean</span>(.)))</a></code></pre></div>
<pre><code>## # A tibble: 1 x 6
##        mpg      disp       hp      drat       wt     qsec
##      &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;
## 1 7.11e-17 -9.08e-17 1.04e-17 -2.92e-16 4.68e-17 5.30e-16</code></pre>
<p>and we see that the means are all zero, to about 15 decimals, anyway.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="3" style="list-style-type: lower-alpha">
<li>Run a K-means cluster analysis for these data, obtaining 3
clusters, and display the results. Take whatever action you need to
obtain the best (random) result from a number of runs.</li>
</ol>
<p>Solution</p>
<p>The hint at the end says “use <code>nstart</code>”, so something like this:</p>
<div class="sourceCode" id="cb349"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb349-1" title="1"><span class="kw">set.seed</span>(<span class="dv">457299</span>)</a>
<a class="sourceLine" id="cb349-2" title="2">cars<span class="fl">.1</span> &lt;-<span class="st"> </span><span class="kw">kmeans</span>(cars.s, <span class="dv">3</span>, <span class="dt">nstart =</span> <span class="dv">20</span>)</a>
<a class="sourceLine" id="cb349-3" title="3">cars<span class="fl">.1</span></a></code></pre></div>
<pre><code>## K-means clustering with 3 clusters of sizes 12, 6, 14
## 
## Cluster means:
##          mpg       disp         hp       drat         wt       qsec
## 1  0.1384407 -0.5707543 -0.5448163  0.1887816 -0.2454544  0.5491221
## 2  1.6552394 -1.1624447 -1.0382807  1.2252295 -1.3738462  0.3075550
## 3 -0.8280518  0.9874085  0.9119628 -0.6869112  0.7991807 -0.6024854
## 
## Clustering vector:
##  [1] 1 1 1 1 3 1 3 1 1 1 1 3 3 3 3 3 3 2 2 2 1 3 3 3 3 2 2 2 3 1 3 1
## 
## Within cluster sum of squares by cluster:
## [1] 24.95528  7.76019 33.37849
##  (between_SS / total_SS =  64.5 %)
## 
## Available components:
## 
## [1] &quot;cluster&quot;      &quot;centers&quot;      &quot;totss&quot;        &quot;withinss&quot;     &quot;tot.withinss&quot;
## [6] &quot;betweenss&quot;    &quot;size&quot;         &quot;iter&quot;         &quot;ifault&quot;</code></pre>
<p>You don’t need the <code>set.seed</code>, but if you run again, you’ll get
a different answer. With the <code>nstart</code>, you’ll probably get the
same clustering every time you run, but the clusters might have
different numbers, so that when you talk about “cluster 1” and then
re-run, what you were talking about might have moved to cluster 3, say.</p>
<p>If you are using R Markdown, for this reason, having a
<code>set.seed</code> before anything involving random number generation
is a smart move.<a href="#fn48" class="footnote-ref" id="fnref48"><sup>48</sup></a></p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="4" style="list-style-type: lower-alpha">
<li>Display the car names together with which cluster they are
in. If you display them all at once, sort by cluster so that it’s
easier to see which clusters contain which cars. (You may have to make
a data frame first.)</li>
</ol>
<p>Solution</p>
<p>As below. The car names are in the <code>Carname</code> column of the
original <code>cars</code> data frame, and the cluster numbers are in
the <code>cluster</code> part of the output from <code>kmeans</code>. You’ll
need to take some action to display everything (there are only 32
cars, so it’s perfectly all right to display all of them):</p>
<div class="sourceCode" id="cb351"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb351-1" title="1"><span class="kw">tibble</span>(<span class="dt">car =</span> cars<span class="op">$</span>Carname, <span class="dt">cluster =</span> cars<span class="fl">.1</span><span class="op">$</span>cluster) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb351-2" title="2"><span class="st">  </span><span class="kw">arrange</span>(cluster) </a></code></pre></div>
<pre><code>## # A tibble: 32 x 2
##    car            cluster
##    &lt;chr&gt;            &lt;int&gt;
##  1 Mazda RX4            1
##  2 Mazda RX4 Wag        1
##  3 Datsun 710           1
##  4 Hornet 4 Drive       1
##  5 Valiant              1
##  6 Merc 240D            1
##  7 Merc 230             1
##  8 Merc 280             1
##  9 Merc 280C            1
## 10 Toyota Corona        1
## # … with 22 more rows</code></pre>
<p>Or start from the original data frame as read in from the file and
grab only what you want:</p>
<div class="sourceCode" id="cb353"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb353-1" title="1">cars <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb353-2" title="2"><span class="st">  </span><span class="kw">select</span>(Carname) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb353-3" title="3"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">cluster =</span> cars<span class="fl">.1</span><span class="op">$</span>cluster) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb353-4" title="4"><span class="st">  </span><span class="kw">arrange</span>(cluster) </a></code></pre></div>
<pre><code>## # A tibble: 32 x 2
##    Carname        cluster
##    &lt;chr&gt;            &lt;int&gt;
##  1 Mazda RX4            1
##  2 Mazda RX4 Wag        1
##  3 Datsun 710           1
##  4 Hornet 4 Drive       1
##  5 Valiant              1
##  6 Merc 240D            1
##  7 Merc 230             1
##  8 Merc 280             1
##  9 Merc 280C            1
## 10 Toyota Corona        1
## # … with 22 more rows</code></pre>
<p>This time we want to <em>keep</em> the car names and throw away
everything else.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="5" style="list-style-type: lower-alpha">
<li>I have no idea whether 3 is a sensible number of clusters. To
find out, we will draw a scree plot (in a moment). Write a function
that accepts the number of clusters and the (scaled) data,
and returns the total within-cluster sum of squares.</li>
</ol>
<p>Solution</p>
<p>I failed to guess (in conversation with students, back when this was
a question to be handed in) what you might
do. There are two equally good ways to tackle this part and the next:</p>
<ul>
<li><p>Write a function to calculate the total within-cluster sum
of squares (in this part) and somehow use it in the next part,
eg. via <code>rowwise</code>, to get the total
within-cluster sum of squares for <em>each</em> number of clusters.</p></li>
<li><p>Skip the function-writing part and go directly to a loop in
the next part.</p></li>
</ul>
<p>I’m good with either approach: as long as you obtain, somehow, the
total within-cluster sum of squares for each number of clusters, and
use them for making a scree plot, I think you should get the
points for this part and the next.
I’ll talk about the function way here and the loop way in the next part.</p>
<p>The function way is just like the one in the previous question:</p>
<div class="sourceCode" id="cb355"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb355-1" title="1">wss &lt;-<span class="st"> </span><span class="cf">function</span>(howmany, data, <span class="dt">nstart =</span> <span class="dv">20</span>) {</a>
<a class="sourceLine" id="cb355-2" title="2">  <span class="kw">kmeans</span>(data, howmany, <span class="dt">nstart =</span> <span class="dv">20</span>)<span class="op">$</span>tot.withinss</a>
<a class="sourceLine" id="cb355-3" title="3">}</a></code></pre></div>
<p>The data and number of clusters can have any names, as long as you use
whatever input names you chose within the function.</p>
<p>I should probably check that this works, at least on 3
clusters. Before we had</p>
<div class="sourceCode" id="cb356"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb356-1" title="1">cars<span class="fl">.1</span><span class="op">$</span>tot.withinss</a></code></pre></div>
<pre><code>## [1] 66.09396</code></pre>
<p>and the function gives</p>
<div class="sourceCode" id="cb358"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb358-1" title="1"><span class="kw">wss</span>(<span class="dv">3</span>, cars.s)</a></code></pre></div>
<pre><code>## [1] 66.09396</code></pre>
<p>Check.
I need to make sure that I used my scaled <code>cars</code> data, but I
don’t need to say anything about <code>nstart</code>, since that defaults
to the perfectly suitable 20.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="6" style="list-style-type: lower-alpha">
<li>Calculate the total within-group sum of squares for each
number of clusters from 2 to 10, using the function you just wrote.</li>
</ol>
<p>Solution</p>
<p>The loop way. I like to define my possible numbers of clusters into
a vector first:</p>
<div class="sourceCode" id="cb360"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb360-1" title="1">w &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb360-2" title="2">nclus &lt;-<span class="st"> </span><span class="dv">2</span><span class="op">:</span><span class="dv">10</span></a>
<a class="sourceLine" id="cb360-3" title="3"><span class="cf">for</span> (i <span class="cf">in</span> nclus) {</a>
<a class="sourceLine" id="cb360-4" title="4">  w[i] &lt;-<span class="st"> </span><span class="kw">wss</span>(i, cars.s)</a>
<a class="sourceLine" id="cb360-5" title="5">}</a>
<a class="sourceLine" id="cb360-6" title="6">w</a></code></pre></div>
<pre><code>##  [1]       NA 87.29448 66.09396 50.94273 38.22004 29.28816 24.23138 20.76061 17.97491
## [10] 15.19850</code></pre>
<p>Now that I look at this again, it occurs to me that there is no great
need to write a function to do this: you can just do what you need to
do within the loop, like this:</p>
<div class="sourceCode" id="cb362"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb362-1" title="1">w &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb362-2" title="2">nclus &lt;-<span class="st"> </span><span class="dv">2</span><span class="op">:</span><span class="dv">10</span></a>
<a class="sourceLine" id="cb362-3" title="3"><span class="cf">for</span> (i <span class="cf">in</span> nclus) {</a>
<a class="sourceLine" id="cb362-4" title="4">  w[i] &lt;-<span class="st"> </span><span class="kw">kmeans</span>(cars.s, i, <span class="dt">nstart =</span> <span class="dv">20</span>)<span class="op">$</span>tot.withinss</a>
<a class="sourceLine" id="cb362-5" title="5">}</a>
<a class="sourceLine" id="cb362-6" title="6">w</a></code></pre></div>
<pre><code>##  [1]       NA 87.29448 66.09396 50.94273 38.22004 29.28816 24.23138 20.76061 17.33653
## [10] 15.19850</code></pre>
<p>You ought to have an <code>nstart</code> somewhere to make sure that
<code>kmeans</code> gets run a number of times and the best result taken.</p>
<p>If you initialize your <code>w</code> with <code>numeric(10)</code> rather
than <code>numeric(0)</code>, it apparently gets filled with zeroes rather
than <code>NA</code> values. This means, later, when you come to plot your
<code>w</code>-values, the within-cluster total sum of squares will appear
to be zero, a legitimate value, for one cluster, even though it is
definitely not. (Or, I suppose, you could start your loop at 1
cluster, and get a legitimate, though very big, value for it.)
In both of the above cases, the curly brackets are optional because
there is only one line within the loop.<a href="#fn49" class="footnote-ref" id="fnref49"><sup>49</sup></a></p>
<p>What is <em>actually</em> happening here is an implicit
loop-within-a-loop. There is a loop over <code>i</code> that goes over all
clusters, and then there is a loop over another variable, <code>j</code>
say, that loops over the <code>nstart</code> runs that we’re doing for
<code>i</code> clusters, where we find the <code>tot.withinss</code> for
<code>i</code> clusters on the <code>j</code>th run, and if it’s the best one
so far for <code>i</code> clusters, we save it. Or, at least,
<code>kmeans</code> saves it.</p>
<p>Or, using <code>rowwise</code>, which I like better:</p>
<div class="sourceCode" id="cb364"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb364-1" title="1"><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">2</span><span class="op">:</span><span class="dv">10</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb364-2" title="2"><span class="st">  </span><span class="kw">rowwise</span>() <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb364-3" title="3"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">ss =</span> <span class="kw">wss</span>(clusters, cars.s)) -&gt;<span class="st"> </span>wwx</a>
<a class="sourceLine" id="cb364-4" title="4">wwx</a></code></pre></div>
<pre><code>## # A tibble: 9 x 2
## # Rowwise: 
##   clusters    ss
##      &lt;int&gt; &lt;dbl&gt;
## 1        2  87.3
## 2        3  66.1
## 3        4  50.9
## 4        5  38.2
## 5        6  29.3
## 6        7  24.2
## 7        8  21.0
## 8        9  17.3
## 9       10  15.2</code></pre>
<p>Note that <code>w</code> starts at 1, but <code>wwx</code> starts at 2. For
this way, you <em>have</em> to define a function first to calculate the
total within-cluster sum of squares for a given number of clusters. If
you must, you can do the calculation in the <code>mutate</code> rather than writing a function,
but I find that very confusing to read, so I’d rather define the
function first, and then use it later. (The principle is to keep the <code>mutate</code> simple, and put the complexity in the function where it belongs.)</p>
<p>As I say, if you <em>must</em>:</p>
<div class="sourceCode" id="cb366"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb366-1" title="1"><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">2</span><span class="op">:</span><span class="dv">10</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb366-2" title="2"><span class="st">  </span><span class="kw">rowwise</span>() <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb366-3" title="3"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">wss =</span> <span class="kw">kmeans</span>(cars.s, </a>
<a class="sourceLine" id="cb366-4" title="4">                      clusters, </a>
<a class="sourceLine" id="cb366-5" title="5">                      <span class="dt">nstart =</span> <span class="dv">20</span>)<span class="op">$</span>tot.withinss) -&gt;<span class="st"> </span>wwx</a>
<a class="sourceLine" id="cb366-6" title="6">wwx</a></code></pre></div>
<pre><code>## # A tibble: 9 x 2
## # Rowwise: 
##   clusters   wss
##      &lt;int&gt; &lt;dbl&gt;
## 1        2  87.3
## 2        3  66.1
## 3        4  50.9
## 4        5  38.2
## 5        6  29.3
## 6        7  24.2
## 7        8  20.8
## 8        9  17.3
## 9       10  15.2</code></pre>
<p>The upshot of all of this is that if you had obtained a total
within-cluster sum of squares for each number of clusters,
<em>somehow</em>, and it’s correct, you should have gotten some credit<a href="#fn50" class="footnote-ref" id="fnref50"><sup>50</sup></a> for this part and the last part. This is a common principle
of mine, and works on exams as well as assignments; it goes back to
the idea of “get the job done first” that you first saw in C32.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="7" style="list-style-type: lower-alpha">
<li>Make a scree plot, using the total within-cluster sums of
squares values that you calculated in the previous part.</li>
</ol>
<p>Solution</p>
<p>If you did this the loop way, it’s tempting to leap into this:</p>
<div class="sourceCode" id="cb368"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb368-1" title="1">d &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">clusters =</span> nclus, <span class="dt">wss =</span> w)</a></code></pre></div>
<pre><code>## Error in data.frame(clusters = nclus, wss = w): arguments imply differing number of rows: 9, 10</code></pre>
<p>and then wonder why it doesn’t work. The problem is that <code>w</code>
has 10 things in it, including an <code>NA</code> at the front (as a
placeholder for 1 cluster):</p>
<div class="sourceCode" id="cb370"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb370-1" title="1">w</a></code></pre></div>
<pre><code>##  [1]       NA 87.29448 66.09396 50.94273 38.22004 29.28816 24.23138 20.76061 17.33653
## [10] 15.19850</code></pre>
<div class="sourceCode" id="cb372"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb372-1" title="1">nclus</a></code></pre></div>
<pre><code>## [1]  2  3  4  5  6  7  8  9 10</code></pre>
<p>while <code>nclus</code> only has 9. So do something like this instead:</p>
<div class="sourceCode" id="cb374"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb374-1" title="1"><span class="kw">tibble</span>(<span class="dt">clusters =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">wss =</span> w) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb374-2" title="2"><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> clusters, <span class="dt">y =</span> wss)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>()</a></code></pre></div>
<pre><code>## Warning: Removed 1 rows containing missing values (geom_point).</code></pre>
<pre><code>## Warning: Removed 1 row(s) containing missing values (geom_path).</code></pre>
<p><img src="pasias_files/figure-html/unnamed-chunk-217-1.png" width="672" /></p>
<p>This gives a warning because there is no 1-cluster <code>w</code>-value,
but the point is properly omitted from the plot, so the plot you get
is fine.</p>
<p>Or plot the output from <code>rowwise</code>, which is easier since it’s
already a data frame:</p>
<div class="sourceCode" id="cb377"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb377-1" title="1">wwx <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> clusters, <span class="dt">y =</span> wss)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>()</a></code></pre></div>
<p><img src="pasias_files/figure-html/unnamed-chunk-218-1.png" width="672" /></p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="8" style="list-style-type: lower-alpha">
<li>What is a suitable number of clusters for K-means, based on
your scree plot?</li>
</ol>
<p>Solution</p>
<p>That seems to me to have a clear elbow at 6, suggesting six
clusters.<a href="#fn51" class="footnote-ref" id="fnref51"><sup>51</sup></a> Look for where the plot
“turns the corner” from going down to going out, or the point that is the
“last one on the mountain and the first one on the scree”. This
mountainside goes down to 6, and from there it seems to turn the
corner and go out after that.</p>
<p>This is a judgement call, but this particular one is about as clear as
you can expect to see.</p>
<p>I wanted a picture of some real scree. This one shows what I mean:</p>
<p><img src="scree.png" /></p>
<p>Note the rock face and
the loose rock below, which is the scree. Imagine looking at the rock
face and scree from side-on. This is in north Wales, the
other end of Wales from Llanederyn/Llanedeyrn and Caldicot.</p>
<p>The above photo is from <a href="http://www.geograph.org.uk/photo/159935">link</a>.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol style="list-style-type: lower-roman">
<li>Run a K-means analysis using the number of clusters suggested
by your scree plot, and list the car names together with the clusters
they belong to, <em>sorted by cluster</em>.</li>
</ol>
<p>Solution</p>
<p>This is the same idea as above. The <code>arrange</code> idea from above
seems to be the cleanest way to arrange the output:
The K-means analysis is thus:</p>
<div class="sourceCode" id="cb378"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb378-1" title="1">cars<span class="fl">.2</span> &lt;-<span class="st"> </span><span class="kw">kmeans</span>(cars.s, <span class="dv">6</span>, <span class="dt">nstart =</span> <span class="dv">20</span>)</a></code></pre></div>
<p>or use whatever number of clusters you thought was good from your
scree plot.</p>
<p>Then display them:</p>
<div class="sourceCode" id="cb379"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb379-1" title="1">cars <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb379-2" title="2"><span class="st">  </span><span class="kw">select</span>(Carname) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb379-3" title="3"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">cluster =</span> cars<span class="fl">.2</span><span class="op">$</span>cluster) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb379-4" title="4"><span class="st">  </span><span class="kw">arrange</span>(cluster) </a></code></pre></div>
<pre><code>## # A tibble: 32 x 2
##    Carname        cluster
##    &lt;chr&gt;            &lt;int&gt;
##  1 Fiat 128             1
##  2 Honda Civic          1
##  3 Toyota Corolla       1
##  4 Fiat X1-9            1
##  5 Porsche 914-2        1
##  6 Lotus Europa         1
##  7 Mazda RX4            2
##  8 Mazda RX4 Wag        2
##  9 Datsun 710           2
## 10 Merc 280             2
## # … with 22 more rows</code></pre>
<p>The logic to this is the same as above.
I don’t have a good feeling for what the cars within a cluster have in
common, by eyeballing the names, except for possibly a couple of
things: my cluster 1 seems to be mostly family cars, and my cluster 3
appears to contain “boats” (large cars that consume a lot of
gas). Your clusters ought to be about the same in terms of membership,
but might be numbered differently.</p>
<p>Extra: to understand these clusters further, we can use them as input to a
discriminant analysis. There isn’t any real need to run a MANOVA
first, since we kind of know that these groups will be different
(that’s why we ran a cluster analysis).</p>
<p>So, first we’ll make a data frame with the whole original data set
plus the clusters that came out of the K-means. We are adding the
clusters to <code>cars</code>, so it makes sense to use the same ideas as I used
above (without the <code>arrange</code>, that being only for looking at,
and without the <code>select</code>, since this time I want all the
variables that were in <code>cars</code>):</p>
<div class="sourceCode" id="cb381"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb381-1" title="1">carsx &lt;-<span class="st"> </span>cars <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(<span class="dt">cluster =</span> cars<span class="fl">.2</span><span class="op">$</span>cluster)</a></code></pre></div>
<p>Now we fire away:</p>
<div class="sourceCode" id="cb382"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb382-1" title="1">carsx<span class="fl">.1</span> &lt;-<span class="st"> </span><span class="kw">lda</span>(cluster <span class="op">~</span><span class="st"> </span>mpg <span class="op">+</span><span class="st"> </span>disp <span class="op">+</span><span class="st"> </span>hp <span class="op">+</span><span class="st"> </span>drat <span class="op">+</span><span class="st"> </span>wt <span class="op">+</span><span class="st"> </span>qsec, <span class="dt">data =</span> carsx)</a>
<a class="sourceLine" id="cb382-2" title="2">carsx<span class="fl">.1</span></a></code></pre></div>
<pre><code>## Call:
## lda(cluster ~ mpg + disp + hp + drat + wt + qsec, data = carsx)
## 
## Prior probabilities of groups:
##       1       2       3       4       5       6 
## 0.18750 0.21875 0.12500 0.15625 0.21875 0.09375 
## 
## Group means:
##        mpg     disp       hp     drat       wt     qsec
## 1 30.06667  86.6500  75.5000 4.251667 1.873000 18.39833
## 2 20.41429 147.0286 120.4286 3.888571 2.892143 17.62714
## 3 14.60000 340.5000 272.2500 3.675000 3.537500 15.08750
## 4 21.64000 178.1200  93.8000 3.430000 3.096000 20.51400
## 5 16.78571 315.6286 170.0000 3.050000 3.688571 17.32000
## 6 11.83333 457.3333 216.6667 3.053333 5.339667 17.74000
## 
## Coefficients of linear discriminants:
##              LD1           LD2         LD3          LD4          LD5
## mpg  -0.19737944 -0.0155769096 -0.27978549  0.353766928  0.035582922
## disp  0.01950855 -0.0001094137 -0.02090998  0.001034719  0.001680201
## hp    0.02804348  0.0251253160 -0.01727355 -0.015955928 -0.017220548
## drat  0.94348424  1.8928372037  0.56645563  1.264185553 -2.015644662
## wt    0.39068831 -1.3973097325  1.84808828  2.963377419 -0.300573153
## qsec  0.33992344 -0.3010056176 -0.66690927 -0.755053279 -0.738889640
## 
## Proportion of trace:
##    LD1    LD2    LD3    LD4    LD5 
## 0.7977 0.1234 0.0368 0.0299 0.0122</code></pre>
<p>At the bottom (in <code>trace</code>) you see that <code>LD1</code> is clearly
the most important thing for splitting into groups, <code>LD2</code> might
be slightly relevant, and the other <code>LD</code>s are basically
meaningless. So a plot of the first two <code>LD</code>s should tell the story.</p>
<p>Before we get to that, however, we can take a look at the Coefficients
of Linear Discriminants, for <code>LD1</code> and <code>LD2</code>
anyway. <code>LD1</code> depends principally on <code>drat</code>, <code>wt</code>
and <code>qsec</code> (positively) and maybe negatively on
<code>mpg</code>. That means <code>LD1</code> will be large if the car is
powerful, heavy, <em>slow</em> (since a larger <code>qsec</code> means the
car takes longer to go a quarter mile) and consumes a lot of gas. I
think I can summarize this as “powerful”.</p>
<p><code>LD2</code> also depends on <code>drat</code> and <code>wt</code>,
but note the signs: it is contrasting <code>drat</code> (displacement
ratio) with <code>wt</code> (weight), so that a car with a large
displacement ratio relative to its weight would be large (plus) on
<code>LD2</code>. That is, <code>LD2</code> is “powerful for its weight”.</p>
<p>All right, now for a plot, with the points colour-coded by
cluster. There are two ways to do this; the easy one is
<code>ggbiplot</code>. The only weirdness here is that the
<code>cluster</code>s are numbered, so you have to turn that into a factor
first (unless you like shades of blue). I didn’t load the package
first, so I call it here with the package name and the two colons:</p>
<div class="sourceCode" id="cb384"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb384-1" title="1">ggbiplot<span class="op">::</span><span class="kw">ggbiplot</span>(carsx<span class="fl">.1</span>, <span class="dt">groups =</span> <span class="kw">factor</span>(carsx<span class="op">$</span>cluster))</a></code></pre></div>
<p><img src="pasias_files/figure-html/unnamed-chunk-223-1.png" width="672" /></p>
<p>Or you can do the predictions, then plot <code>LD1</code> against
<code>LD2</code>, coloured by cluster:</p>
<div class="sourceCode" id="cb385"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb385-1" title="1">p &lt;-<span class="st"> </span><span class="kw">predict</span>(carsx<span class="fl">.1</span>)</a>
<a class="sourceLine" id="cb385-2" title="2"><span class="kw">data.frame</span>(p<span class="op">$</span>x, <span class="dt">cluster =</span> <span class="kw">factor</span>(carsx<span class="op">$</span>cluster)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb385-3" title="3"><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> LD1, <span class="dt">y =</span> LD2, <span class="dt">colour =</span> cluster)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb385-4" title="4"><span class="st">  </span><span class="kw">coord_fixed</span>()</a></code></pre></div>
<p><img src="pasias_files/figure-html/unnamed-chunk-224-1.png" width="672" /></p>
<p>The pattern of coloured points is the same. The advantage to the
biplot is that you see which original variables contribute to the
<code>LD</code> scores and thus distinguish the clusters; on the second
plot, you have to figure out for yourself which original variables
contribute, and how, to the <code>LD</code> scores.</p>
<p>You should include <code>coord_fixed</code> to make the axis scales the
same, since allowing them to be different will distort the picture
(the picture should come out square). You do the same thing in
multidimensional scaling.</p>
<p>As you see, <code>LD1</code> is doing the best job of separating the
clusters, but <code>LD2</code> is also doing something: separating
clusters 1 and 5, and also 2 and 4 (though 4 is a bit bigger than 2 on
<code>LD1</code> also).</p>
<p>I suggested above that <code>LD1</code> seems to be “powerful”
(on the right) vs. not (on the left). The displacement ratio is a
measure of the power of an engine, so a car
that is large on <code>LD2</code> is powerful for its weight.</p>
<p>Let’s find the clusters I mentioned before. Cluster 3 was the
“boats”: big engines and heavy cars, but not fast. So they
should be large <code>LD1</code> and small (negative)
<code>LD2</code>. Cluster 1 I called “family cars”: they are not
powerful, but have moderate-to-good power for their weight.</p>
<p>With that in mind, we can have a crack at the other clusters. Cluster
2 is neither powerful nor powerful-for-weight (I don’t know these
cars, so can’t
comment further) while cluster 5 is powerful and also powerful for
their weight, so these
might be sports cars. Clusters 6 and 4 are less and more
powerful, both averagely powerful for their size.</p>
</div>
<div id="rating-beer-1" class="section level2">
<h2><span class="header-section-number">36.10</span> Rating beer</h2>
<p>Thirty-two students each rated 10 brands of beer:</p>
<ul>
<li><p>Anchor Steam</p></li>
<li><p>Bass</p></li>
<li><p>Beck’s</p></li>
<li><p>Corona</p></li>
<li><p>Gordon Biersch</p></li>
<li><p>Guinness</p></li>
<li><p>Heineken</p></li>
<li><p>Pete’s Wicked Ale</p></li>
<li><p>Sam Adams</p></li>
<li><p>Sierra Nevada</p></li>
</ul>
<p>The ratings are on a scale of 1 to 9, with a higher
rating being better.
The data are in
<a href="http://ritsokiguess.site/datafiles/beer.txt">link</a>. I
abbreviated the beer names for the data file. I hope you can figure
out which is which.</p>
<ol style="list-style-type: lower-alpha">
<li>Read in the data, and look at the first few rows.</li>
</ol>
<p>Solution</p>
<p>Data values are aligned in columns, but the column headers are
not aligned with them, so <code>read_table2</code>:</p>
<div class="sourceCode" id="cb386"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb386-1" title="1">my_url &lt;-<span class="st"> &quot;http://ritsokiguess.site/datafiles/beer.txt&quot;</span></a>
<a class="sourceLine" id="cb386-2" title="2">beer &lt;-<span class="st"> </span><span class="kw">read_table2</span>(my_url)</a></code></pre></div>
<pre><code>## 
## ── Column specification ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## cols(
##   student = col_character(),
##   AnchorS = col_double(),
##   Bass = col_double(),
##   Becks = col_double(),
##   Corona = col_double(),
##   GordonB = col_double(),
##   Guinness = col_double(),
##   Heineken = col_double(),
##   PetesW = col_double(),
##   SamAdams = col_double(),
##   SierraN = col_double()
## )</code></pre>
<div class="sourceCode" id="cb388"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb388-1" title="1">beer</a></code></pre></div>
<pre><code>## # A tibble: 32 x 11
##    student AnchorS  Bass Becks Corona GordonB Guinness Heineken PetesW SamAdams SierraN
##    &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;
##  1 S001          5     9     7      1       7        6        6      5        9       5
##  2 S008          7     5     6      8       8        4        8      8        7       7
##  3 S015          7     7     5      6       6        1        8      4        7       5
##  4 S022          7     7     5      2       5        8        4      6        8       9
##  5 S029          9     7     3      1       6        8        2      7        6       8
##  6 S036          7     6     4      3       7        6        6      5        4       9
##  7 S043          5     5     5      6       6        4        7      5        5       6
##  8 S050          5     3     1      5       5        5        3      5        5       9
##  9 S057          9     3     2      6       4        6        1      5        3       6
## 10 S064          2     6     6      5       6        4        8      4        4       3
## # … with 22 more rows</code></pre>
<p>32 rows (students), 11 columns (10 beers, plus a column of student
IDs). All seems to be kosher. If beer can be kosher.<a href="#fn52" class="footnote-ref" id="fnref52"><sup>52</sup></a></p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="2" style="list-style-type: lower-alpha">
<li>The researcher who collected the data wants to see which
beers are rated similarly to which other beers. Try to create a
distance matrix from these data and explain why it didn’t do what
you wanted. (Remember to get rid of the <code>student</code> column
first.)</li>
</ol>
<p>Solution</p>
<p>The obvious thing is to feed these ratings into <code>dist</code>
(we are <em>creating</em> distances rather than re-formatting
things that are already distances). We need to skip the first
column, since those are student identifiers:</p>
<div class="sourceCode" id="cb390"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb390-1" title="1">beer <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb390-2" title="2"><span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>student) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb390-3" title="3"><span class="st">  </span><span class="kw">dist</span>() -&gt;<span class="st"> </span>d</a>
<a class="sourceLine" id="cb390-4" title="4"><span class="kw">glimpse</span>(d)</a></code></pre></div>
<pre><code>##  &#39;dist&#39; num [1:496] 9.8 8.49 6.56 8.89 8.19 ...
##  - attr(*, &quot;Size&quot;)= int 32
##  - attr(*, &quot;Diag&quot;)= logi FALSE
##  - attr(*, &quot;Upper&quot;)= logi FALSE
##  - attr(*, &quot;method&quot;)= chr &quot;euclidean&quot;
##  - attr(*, &quot;call&quot;)= language dist(x = .)</code></pre>
<p>The 496 distances are:</p>
<div class="sourceCode" id="cb392"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb392-1" title="1"><span class="dv">32</span> <span class="op">*</span><span class="st"> </span><span class="dv">31</span> <span class="op">/</span><span class="st"> </span><span class="dv">2</span></a></code></pre></div>
<pre><code>## [1] 496</code></pre>
<p>the number of ways of choosing 2 objects out of 32, when order does
not matter.
Feel free to be offended by my choice of the letter <code>d</code> to
denote both data frames (that I didn’t want to give a better name to)
and dissimilarities in <code>dist</code> objects.</p>
<p>You can look at the whole thing if you like, though it is rather
large. A <code>dist</code> object is stored internally as a long vector
(here of 496 values); it’s displayed as a nice triangle. The clue here
is the thing called <code>Size</code>, which indicates that we have a
<span class="math inline">\(32\times 32\)</span> matrix of distances <em>between the 32 students</em>, so
that if we were to go on and do a cluster analysis based on this
<code>d</code>, we’d get a clustering of the <em>students</em> rather than
of the <em>beers</em>, as we want. (If you just print out <code>d</code>,
you’ll see that is of distances between 32 (unlabelled) objects, which
by inference must be the 32 students.)</p>
<p>It might be interesting to do a cluster analysis of the 32 students
(it would tell you which of the students have similar taste in beer),
but that’s not what we have in mind here.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="3" style="list-style-type: lower-alpha">
<li>The R function <code>t()</code> <em>transposes</em> a matrix: that
is, it interchanges rows and columns. Feed the transpose of your
read-in beer ratings into <code>dist</code>. Does this now give
distances between beers?</li>
</ol>
<p>Solution</p>
<p>Again, omit the first column. The pipeline code looks a bit weird:</p>
<div class="sourceCode" id="cb394"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb394-1" title="1">beer <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb394-2" title="2"><span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>student) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb394-3" title="3"><span class="st">  </span><span class="kw">t</span>() <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb394-4" title="4"><span class="st">  </span><span class="kw">dist</span>() -&gt;<span class="st"> </span>d</a></code></pre></div>
<p>so you should feel free to do it in a couple of steps. This way shows
that you can also refer to columns by number:</p>
<div class="sourceCode" id="cb395"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb395-1" title="1">beer <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(<span class="op">-</span><span class="dv">1</span>) -&gt;<span class="st"> </span>beer2</a>
<a class="sourceLine" id="cb395-2" title="2">d &lt;-<span class="st"> </span><span class="kw">dist</span>(<span class="kw">t</span>(beer2))</a></code></pre></div>
<p>Either way gets you to the same place:</p>
<div class="sourceCode" id="cb396"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb396-1" title="1">d</a></code></pre></div>
<pre><code>##           AnchorS     Bass    Becks   Corona  GordonB Guinness Heineken   PetesW SamAdams
## Bass     15.19868                                                                        
## Becks    16.09348 13.63818                                                               
## Corona   20.02498 17.83255 17.54993                                                      
## GordonB  13.96424 11.57584 14.42221 13.34166                                             
## Guinness 14.93318 13.49074 16.85230 20.59126 14.76482                                    
## Heineken 20.66398 15.09967 13.78405 14.89966 14.07125 18.54724                           
## PetesW   11.78983 14.00000 16.37071 17.72005 11.57584 14.28286 19.49359                  
## SamAdams 14.62874 11.61895 14.73092 14.93318 10.90871 15.90597 14.52584 14.45683         
## SierraN  12.60952 15.09967 17.94436 16.97056 11.74734 13.34166 19.07878 13.41641 12.12436</code></pre>
<p>There are 10 beers with these names, so this is good.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="4" style="list-style-type: lower-alpha">
<li>Try to explain briefly why I used <code>as.dist</code> in the
class example (the languages one) but <code>dist</code> here. (Think
about the form of the input to each function.)</li>
</ol>
<p>Solution</p>
<p><code>as.dist</code> is used if you <em>already</em> have
dissimilarities (and you just want to format them right), but
<code>dist</code> is used if you have
<em>data on variables</em> and you want to <em>calculate</em>
dissimilarities.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="5" style="list-style-type: lower-alpha">
<li><a name="part:beer-dendro">*</a> Obtain a clustering of the beers, using Ward’s method. Show
the dendrogram.</li>
</ol>
<p>Solution</p>
<p>This:</p>
<div class="sourceCode" id="cb398"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb398-1" title="1">beer<span class="fl">.1</span> &lt;-<span class="st"> </span><span class="kw">hclust</span>(d, <span class="dt">method =</span> <span class="st">&quot;ward.D&quot;</span>)</a>
<a class="sourceLine" id="cb398-2" title="2"><span class="kw">plot</span>(beer<span class="fl">.1</span>)</a></code></pre></div>
<p><img src="pasias_files/figure-html/khas-1.png" width="672" /></p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="6" style="list-style-type: lower-alpha">
<li>What seems to be a sensible number of clusters? Which
beers are in which cluster?</li>
</ol>
<p>Solution</p>
<p>This is a judgement call. Almost anything sensible is
reasonable. I personally think that two clusters is good, beers
Anchor Steam, Pete’s Wicked Ale, Guinness and Sierra Nevada in
the first, and Bass, Gordon Biersch, Sam Adams, Corona, Beck’s,
and Heineken in the second.
You could make a case for three clusters, splitting off
Corona, Beck’s and Heineken into their own cluster, or even
about 5 clusters as
Anchor Steam, Pete’s Wicked Ale; Guinness, Sierra Nevada; Bass,
Gordon Biersch, Sam Adams; Corona; Beck’s, Heineken.</p>
<p>The idea is to have a number of clusters sensibly smaller than
the 10 observations, so that you are getting some actual
insight. Having 8 clusters for 10 beers wouldn’t be very
informative! (This is where you use your own knowledge about
beer to help you rationalize your choice of number of clusters.)</p>
<p>Extra: as to why the clusters split up like this, I think the four
beers on the left of my dendrogram are “dark” and the six on
the right are “light” (in colour), and I would expect the
students to tend to like all the beers of one type and not so
much all the beers of the other type.</p>
<p>You knew I would have to investigate this, didn’t you? Let’s aim
for a scatterplot of all the ratings for the dark beers,
against the ones for the light beers.</p>
<p>Start with the data frame read in from the file:</p>
<div class="sourceCode" id="cb399"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb399-1" title="1">beer</a></code></pre></div>
<pre><code>## # A tibble: 32 x 11
##    student AnchorS  Bass Becks Corona GordonB Guinness Heineken PetesW SamAdams SierraN
##    &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;
##  1 S001          5     9     7      1       7        6        6      5        9       5
##  2 S008          7     5     6      8       8        4        8      8        7       7
##  3 S015          7     7     5      6       6        1        8      4        7       5
##  4 S022          7     7     5      2       5        8        4      6        8       9
##  5 S029          9     7     3      1       6        8        2      7        6       8
##  6 S036          7     6     4      3       7        6        6      5        4       9
##  7 S043          5     5     5      6       6        4        7      5        5       6
##  8 S050          5     3     1      5       5        5        3      5        5       9
##  9 S057          9     3     2      6       4        6        1      5        3       6
## 10 S064          2     6     6      5       6        4        8      4        4       3
## # … with 22 more rows</code></pre>
<p>The aim is to find the average rating for a dark beer and a light beer
for each student, and then plot them against each other. Does a
student who likes dark beer tend not to like light beer, and vice versa?</p>
<p>Let’s think about what to do first.</p>
<p>We need to: <code>pivot_longer</code> all the rating columns into one, labelled
by <code>name</code> of beer. Then create a variable that is <code>dark</code>
if we’re looking at one of the dark beers and <code>light</code>
otherwise. <code>ifelse</code> works like “if” in a spreadsheet: a
logical thing that is either true or false, followed by a value if
true and a value if false. There is a nice R command <code>%in%</code>
which is <code>TRUE</code> if the thing in the first variable is to be
found somewhere in the list of things given next (here, one of the
apparently dark beers). (Another way to do this, which will appeal to
you more if you like databases, is to create a second data frame with
two columns, the first being the beer names, and the second being
<code>dark</code> or <code>light</code> as appropriate for that beer. Then you
use a “left join” to look up beer type from beer name.)</p>
<p>Next, group by beer type within student. Giving two things to
<code>group_by</code> does it this way: the second thing within
(or “for each of”) the first.</p>
<p>Then calculate the mean
rating within each group. This gives one column of students, one
column of beer types,
and one column of rating means.</p>
<p>Then we need to <code>pivot_wider</code> beer type
into two columns so that we can make a scatterplot of the mean ratings
for light and dark against
each other.</p>
<p>Finally, we make a scatterplot.</p>
<p>You’ll see the final version of this that worked, but rest assured
that there were many intervening versions of this that didn’t!</p>
<p>I urge you to examine the chain one line at a time and see what each
line does. That was how I debugged it.</p>
<p>Off we go:</p>
<div class="sourceCode" id="cb401"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb401-1" title="1">beer <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb401-2" title="2"><span class="st">  </span><span class="kw">pivot_longer</span>(<span class="op">-</span>student, <span class="dt">names_to=</span><span class="st">&quot;name&quot;</span>, <span class="dt">values_to=</span><span class="st">&quot;rating&quot;</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb401-3" title="3"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">beer.type =</span> <span class="kw">ifelse</span>(name <span class="op">%in%</span></a>
<a class="sourceLine" id="cb401-4" title="4"><span class="st">    </span><span class="kw">c</span>(<span class="st">&quot;AnchorS&quot;</span>, <span class="st">&quot;PetesW&quot;</span>, <span class="st">&quot;Guinness&quot;</span>, <span class="st">&quot;SierraN&quot;</span>), <span class="st">&quot;dark&quot;</span>, <span class="st">&quot;light&quot;</span>)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb401-5" title="5"><span class="st">  </span><span class="kw">group_by</span>(student, beer.type) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb401-6" title="6"><span class="st">  </span><span class="kw">summarize</span>(<span class="dt">mean.rat =</span> <span class="kw">mean</span>(rating)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb401-7" title="7"><span class="st">  </span><span class="kw">pivot_wider</span>(<span class="dt">names_from=</span>beer.type, <span class="dt">values_from=</span>mean.rat) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb401-8" title="8"><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> dark, <span class="dt">y =</span> light)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>()</a></code></pre></div>
<p><img src="pasias_files/figure-html/iyrpoydf-1.png" width="672" /></p>
<p>After all that work, not really. There are some students who like
light beer but not dark beer (top left), there is a sort of vague
straggle down to the bottom right, where some students like dark beer
but not light beer, but there are definitely students at the top
right, who just like beer!</p>
<p>The only really empty part of this plot is
the bottom left, which says that these students don’t hate both kinds
of beer; they like either dark beer, or light beer, or both.</p>
<p>The reason a <code>ggplot</code> fits into this “workflow” is that the
first thing you feed into <code>ggplot</code> is a data frame, the one
created by the chain here. Because it’s in a pipeline,
you don’t have the
first thing on <code>ggplot</code>, so you can concentrate on the
<code>aes</code> (“what to plot”) and then the “how to plot it”.
Now back to your regularly-scheduled programming.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="7" style="list-style-type: lower-alpha">
<li>Re-draw your dendrogram with your clusters indicated.</li>
</ol>
<p>Solution</p>
<p><code>rect.hclust</code>, with your chosen number of clusters:</p>
<div class="sourceCode" id="cb402"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb402-1" title="1"><span class="kw">plot</span>(beer<span class="fl">.1</span>)</a>
<a class="sourceLine" id="cb402-2" title="2"><span class="kw">rect.hclust</span>(beer<span class="fl">.1</span>, <span class="dv">2</span>)</a></code></pre></div>
<p><img src="pasias_files/figure-html/sdkjdh-1.png" width="672" /></p>
<p>Or if you prefer 5 clusters, like this:</p>
<div class="sourceCode" id="cb403"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb403-1" title="1"><span class="kw">plot</span>(beer<span class="fl">.1</span>)</a>
<a class="sourceLine" id="cb403-2" title="2"><span class="kw">rect.hclust</span>(beer<span class="fl">.1</span>, <span class="dv">5</span>)</a></code></pre></div>
<p><img src="pasias_files/figure-html/ljashkjsdah-1.png" width="672" /></p>
<p>Same idea with any other number of clusters. If you follow through
with your preferred number of clusters from the previous part, I’m good.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="8" style="list-style-type: lower-alpha">
<li>Obtain a K-means
clustering with 2 clusters.<a href="#fn53" class="footnote-ref" id="fnref53"><sup>53</sup></a>
Note that you will need to use the (transposed)
<em>original data</em>, not the distances. Use a suitably large value of
<code>nstart</code>. (The data are ratings all on the same scale, so
there is no need for <code>scale</code> here. In case you were
wondering.)</li>
</ol>
<p>Solution</p>
<p>I used 20 for <code>nstart</code>. This is the pipe way:</p>
<div class="sourceCode" id="cb404"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb404-1" title="1">beer<span class="fl">.2</span> &lt;-<span class="st"> </span>beer <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb404-2" title="2"><span class="st">  </span><span class="kw">select</span>(<span class="op">-</span><span class="dv">1</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb404-3" title="3"><span class="st">  </span><span class="kw">t</span>() <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb404-4" title="4"><span class="st">  </span><span class="kw">kmeans</span>(<span class="dv">2</span>, <span class="dt">nstart =</span> <span class="dv">20</span>)</a></code></pre></div>
<p>Not everyone (probably) will get the same answer, because of the
random nature of the procedure, but the above code should be good
whatever output it produces.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol style="list-style-type: lower-roman">
<li>How many beers are in each cluster?</li>
</ol>
<p>Solution</p>
<p>On mine:</p>
<div class="sourceCode" id="cb405"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb405-1" title="1">beer<span class="fl">.2</span><span class="op">$</span>size</a></code></pre></div>
<pre><code>## [1] 6 4</code></pre>
<p>You might get the same numbers the other way around.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>
<ol start="10" style="list-style-type: lower-alpha">
<li><em>Which</em> beers are in each cluster? You can do this
simply by obtaining the cluster memberships and using
<code>sort</code> as in the last question, or you can do it as I did
in class by obtaining the
names of the things to be clustered and picking out the ones of
them that are in cluster 1, 2, 3, .)</li>
</ol>
<p>Solution</p>
<p>The cluster numbers of each beer are these:</p>
<div class="sourceCode" id="cb407"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb407-1" title="1">beer<span class="fl">.2</span><span class="op">$</span>cluster</a></code></pre></div>
<pre><code>##  AnchorS     Bass    Becks   Corona  GordonB Guinness Heineken   PetesW SamAdams  SierraN 
##        2        1        1        1        1        2        1        2        1        2</code></pre>
<p>This is what is known in the business as a “named vector”: it has values (the cluster numbers) and each value has a name attached to it (the name of a beer).</p>
<p>Named vectors are handily turned into a data frame with <code>enframe</code>:</p>
<div class="sourceCode" id="cb409"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb409-1" title="1">x &lt;-<span class="st"> </span><span class="kw">enframe</span>(beer<span class="fl">.2</span><span class="op">$</span>cluster)</a>
<a class="sourceLine" id="cb409-2" title="2">x</a></code></pre></div>
<pre><code>## # A tibble: 10 x 2
##    name     value
##    &lt;chr&gt;    &lt;int&gt;
##  1 AnchorS      2
##  2 Bass         1
##  3 Becks        1
##  4 Corona       1
##  5 GordonB      1
##  6 Guinness     2
##  7 Heineken     1
##  8 PetesW       2
##  9 SamAdams     1
## 10 SierraN      2</code></pre>
<p>Or, to go back the other way, <code>deframe</code>:</p>
<div class="sourceCode" id="cb411"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb411-1" title="1"><span class="kw">deframe</span>(x)</a></code></pre></div>
<pre><code>##  AnchorS     Bass    Becks   Corona  GordonB Guinness Heineken   PetesW SamAdams  SierraN 
##        2        1        1        1        1        2        1        2        1        2</code></pre>
<p>or, give the columns better names and arrange them by cluster:</p>
<div class="sourceCode" id="cb413"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb413-1" title="1"><span class="kw">enframe</span>(beer<span class="fl">.2</span><span class="op">$</span>cluster, <span class="dt">name =</span> <span class="st">&quot;beer&quot;</span>, <span class="dt">value =</span> <span class="st">&quot;cluster&quot;</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb413-2" title="2"><span class="st">  </span><span class="kw">arrange</span>(cluster)</a></code></pre></div>
<pre><code>## # A tibble: 10 x 2
##    beer     cluster
##    &lt;chr&gt;      &lt;int&gt;
##  1 Bass           1
##  2 Becks          1
##  3 Corona         1
##  4 GordonB        1
##  5 Heineken       1
##  6 SamAdams       1
##  7 AnchorS        2
##  8 Guinness       2
##  9 PetesW         2
## 10 SierraN        2</code></pre>
<p>These happen to be the same clusters as in my 2-cluster solution using
Ward’s method.</p>
<p><span class="math inline">\(\blacksquare\)</span></p>

</div>
</div>
<div class="footnotes">
<hr />
<ol start="36">
<li id="fn36"><p>Women compete in a similar competition called the <em>heptathlon</em> with seven events.<a href="k-means-cluster-analysis.html#fnref36" class="footnote-back">↩</a></p></li>
<li id="fn37"><p>I grew up in the UK, and when I saw that in an exam, it was code for “the way you’d think is obvious but long, and the otherwise-way is clever but short”. I think this is one of those.<a href="k-means-cluster-analysis.html#fnref37" class="footnote-back">↩</a></p></li>
<li id="fn38"><p>If you haven’t gotten to K-means clustering yet, leave this and save it for later.<a href="k-means-cluster-analysis.html#fnref38" class="footnote-back">↩</a></p></li>
<li id="fn39"><p>Women compete in a similar competition called the <em>heptathlon</em> with seven events.<a href="k-means-cluster-analysis.html#fnref39" class="footnote-back">↩</a></p></li>
<li id="fn40"><p>I grew up in the UK, and when I saw that in an exam, it was code for “the way you’d think is obvious but long, and the otherwise-way is clever but short”. I think this is one of those.<a href="k-means-cluster-analysis.html#fnref40" class="footnote-back">↩</a></p></li>
<li id="fn41"><p>I have to sneak a Seinfeld quote in there somewhere.<a href="k-means-cluster-analysis.html#fnref41" class="footnote-back">↩</a></p></li>
<li id="fn42"><p>Like Buddhism. I keep feeling that R should have something called the Eight Noble Truths or similar. See the Extra at the end of this part.<a href="k-means-cluster-analysis.html#fnref42" class="footnote-back">↩</a></p></li>
<li id="fn43"><p>I wrote that a few years ago, and you may be pleased to learn that I have indeed completely forgotten about <code>apply</code>, <code>sapply</code>, <code>lapply</code> and all the others. I remember struggling through them when I first learned R, but you are in the happy position of never having to worry about them.<a href="k-means-cluster-analysis.html#fnref43" class="footnote-back">↩</a></p></li>
<li id="fn44"><p>We are no longer in the <code>tidyverse</code>, so you no longer have the option of using British or American spelling.<a href="k-means-cluster-analysis.html#fnref44" class="footnote-back">↩</a></p></li>
<li id="fn45"><p>R vectors start from 1, unlike C arrays or Python lists, which start from 0.<a href="k-means-cluster-analysis.html#fnref45" class="footnote-back">↩</a></p></li>
<li id="fn46"><p>This is again where <code>set.seed</code> is valuable: write this text once and it never needs to change.<a href="k-means-cluster-analysis.html#fnref46" class="footnote-back">↩</a></p></li>
<li id="fn47"><p>The <em>scale</em> function can take a data frame, as here, but always produces a matrix. That’s why we had to turn it back into a data frame.<a href="k-means-cluster-analysis.html#fnref47" class="footnote-back">↩</a></p></li>
<li id="fn48"><p>I forgot this, and then realized that I would have to rewrite a whole paragraph. In case you think I remember everything the first time.<a href="k-means-cluster-analysis.html#fnref48" class="footnote-back">↩</a></p></li>
<li id="fn49"><p>I am accustomed to using the curly brackets all the time, partly because my single-line loops have a habit of expanding to more than one line as I embellish what they do, and partly because I’m used to the programming language Perl where the curly brackets are obligatory even with only one line. Curly brackets in Perl serve the same purpose as indentation serves in Python: figuring out what is inside a loop or an <em>if</em> and what is outside.<a href="k-means-cluster-analysis.html#fnref49" class="footnote-back">↩</a></p></li>
<li id="fn50"><p>When this was a question to hand in, which it is not any more.<a href="k-means-cluster-analysis.html#fnref50" class="footnote-back">↩</a></p></li>
<li id="fn51"><p>We do something similar on scree plots for principal components later, but then, for reasons that will become clear then, we take elbow <em>minus 1</em>.<a href="k-means-cluster-analysis.html#fnref51" class="footnote-back">↩</a></p></li>
<li id="fn52"><p>I investigated. It can; in fact, I found a long list of kosher beers that included Anchor Steam.<a href="k-means-cluster-analysis.html#fnref52" class="footnote-back">↩</a></p></li>
<li id="fn53"><p>If you haven’t gotten to K-means clustering yet, leave this and save it for later.<a href="k-means-cluster-analysis.html#fnref53" class="footnote-back">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="hierarchical-cluster-analysis.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="drawing-maps-with-leaflet.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["pasias.pdf"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
